author:: Tom Hombergs
published:: 2023-07 (2판)
tags:: #📘 

- 초판 발행: 2019년 9월
- 2판 발행: 2023년 7월
- 프로덕션 참조: 1300623

> 제 아내 라이크와 제 아이들 노라와 니클라스에게, 소프트웨어 개발 외의 삶이 있다는 것을 정기적으로 상기시켜준 것에 대해 감사합니다.
> – 톰 홈버그

### 저자 소개
톰 홈버그는 소프트웨어 엔지니어, 작가, 그리고 단순함에 대한 너드입니다. 복잡성은 그의 크립토나이트이므로, 그는 복잡한 것들을 자신이 이해할 수 있는 간단한 조각으로 나누기 위해 열심히 노력합니다. 그가 이해할 수 있다면, 다른 모든 사람도 할 수 있습니다. 그는 코드뿐만 아니라 텍스트도 단순화하여, 읽기 즐거운 기사, 책, 개발자 문서를 만듭니다. 톰은 현재 호주 시드니의 Atlassian에서 근무하며, 다른 Atlassian 개발자들이 사용하는 기술 스택의 개발자 경험(DX)을 책임지고 있습니다.

---

# 서문
이 책을 집어 들었다면, 당신은 만들고 있는 소프트웨어의 아키텍처에 관심이 있는 것입니다. 당신은 소프트웨어가 고객의 명시적인 요구사항뿐만 아니라 유지보수성이라는 숨겨진 요구사항과 구조 및 미학에 관한 자신만의 요구사항을 충족하기를 원합니다.
이러한 요구사항을 충족하기는 어렵습니다. 왜냐하면 소프트웨어 프로젝트(또는 일반적으로 프로젝트)는 보통 계획대로 진행되지 않기 때문입니다. 관리자들은 프로젝트 팀 주위에 마감일을 그리고, 외부 파트너들은 약속했던 것과 다르게 API를 만들며, 우리가 의존하는 소프트웨어 제품들은 예상대로 작동하지 않습니다.
그리고 우리 자신의 소프트웨어 아키텍처가 있습니다. 처음에는 모든 것이 명확하고 아름다웠습니다. 그러다 마감일이 우리를 지름길로 내몰았습니다. 이제 아키텍처에 남은 것은 지름길뿐이고, 새로운 기능을 제공하는 데 점점 더 오랜 시간이 걸립니다.
우리의 지름길 중심 아키텍처는 외부 파트너가 망쳐서 변경해야 했던 API에 대응하기 어렵게 만듭니다. 차라리 우리 프로젝트 관리자를 그 파트너와 싸우게 보내서 우리가 합의했던 API를 제공하라고 말하는 것이 더 쉬워 보입니다.
이제 우리는 상황에 대한 모든 통제권을 포기했습니다. 다음 중 하나가 일어날 가능성이 높습니다:

- 프로젝트 관리자가 외부 파트너와의 싸움에서 이길 만큼 강하지 않다
- 외부 파트너가 API 명세서에서 허점을 찾아 자신들이 옳았음을 증명한다
- 외부 파트너가 API를 수정하는 데 <여기에 숫자 입력> 개월이 더 필요하다

이 모든 것은 동일한 결과로 이어집니다 – 마감일이 다가오고 있기 때문에 코드를 빨리 변경해야 합니다. 우리는 또 다른 지름길을 추가합니다.
외부 요인이 우리 소프트웨어 아키텍처의 상태를 좌우하게 두는 대신, 이 책은 우리가 직접 통제권을 갖는 입장을 취합니다. 우리는 소프트웨어를 "유연하고", "확장 가능하며", "적응 가능하게" 만드는 아키텍처를 만들어 이 통제권을 얻습니다. 이러한 아키텍처는 외부 요인에 쉽게 대응하게 하고 우리 등의 많은 압박을 덜어줄 것입니다.

> 1 ‘데드라인’이라는 단어는 아마도 19세기에 유래했으며, 감옥이나 포로 수용소 주위에 그어진 선을 묘사했습니다. 그 선을 넘은 죄수는 총에 맞았습니다. 다음에 누군가 당신 주위에 "데드라인을 그릴" 때 이 정의에 대해 생각해보십시오... 분명 새로운 관점을 열어줄 것입니다. https://www.merriam-webster.com/words-at-play/yourdeadline-wont-kill-you 참조.

## 이 책의 목표
저는 로버트 C. 마틴의 클린 아키텍처와 알리스테어 콕번의 헥사고날 아키텍처와 같은 도메인 중심 아키텍처 스타일에 대한 가용 자원의 실용성에 실망했기 때문에 이 책을 썼습니다.
많은 책과 온라인 자료들은 가치 있는 개념을 설명하지만, 우리가 실제로 그것들을 어떻게 구현할 수 있는지는 설명하지 않습니다. 아마도 어떤 아키텍처 스타일이든 구현하는 방법이 하나 이상이기 때문일 것입니다.
이 책을 통해 저는 헥사고날 아키텍처 또는 "포트와 어댑터" 스타일로 웹 애플리케이션을 만드는 것에 대한 실습 코드 토론을 제공함으로써 이 공백을 메우려고 노력하고 있습니다. 그 목표에 부응하기 위해, 이 책에서 논의된 코드 예제와 개념들은 헥사고날 아키텍처를 구현하는 방법에 대한 저의 해석을 제공합니다. 분명 다른 해석들도 있을 것이며, 제 것이 권위 있다고 주장하지 않습니다.
하지만 이 책의 개념들로부터 영감을 얻어 헥사고날/클린 아키텍처에 대한 자신만의 해석을 만들 수 있기를 바랍니다.

## 이 책의 대상 독자
이 책은 웹 애플리케이션 제작에 참여하는 모든 경험 수준의 소프트웨어 개발자를 대상으로 합니다.
주니어 개발자로서, 당신은 소프트웨어 컴포넌트와 완전한 애플리케이션을 깨끗하고 유지보수 가능한 방식으로 설계하는 방법에 대해 배우게 될 것입니다. 또한 특정 기술을 언제 적용해야 하는지에 대한 몇 가지 논거도 배우게 될 것입니다. 하지만 이 책을 최대한 활용하려면 과거에 웹 애플리케이션을 구축하는 데 참여해 본 경험이 있어야 합니다.
경험 많은 개발자라면, 책의 개념을 자신만의 방식과 비교하고, 바라건대 자신의 소프트웨어 개발 스타일에 조금씩 통합하는 것을 즐길 것입니다.
이 책의 코드 예제는 자바와 코틀린으로 되어 있지만, 모든 논의는 다른 객체 지향 프로그래밍 언어에도 동일하게 적용됩니다. 자바 프로그래머가 아니더라도 다른 언어로 된 객체 지향 코드를 읽을 수 있다면 괜찮을 것입니다. 자바나 프레임워크 특수성이 필요한 몇 군데에서는 제가 설명해 드리겠습니다.

## 예제 애플리케이션
책 전반에 걸쳐 반복되는 주제를 갖기 위해, 대부분의 코드 예제는 온라인으로 돈을 이체하는 예제 웹 애플리케이션의 코드를 보여줍니다. 우리는 그것을 "BuckPal"이라고 부를 것입니다.²

> 2 BuckPal: 빠른 온라인 검색 결과 PayPal이라는 회사가 제 아이디어를 훔쳤고 이름의 일부까지 베꼈다는 사실이 드러났습니다. 농담은 제쳐두고: "PayPal"과 비슷하면서 기존 회사 이름이 아닌 이름을 찾아보세요. 정말 재밌습니다!

BuckPal 애플리케이션은 사용자가 계정을 등록하고, 계정 간에 돈을 이체하고, 계정의 활동(입금 및 출금)을 볼 수 있게 해줍니다.
저는 금융 전문가가 아니므로, 예제 코드를 법적 또는 기능적 정확성을 기준으로 판단하지 마십시오. 오히려 구조와 유지보수성을 기준으로 판단해 주십시오.
소프트웨어 공학 책과 온라인 자료를 위한 예제 애플리케이션의 저주는 우리가 매일 겪는 실제 문제를 강조하기에는 너무 단순하다는 것입니다. 반면에, 예제 애플리케이션은 논의된 개념을 효과적으로 전달하기에 충분히 단순해야 합니다.
이 책 전반에 걸쳐 BuckPal 애플리케이션의 유스케이스를 논의하면서 "너무 단순함"과 "너무 복잡함" 사이의 균형을 찾았기를 바랍니다.
예제 애플리케이션의 코드는 깃허브에서 찾을 수 있습니다.

---

> [!note] 본문 시작

# 1. 유지보수성
이 책은 소프트웨어 아키텍처에 관한 것입니다. 아키텍처의 정의 중 하나는 시스템이나 프로세스의 구조입니다. 우리의 경우, 그것은 소프트웨어 시스템의 구조입니다.
아키텍처는 목적을 가지고 이 구조를 설계하는 것입니다. 우리는 특정 요구사항을 충족시키기 위해 의식적으로 소프트웨어 시스템을 설계합니다. 소프트웨어가 사용자에게 가치를 창출하기 위해 충족해야 하는 기능적 요구사항이 있습니다. 기능이 없으면 소프트웨어는 가치가 없습니다. 왜냐하면 아무런 가치를 생산하지 않기 때문입니다.
소프트웨어가 사용자, 개발자 및 이해관계자에게 고품질로 간주되기 위해 충족해야 하는 품질 요구사항(비기능적 요구사항이라고도 함)도 있습니다. 그러한 품질 요구사항 중 하나가 유지보수성입니다.
만약 제가 유지보수성이라는 품질 속성이 어떤 면에서는 기능보다 더 중요하며, 다른 모든 것보다 유지보수성을 위해 소프트웨어를 설계해야 한다고 말한다면 어떻게 생각하시겠습니까?
유지보수성을 중요한 품질로 확립하고 나면, 이 책의 나머지 부분에서는 클린 아키텍처와 헥사고날 아키텍처의 개념을 적용하여 소프트웨어의 유지보수성을 향상시키는 방법을 탐구할 것입니다.

## 유지보수성이란 무엇을 의미하는가?
저를 미치광이로 치부하고 이 책을 반품할 방법을 찾기 전에, 제가 유지보수성이라고 말하는 것이 무엇을 의미하는지 설명하게 해주십시오.
유지보수성은 잠재적으로 소프트웨어 아키텍처를 구성하는 많은 품질 요구사항 중 하나일 뿐입니다. 저는 ChatGPT에게 품질 요구사항 목록을 요청했고, 그 결과는 다음과 같습니다:

- 확장성
- 유연성
- 유지보수성
- 보안성
- 신뢰성
- 모듈성
- 성능
- 상호운용성
- 테스트 용이성
- 비용 효율성

목록은 여기서 끝나지 않습니다.¹
소프트웨어 아키텍트로서 우리는 소프트웨어에 가장 중요한 품질 요구사항을 충족하도록 소프트웨어를 설계합니다. 처리량이 많은 거래 애플리케이션의 경우 확장성과 신뢰성에 중점을 둘 수 있습니다. 독일에서 개인 식별 정보를 다루는 애플리케이션의 경우 보안에 중점을 둘 수 있습니다.
저는 유지보수성을 나머지 품질 요구사항과 함께 묶는 것이 잘못되었다고 생각합니다. 왜냐하면 유지보수성은 특별하기 때문입니다. 소프트웨어가 유지보수 가능하다는 것은 변경하기 쉽다는 것을 의미합니다. 변경하기 쉽다면 유연하고 아마도 모듈화되어 있을 것입니다. 쉬운 변경은 저렴한 변경을 의미하므로 비용 효율적일 가능성도 높습니다. 유지보수 가능하다면 필요할 경우 확장 가능하고, 안전하며, 신뢰할 수 있고, 성능이 좋도록 발전시킬 수 있을 것입니다. 변경하기 쉽기 때문에 다른 시스템과 상호 운용 가능하도록 소프트웨어를 변경할 수 있습니다. 마지막으로, 유지보수 가능한 소프트웨어는 테스트 용이성을 의미합니다. 왜냐하면 유지보수 가능한 소프트웨어는 테스트를 쉽게 만드는 더 작고 간단한 구성 요소로 설계될 가능성이 높기 때문입니다.
제가 여기서 무엇을 했는지 아시겠습니까? 저는 AI에게 품질 요구사항 목록을 요청한 다음, 그 모든 것을 유지보수성과 연결했습니다. 저는 아마도 비슷한 그럴듯한 주장으로 더 많은 품질 요구사항을 유지보수성과 연결할 수 있을 것입니다. 물론 약간 단순화된 것이지만, 그 핵심은 사실입니다: 소프트웨어가 유지보수 가능하다면, 기능적으로나 비기능적으로나 어떤 방향으로든 발전시키기 더 쉽습니다. 그리고 우리 모두는 소프트웨어 시스템의 수명 동안 변경이 일반적이라는 것을 알고 있습니다.

## 유지보수성은 기능을 가능하게 한다
이제 이 장의 시작 부분에서 제가 주장했던 유지보수성이 기능보다 더 중요하다는 주장으로 돌아가 보겠습니다.
제품 담당자에게 소프트웨어 프로젝트에서 가장 중요한 것이 무엇인지 물으면, 그들은 소프트웨어가 사용자에게 제공하는 가치가 가장 중요하다고 말할 것입니다. 사용자에게 가치를 제공하지 않는 소프트웨어는 사용자가 비용을 지불하지 않는다는 것을 의미합니다. 그리고 비용을 지불하는 사용자가 없으면 작동하는 비즈니스 모델이 없으며, 이는 비즈니스 세계에서 성공의 주요 척도입니다.

> 1 소프트웨어 품질에 대한 영감을 얻으려면 (언어 모델이 아닌 인간이 만든) https://quality.arc42.org/ 를 참조하십시오.

따라서 우리 소프트웨어는 가치를 제공해야 합니다. 그러나 유지보수성을 희생하면서 가치를 제공해서는 안 됩니다.²
한 줄 한 줄 코드를 헤쳐나가야 하는 소프트웨어 시스템과 비교하여, 쉽게 변경할 수 있는 소프트웨어 시스템에 기능을 추가하는 것이 얼마나 더 효율적이고 즐거운지 생각해보십시오! 저는 여러분이 몇 시간이면 끝날 것이라고 생각하는 기능을 구축하는 데 며칠 또는 몇 주가 걸리는, 그을음과 의식이 너무 많은 소프트웨어 프로젝트 중 하나에서 일해 본 적이 있다고 확신합니다.
이런 식으로 유지보수성은 기능의 핵심 지원자입니다. 나쁜 유지보수성은 그림 1.1에서 볼 수 있듯이 시간이 지남에 따라 기능 변경 비용이 점점 더 비싸진다는 것을 의미합니다.

![[tom_hombergs_3.jpg]]
*그림 1.1 – 유지보수 가능한 소프트웨어 시스템은 그렇지 않은 소프트웨어 시스템보다 수명 주기 비용이 적다*

유지보수성이 좋지 않은 소프트웨어 시스템에서는 기능 변경이 곧 너무 비싸져서 변경이 고통이 됩니다. 제품 담당자들은 변경 비용에 대해 엔지니어들에게 불평할 것입니다. 엔지니어들은 새로운 기능을 출시하는 것이 항상 유지보수성을 높이는 것보다 우선순위가 높았다고 말하며 자신들을 방어할 것입니다. 갈등의 확률은 변경 비용과 함께 증가합니다.
유지보수성은 진정제입니다. 그것은 변경 비용에 반비례하므로 갈등 확률에도 반비례합니다. 갈등을 피하기 위해 소프트웨어 시스템에 유지보수성을 추가하는 것에 대해 생각해 본 적이 있습니까? 저는 그것만으로도 좋은 투자라고 생각합니다.

> 2 이 책의 맥락에서 저는 "유지보수성"이라는 용어를 "코드 베이스의 변경 가능성"과 동의어로 사용합니다. 또한 유지보수성의 몇 가지 정의(모두 소프트웨어 변경과 관련이 있음)에 대해서는 https://quality.arc42.org/qualities/maintainability를 참조하십시오.

그러나 유지보수성이 나쁨에도 불구하고 성공적인 대규모 소프트웨어 시스템은 어떻습니까? 유지보수성이 거의 없는 상업적으로 성공적인 소프트웨어 시스템이 있다는 것은 사실입니다. 저는 폼에 단일 필드를 추가하는 것이 개발자 시간으로 몇 주가 걸리는 프로젝트인 시스템에서 일한 적이 있으며, 클라이언트는 제 시간에 대해 기꺼이 프리미엄을 지불했습니다.
이러한 시스템은 일반적으로 다음 두 가지 범주 중 하나(또는 둘 다)에 속합니다.

- 시스템 변경이 거의 없는 수명 주기의 끝에 있다.
- 문제에 돈을 쏟아부을 의향이 있는 재정적으로 부유한 회사가 지원한다.

회사가 쓸 돈이 많은 경우에도, 회사는 유지보수성에 투자함으로써 유지보수 세금을 줄일 수 있다는 것을 깨닫습니다. 그래서 보통 소프트웨어를 더 유지보수 가능하게 만들기 위한 계획이 이미 진행 중입니다.
우리는 우리가 만드는 소프트웨어의 유지보수성에 항상 신경 써야 합니다. 그래야 그것이 두려운 '진흙탕'으로 전락하지 않습니다. 그러나 우리 소프트웨어가 앞서 언급한 두 가지 범주 중 하나에 속하지 않는다면, 우리는 더욱 신경 써야 합니다.
이것이 우리가 프로그래밍을 시작하기 전에 유지보수 가능한 아키텍처를 계획하는 데 많은 시간을 할애해야 한다는 것을 의미합니까? 폭포수 방법론과 동의어로 간주되는 BDUF(Big Design Up Front)를 해야 합니까? 아니요, 그렇지 않습니다. 그러나 우리는 소프트웨어에 유지보수성의 씨앗을 심기 위해 약간의 사전 설계(SDUF라고 부를까요?)를 해야 합니다. 이는 시간이 지남에 따라 아키텍처를 필요한 곳으로 발전시키기 쉽게 만들 수 있습니다.
그 사전 설계의 일부는 우리가 구축하는 소프트웨어의 가드레일을 정의하는 아키텍처 스타일을 선택하는 것입니다. 이 책은 클린 아키텍처 또는 포트 및 어댑터/헥사고날 아키텍처가 귀하의 상황에 적합한지 결정하는 데 도움이 될 것입니다.

## 유지보수성은 개발자의 즐거움을 생성한다
개발자로서, 변경이 쉬운 소프트웨어에서 일하고 싶습니까, 아니면 변경이 어려운 소프트웨어에서 일하고 싶습니까? 대답하지 마십시오. 수사적인 질문입니다.
변경 비용에 대한 직접적인 영향 외에도 유지보수성에는 또 다른 이점이 있습니다. 바로 개발자를 행복하게 만든다는 것입니다(또는 현재 작업 중인 프로젝트에 따라 적어도 덜 슬프게 만듭니다).
이 행복을 묘사하기 위해 사용하고 싶은 용어는 '개발자 즐거움'입니다. 이는 '개발자 경험' 또는 '개발자 활성화'라고도 알려져 있습니다. 우리가 그것을 어떻게 부르든, 그것은 개발자가 자신의 일을 잘 수행하는 데 필요한 컨텍스트를 제공한다는 것을 의미합니다.
개발자 즐거움은 개발자 생산성과 직접적으로 관련이 있습니다. 일반적으로 개발자가 행복하면 더 나은 일을 합니다. 그리고 좋은 일을 하면 더 행복해집니다. 개발자 즐거움과 개발자 생산성 사이에는 양방향 상관관계가 있습니다.

![[tom_hombergs_4.png]]
*그림 1.2 – 개발자 즐거움은 개발자 생산성에 영향을 미치고 그 반대도 마찬가지이다*

이 상관관계는 개발자 생산성을 위한 SPACE 프레임워크에서 인정되었습니다.³ SPACE는 개발자 생산성을 측정하는 방법에 대한 쉬운 답을 제공하지는 않지만, 우리 회사와 프로젝트의 맥락에서 개발자 생산성을 가장 잘 측정하기 위해 모든 범주를 포괄하는 메트릭 세트를 의식적으로 선택할 수 있도록 5가지 범주를 제공합니다. 이러한 범주 중 하나(SPACE의 S)는 만족도 및 웰빙이며, 이 장에서는 이를 개발자 즐거움으로 번역했습니다.
개발자 즐거움은 더 나은 생산성으로 이어질 뿐만 아니라 자연스럽게 더 나은 유지율로 이어집니다. 자신의 일을 즐기는 개발자는 회사에 남을 것입니다. 오히려 자신의 일을 즐기지 않는 개발자는 더 나은 곳을 찾아 떠날 가능성이 더 높습니다.
그렇다면 유지보수성은 어디에 들어갈까요? 글쎄요, 우리 소프트웨어 시스템이 유지보수 가능하다면, 변경을 구현하는 데 시간이 덜 걸리므로 우리는 더 생산적입니다. 또한, 우리 소프트웨어 시스템이 유지보수 가능하다면, 변경하는 것이 더 효율적이고 더 자부심을 가질 수 있기 때문에 변경하는 데 더 많은 즐거움을 느낍니다. 우리 소프트웨어가 우리가 원하는 만큼 유지보수 가능하지 않더라도(솔직히 말해서 동어반복이지만), 시간이 지남에 따라 유지보수성을 향상시킬 기회가 주어진다면, 우리는 더 행복하고 더 생산적입니다. 우리가 행복하다면, 우리는 머물 가능성이 더 높습니다.

다이어그램으로 표현하면 다음과 같습니다.

![[tom_hombergs_5.png]]
*그림 1.3 – 유지보수성은 개발자 즐거움과 생산성에 직접적인 영향을 미치며, 개발자 즐거움은 유지율에 영향을 미친다*

> 3 니콜 포스그렌 외, 2021년 3월 6일, "개발자 생산성의 공간(SPACE)". "SPACE"는 만족도 및 웰빙, 성과, 활동, 커뮤니케이션 및 협업, 효율성 및 흐름을 의미합니다. https://queue.acm.org/detail.cfm?id=3454124 참조.

## 유지보수성은 의사결정을 지원한다
소프트웨어 시스템을 구축할 때 우리는 매일 문제를 해결합니다. 우리가 직면하는 대부분의 문제에는 하나 이상의 해결책이 있습니다. 우리는 그 해결책들 사이에서 선택하기 위해 결정을 내려야 합니다.
우리가 만들고 있는 새로운 기능을 위해 이 코드 조각을 복사해야 할까요? 객체를 직접 만들어야 할까요, 아니면 의존성 주입 프레임워크를 사용해야 할까요? 이 객체를 만들기 위해 오버로드된 생성자를 사용해야 할까요, 아니면 빌더를 만들어야 할까요?
이러한 결정 중 많은 것을 우리는 의식적으로 내리지도 않습니다. 우리는 단지 이전에 사용했던 패턴이나 원칙을 적용할 뿐이며, 우리의 직관은 현재 상황에서 그것이 효과가 있을 것이라고 말합니다. 다음과 같이 말입니다.

- 코드 중복을 발견하면 DRY(Don't Repeat Yourself)를 적용한다.
- 코드를 더 테스트하기 쉽게 만들기 위해 의존성 주입을 사용한다.
- 객체를 더 간단하게 만들기 위해 빌더를 도입한다.

이러한 잘 알려진 패턴들과 다른 많은 패턴들을 살펴보면, 그 효과는 무엇일까요? 많은 경우, 주된 효과는 미래에 코드를 변경하기 쉽게 만든다는 것입니다(즉, 더 유지보수하기 쉽게 만듭니다). 유지보수성은 우리가 매일 자동으로 내리는 많은 결정에 내장되어 있습니다!
미리 준비된 패턴을 적용하는 것 이상의 것을 요구하는 더 어려운 결정에 직면했을 때에도 우리는 그것을 활용할 수 있습니다. 여러 옵션 사이에서 결정해야 할 때마다, 우리는 미래에 코드를 변경하기 쉽게 만드는 옵션을 선택할 수 있습니다.⁴ 더 이상 다른 옵션들 사이에서 고민할 필요가 없습니다. 우리는 단지 유지보수성을 가장 많이 증가시키는 옵션을 선택하면 됩니다. 다이어그램으로 표현하면 매우 간단합니다.

![[tom_hombergs_6.png]]
*그림 1.4 – 유지보수성은 의사결정에 영향을 미친다*

> 4 2022년 같은 이름의 강연에서 (실용적인) 데이브 토마스는 변경 가능성을 기반으로 결정을 내리는 원칙을 "모든 것을 지배하는 하나의 규칙"이라고 불렀습니다. 저는 그 강연을 온라인에서 찾지 못했지만, 언젠가 그의 웹사이트에 추가하기를 바랍니다. https://pragdave.me/talks-and-interviews.html 참조.

대부분의 원칙과 마찬가지로, 이것은 물론 일반화입니다. 특정 상황에서는 유지보수성을 향상시키지 않거나 심지어 감소시키는 옵션을 선택하는 것이 올바른 결정일 수 있습니다. 그러나 기본 규칙으로 되돌아갈 때, 유지보수성을 선택하는 것은 일상적인 의사결정을 단순화하는 지침입니다.

## 유지보수성 유지하기
좋습니다, 저는 여러분이 유지보수성이 개발자의 즐거움, 생산성 및 의사결정에 긍정적인 영향을 미친다고 믿는다고 가정합니다. 우리가 코드 베이스에 적용하는 변경 사항이 유지보수성을 증가시키는지(또는 적어도 감소시키지 않는지) 어떻게 알 수 있을까요? 시간이 지남에 따라 유지보수성을 어떻게 관리할까요?
그 질문에 대한 답은 유지보수 가능한 코드를 쉽게 만들 수 있는 아키텍처를 만들고 유지하는 것입니다. 좋은 아키텍처는 코드 베이스를 쉽게 탐색할 수 있게 해줍니다. 쉽게 탐색할 수 있는 코드 베이스에서는 기존 기능을 수정하거나 새로운 기능을 추가하는 것이 매우 쉽습니다. 애플리케이션 구성 요소 간의 의존성은 명확하고 얽혀 있지 않습니다. 요약하자면, 좋은 아키텍처는 유지보수성을 높입니다.

![[tom_hombergs_7.png]]
*그림 1.5 – 소프트웨어 아키텍처는 유지보수성에 영향을 미친다*

더 나아가, 좋은 아키텍처는 개발자의 즐거움, 개발자 생산성, 개발자 유지율 및 의사결정을 향상시킵니다. 우리는 소프트웨어 아키텍처에 의해 직간접적으로 영향을 받는 더 많은 것들을 계속해서 찾을 수 있습니다.
이 상관관계는 우리가 코드를 어떻게 구성할지에 대해 약간의 생각을 투자해야 한다는 것을 의미합니다. 코드 파일을 어떻게 구성 요소로 그룹화할까요? 이러한 구성 요소 간의 의존성을 어떻게 관리할까요? 어떤 의존성이 필요하고, 코드 베이스를 변경에 유연하게 유지하기 위해 어떤 의존성을 지양해야 할까요? 이것이 이 책의 목적으로 이어집니다. 이 책은 코드 베이스를 유지보수 가능하게 구성하는 한 가지 방법을 보여줍니다. 이 책에서 설명하는 아키텍처 스타일은 클린/헥사고날 아키텍처를 구현하는 한 가지 방법입니다. 그러나 이 아키텍처 스타일은 소프트웨어 구축의 모든 문제를 해결하는 만병통치약은 아닙니다. 15장, 아키텍처 스타일 결정하기에서 배우게 될 것처럼, 모든 종류의 소프트웨어 애플리케이션에 적합하지는 않습니다.
이 책에서 배운 것을 가지고 아이디어를 가지고 놀고, 그것들을 자신의 것으로 만들기 위해 수정하고, 주어진 상황에서 적절하다고 느낄 때 적용할 수 있도록 도구 상자에 추가하기를 권장합니다. 다음 각 장은 '이것이 유지보수 가능한 소프트웨어를 구축하는 데 어떻게 도움이 되는가?'라는 제목의 섹션으로 끝납니다. 이 섹션은 각 장의 주요 아이디어를 요약하고 현재 또는 미래의 소프트웨어 프로젝트의 아키텍처에 관한 결정을 내리는 데 도움이 되기를 바랍니다.

---

# 2. 계층형 아키텍처의 문제점은 무엇인가?
과거에 계층형 (웹) 애플리케이션을 개발해 본 적이 있을 것입니다. 현재 프로젝트에서도 그렇게 하고 있을지 모릅니다.
계층으로 생각하는 것은 컴퓨터 과학 수업, 튜토리얼, 모범 사례에서 우리에게 주입되었습니다. 심지어 책에서도 가르쳐졌습니다.¹

![[tom_hombergs_8.png]]
*그림 2.1 – 일반적인 웹 애플리케이션 아키텍처는 웹 계층, 도메인 계층, 영속성 계층으로 구성된다*

그림 2.1은 매우 일반적인 3계층 아키텍처의 상위 수준 뷰를 보여줍니다. 요청을 받아 도메인 계층의 서비스로 라우팅하는 웹 계층이 있습니다.² 서비스는 일부 비즈니스 로직을 수행하고 영속성 계층의 구성 요소를 호출하여 데이터베이스에서 도메인 엔티티의 현재 상태를 쿼리하거나 수정합니다.

> 1 계층 패턴은 예를 들어 마크 리처드의 『소프트웨어 아키텍처 패턴』(오라일리, 2015)에서 가르칩니다.
> 2 도메인 대 비즈니스: 이 책에서는 "도메인"과 "비즈니스"라는 용어를 동의어로 사용합니다. 도메인 계층 또는 비즈니스 계층은 데이터베이스에 항목을 영속화하거나 웹 요청을 처리하는 것과 같은 기술적 문제를 해결하는 코드와 달리 비즈니스 문제를 해결하는 코드의 위치입니다.

아시겠나요? 계층은 견고한 아키텍처 패턴입니다! 제대로만 한다면 웹 및 영속성 계층과 독립적인 도메인 로직을 구축할 수 있습니다. 필요하다면 도메인 로직에 영향을 주지 않고 웹 또는 영속성 기술을 교체할 수 있습니다. 또한 기존 기능에 영향을 주지 않고 새로운 기능을 추가할 수 있습니다.
좋은 계층형 아키텍처를 사용하면 옵션을 열어두고 변화하는 요구사항과 외부 요인(예: 데이터베이스 공급업체가 하룻밤 사이에 가격을 두 배로 올리는 경우)에 신속하게 적응할 수 있습니다. 좋은 계층형 아키텍처는 유지보수성이 좋습니다.
그렇다면 계층의 문제점은 무엇일까요?
제 경험상 계층형 아키텍처는 변경에 매우 취약하여 유지보수하기 어렵습니다. 나쁜 의존성이 스며들어 시간이 지남에 따라 소프트웨어를 변경하기가 점점 더 어려워집니다. 계층은 아키텍처를 궤도에 유지하기에 충분한 가드레일을 제공하지 않습니다. 유지보수성을 유지하기 위해 인간의 규율과 근면에 너무 많이 의존해야 합니다.
다음 섹션에서 그 이유를 말씀드리겠습니다.

## 데이터베이스 주도 설계를 조장한다
정의상, 전통적인 계층형 아키텍처의 기반은 데이터베이스입니다. 웹 계층은 도메인 계층에 의존하고, 도메인 계층은 다시 영속성 계층과 데이터베이스에 의존합니다. 모든 것이 영속성 계층 위에 구축됩니다. 이것은 여러 가지 이유로 문제가 됩니다.
우리가 구축하는 거의 모든 애플리케이션으로 달성하려는 것을 잠시 생각해 봅시다. 우리는 일반적으로 사용자가 비즈니스와 상호 작용하기 쉽게 만들기 위해 비즈니스를 지배하는 규칙 또는 "정책"의 모델을 만들려고 합니다.
우리는 주로 상태가 아닌 동작을 모델링하려고 합니다. 예, 상태는 모든 애플리케이션의 중요한 부분이지만, 상태를 변경하고 따라서 비즈니스를 주도하는 것은 동작입니다!
그렇다면 왜 우리는 아키텍처의 기반을 도메인 로직이 아닌 데이터베이스로 만들고 있을까요?
어떤 애플리케이션에서든 마지막으로 구현했던 유스케이스를 떠올려보세요. 도메인 로직을 먼저 구현했나요, 아니면 영속성 계층을 먼저 구현했나요? 아마도 데이터베이스 구조가 어떻게 될지 먼저 생각하고 나서야 그 위에 도메인 로직을 구현했을 것입니다.
이것은 전통적인 계층형 아키텍처에서는 자연스러운 의존성 흐름을 따르기 때문에 말이 됩니다. 하지만 비즈니스 관점에서는 전혀 말이 되지 않습니다! 우리는 다른 어떤 것보다 먼저 도메인 로직을 구축해야 합니다! 우리는 비즈니스 규칙을 올바르게 이해했는지 확인하고 싶습니다. 그리고 올바른 도메인 로직을 구축하고 있다는 것을 알게 된 후에야 그 주위에 영속성 및 웹 계층을 구축해야 합니다.
이러한 데이터베이스 중심 아키텍처의 원동력은 객체-관계 매핑(ORM) 프레임워크의 사용입니다. 오해하지 마세요, 저는 그 프레임워크들을 좋아하고 정기적으로 사용합니다. 하지만 ORM 프레임워크를 계층형 아키텍처와 결합하면 비즈니스 규칙과 영속성 측면을 쉽게 섞게 됩니다.

![[tom_hombergs_9.png]]
*그림 2.2 – 도메인 계층에서 데이터베이스 엔티티를 사용하면 영속성 계층과의 강한 결합으로 이어진다*

일반적으로 그림 2.2와 같이 영속성 계층의 일부로 ORM 관리 엔티티가 있습니다. 계층은 그 아래 계층에 접근할 수 있으므로 도메인 계층은 해당 엔티티에 접근할 수 있습니다. 그리고 사용할 수 있다면 언젠가는 사용하게 될 것입니다.
이것은 도메인 계층과 영속성 계층 사이에 강한 결합을 만듭니다. 우리의 비즈니스 서비스는 영속성 모델을 비즈니스 모델로 사용하며 도메인 로직뿐만 아니라 즉시 로딩 대 지연 로딩, 데이터베이스 트랜잭션, 캐시 플러싱 및 유사한 하우스키핑 작업도 처리해야 합니다.³
영속성 코드는 사실상 도메인 코드에 융합되어 있으므로 하나를 다른 것 없이 변경하기 어렵습니다. 이것은 유연하고 옵션을 열어두는 것의 반대이며, 이는 우리 아키텍처의 목표가 되어야 합니다.

> 3 그의 중요한 저서 『리팩토링』(피어슨, 2018)에서 마틴 파울러는 이 증상을 "발산적 변경"이라고 부릅니다. 즉, 단일 기능을 구현하기 위해 코드의 관련 없어 보이는 부분을 변경해야 하는 것입니다. 이것은 리팩토링을 유발해야 하는 코드 스멜입니다.

## 지름길에 취약하다
전통적인 계층형 아키텍처에서 유일한 전역 규칙은 특정 계층에서는 동일한 계층이나 그 아래 계층의 구성 요소에만 접근할 수 있다는 것입니다. 개발팀이 합의한 다른 규칙이 있을 수 있고 그 중 일부는 도구에 의해 강제될 수도 있지만, 계층형 아키텍처 스타일 자체는 우리에게 그러한 규칙을 강요하지 않습니다.
따라서 상위 계층의 특정 구성 요소에 접근해야 하는 경우, 해당 구성 요소를 한 계층 아래로 밀어내면 접근이 허용됩니다. 문제 해결. 한 번 하는 것은 괜찮을 수 있습니다. 하지만 한 번 하면 두 번째 할 수 있는 문이 열립니다. 그리고 다른 사람이 할 수 있었다면, 나도 할 수 있지 않을까요?
개발자로서 우리가 그런 지름길을 가볍게 여긴다고 말하는 것은 아닙니다. 하지만 무언가를 할 수 있는 옵션이 있다면, 누군가는 그것을 할 것입니다. 특히 임박한 마감일과 결합될 때 더욱 그렇습니다. 그리고 무언가가 이전에 행해졌다면, 다른 누군가가 그것을 다시 할 가능성은 급격히 증가할 것입니다. 이것은 깨진 창문 이론이라는 심리적 효과입니다 – 11장, 의식적으로 지름길 택하기에서 더 자세히 다룹니다.

![[tom_hombergs_10.png]]
*그림 2.3 – 어떤 계층이든 영속성 계층의 모든 것에 접근할 수 있기 때문에 시간이 지남에 따라 뚱뚱해지는 경향이 있다*

소프트웨어 프로젝트의 수년간의 개발 및 유지보수 과정에서 영속성 계층은 그림 2.3과 같이 끝날 수 있습니다.
영속성 계층(또는 더 일반적인 용어로 최하위 계층)은 구성 요소를 계층 아래로 밀어내면서 뚱뚱해질 것입니다. 이에 대한 완벽한 후보는 특정 계층에 속하지 않는 것처럼 보이는 헬퍼 또는 유틸리티 구성 요소입니다.
따라서 아키텍처에 대한 지름길 모드를 비활성화하려면 계층이 최선의 선택이 아닙니다. 적어도 어떤 종류의 추가 아키텍처 규칙을 강제하지 않는 한 말입니다. 그리고 강제한다는 것은 선임 개발자가 코드 리뷰를 하는 것을 의미하는 것이 아니라, 규칙이 깨졌을 때 빌드를 실패하게 만드는 자동으로 강제되는 규칙을 의미합니다.

## 테스트하기 어려워진다
계층형 아키텍처 내에서 흔히 볼 수 있는 발전은 계층을 건너뛰는 것입니다. 엔티티의 단일 필드만 조작하기 때문에 웹 계층에서 직접 영속성 계층에 접근합니다. 이를 위해 도메인 계층을 귀찮게 할 필요는 없겠죠?

![[tom_hombergs_11.png]]
*그림 2.4 – 도메인 계층을 건너뛰면 도메인 로직이 코드 베이스 전체에 흩어지는 경향이 있다*

그림 2.4는 웹 계층에서 바로 영속성 계층에 접근하여 도메인 계층을 건너뛰는 방법을 보여줍니다.
다시 말하지만, 처음 몇 번은 괜찮아 보이지만, 자주 발생하면(그리고 누군가 첫발을 내디디면 그렇게 될 것입니다) 두 가지 단점이 있습니다.
첫째, 단일 필드를 조작하는 것뿐이라도 웹 계층에서 도메인 로직을 구현하고 있습니다. 미래에 유스케이스가 확장되면 어떻게 될까요? 우리는 웹 계층에 더 많은 도메인 로직을 추가하여 책임을 혼합하고 필수적인 도메인 로직을 모든 계층에 퍼뜨릴 가능성이 높습니다.
둘째, 웹 계층의 단위 테스트에서는 도메인 계층에 대한 의존성뿐만 아니라 영속성 계층에 대한 의존성도 관리해야 합니다. 테스트에서 모의(mock)를 사용하는 경우, 이는 두 계층 모두에 대한 모의를 만들어야 함을 의미합니다. 이것은 테스트에 복잡성을 더합니다. 그리고 복잡한 테스트 설정은 시간이 없기 때문에 전혀 테스트하지 않는 첫걸음입니다. 웹 구성 요소가 시간이 지남에 따라 성장함에 따라 다른 영속성 구성 요소에 대한 많은 의존성을 축적하여 테스트의 복잡성을 더할 수 있습니다. 어느 시점에서는 의존성을 이해하고 모의를 만드는 데 더 많은 시간이 걸리므로 실제 테스트 코드를 작성하는 것보다 더 많은 시간이 걸립니다.
시간이 지남에 따라 다른 영속성 구성 요소에 대한 많은 의존성을 축적하여 테스트의 복잡성을 더할 수 있습니다. 어느 시점에서는 의존성을 이해하고 모의(mock)를 만드는 데 실제 테스트 코드를 작성하는 것보다 더 많은 시간이 걸립니다.

### 유스케이스를 숨긴다
개발자로서 우리는 빛나는 새로운 유스케이스를 구현하는 새로운 코드를 만드는 것을 좋아합니다. 그러나 우리는 보통 새로운 코드를 만드는 것보다 기존 코드를 변경하는 데 훨씬 더 많은 시간을 보냅니다. 이것은 수십 년 된 코드 베이스에서 작업하는 두려운 레거시 프로젝트뿐만 아니라 초기 유스케이스가 구현된 후의 뜨거운 새로운 그린필드 프로젝트에도 해당됩니다.
기능을 추가하거나 변경할 올바른 위치를 너무 자주 찾기 때문에, 우리 아키텍처는 코드 베이스를 빠르게 탐색하는 데 도움이 되어야 합니다. 계층형 아키텍처는 이 점에서 어떻게 버틸까요?
앞서 논의했듯이, 계층형 아키텍처에서는 도메인 로직이 계층 전체에 흩어지기 쉽습니다. "쉬운" 유스케이스에 대해 도메인 로직을 건너뛰면 웹 계층에 존재할 수 있습니다. 그리고 특정 구성 요소를 도메인 및 영속성 계층 모두에서 접근할 수 있도록 아래로 밀어 넣으면 영속성 계층에 존재할 수 있습니다. 이것만으로도 새로운 기능을 추가할 올바른 지점을 찾기가 어려워집니다.
하지만 더 있습니다. 계층형 아키텍처는 도메인 서비스의 "너비"에 대한 규칙을 부과하지 않습니다. 시간이 지남에 따라 이것은 종종 여러 유스케이스를 제공하는 매우 광범위한 서비스로 이어집니다(그림 2.5 참조).

![[tom_hombergs_12.png]]
*그림 2.5 – "광범위한" 서비스는 코드 베이스 내에서 특정 유스케이스를 찾기 어렵게 만든다*

광범위한 서비스는 영속성 계층에 많은 의존성을 가지며 웹 계층의 많은 구성 요소가 이에 의존합니다. 이것은 서비스를 테스트하기 어렵게 만들 뿐만 아니라, 우리가 작업하려는 유스케이스를 담당하는 코드를 찾기 어렵게 만듭니다.
각각 단일 유스케이스를 제공하는 고도로 전문화되고 좁은 도메인 서비스가 있다면 얼마나 더 쉬울까요? `UserService`에서 사용자 등록 유스케이스를 찾는 대신, `RegisterUserService`를 열고 바로 작업을 시작할 수 있을 것입니다.

### 병렬 작업을 어렵게 만든다
경영진은 보통 우리가 후원하는 소프트웨어 구축을 특정 날짜에 끝내기를 기대합니다. 사실, 그들은 특정 예산 내에서 끝내기를 기대하기도 하지만, 여기서는 일을 복잡하게 만들지 맙시다.
소프트웨어 엔지니어로서의 제 경력에서 "완성된" 소프트웨어를 본 적이 없다는 사실은 제쳐두고, 특정 날짜까지 "완성"된다는 것은 보통 여러 사람이 병렬로 작업해야 함을 의미합니다.
아마도 책을 읽지 않았더라도 "신화적인 맨먼스"의 이 유명한 결론을 알고 있을 것입니다: 늦은 소프트웨어 프로젝트에 인력을 추가하면 더 늦어진다.⁴

> 4 프레더릭 P. 브룩스 주니어, 『신화적인 맨먼스: 소프트웨어 공학에 관한 에세이』, 애디슨-웨슬리, 1995.

이것은 (아직) 늦지 않은 소프트웨어 프로젝트에서도 어느 정도 사실입니다. 50명의 개발자로 구성된 대규모 그룹이 10명의 개발자로 구성된 소규모 팀보다 5배 빠를 것이라고 기대할 수 없습니다. 그들이 하위 팀으로 나뉘어 소프트웨어의 별도 부분에서 작업할 수 있는 매우 큰 애플리케이션에서 작업하는 경우 효과가 있을 수 있지만, 대부분의 상황에서는 서로 발을 밟게 될 것입니다.
그러나 건강한 규모에서는 프로젝트에 더 많은 사람이 있으면 확실히 더 빠를 것으로 기대할 수 있습니다. 그리고 경영진이 우리에게 그것을 기대하는 것은 옳습니다.
이 기대를 충족시키기 위해 우리 아키텍처는 병렬 작업을 지원해야 합니다. 이것은 쉽지 않습니다. 그리고 계층형 아키텍처는 여기서 우리에게 별로 도움이 되지 않습니다.
애플리케이션에 새로운 유스케이스를 추가한다고 상상해보십시오. 세 명의 개발자가 있습니다. 한 명은 웹 계층에 필요한 기능을 추가하고, 한 명은 도메인 계층에, 세 번째는 영속성 계층에 추가할 수 있습니다. 맞죠?
글쎄요, 계층형 아키텍처에서는 보통 그렇게 작동하지 않습니다. 모든 것이 영속성 계층 위에 구축되기 때문에 영속성 계층이 먼저 개발되어야 합니다. 그런 다음 도메인 계층이 오고 마지막으로 웹 계층이 옵니다. 따라서 한 번에 한 명의 개발자만 기능에 대해 작업할 수 있습니다!
"아, 하지만 개발자들이 먼저 인터페이스를 정의할 수 있습니다."라고 당신은 말합니다. "그리고 나서 각 개발자는 실제 구현을 기다리지 않고 이러한 인터페이스에 대해 작업할 수 있습니다."
물론, 이것은 가능하지만, 앞서 논의한 것처럼 도메인 및 영속성 로직을 혼합하지 않은 경우에만 가능하며, 각 측면을 개별적으로 작업하는 것을 막습니다.
코드 베이스에 광범위한 서비스가 있는 경우, 병렬로 다른 기능에 대해 작업하기가 어려울 수도 있습니다. 다른 유스케이스에 대해 작업하면 동일한 서비스가 병렬로 편집되어 병합 충돌 및 잠재적 회귀로 이어질 수 있습니다.

### 이것이 유지보수 가능한 소프트웨어를 구축하는 데 어떻게 도움이 되는가?
과거에 계층형 아키텍처를 구축했다면, 이 장에서 논의된 문제 중 일부에 공감할 수 있을 것이며, 아마도 몇 가지를 더 추가할 수도 있을 것입니다.
올바르게 수행되고 몇 가지 추가 규칙이 부과된다면, 계층형 아키텍처는 매우 유지보수 가능하며 코드 베이스를 변경하거나 추가하는 것을 쉽게 만들 수 있습니다.
그러나 논의는 계층형 아키텍처가 많은 잘못될 수 있는 것을 허용한다는 것을 보여줍니다. 좋은 자기 훈련 없이는 시간이 지남에 따라 저하되고 유지보수성이 떨어지기 쉽습니다. 그리고 우리 자기 훈련은 보통 팀 구성원이 팀에 들어오거나 나갈 때마다, 또는 관리자가 개발팀 주위에 새로운 마감일을 그릴 때마다 타격을 받습니다.
계층형 아키텍처의 함정을 염두에 두는 것은 다음에 우리가 지름길을 택하는 것에 반대하고 대신 더 유지보수 가능한 솔루션을 구축하는 것에 대해 논쟁할 때 도움이 될 것입니다 – 그것이 계층형 아키텍처이든 다른 아키텍처 스타일이든 말입니다.

---

# 3. 의존성 역전
이전 장에서 계층형 아키텍처에 대해 이야기한 후, 이 장에서 대안적인 접근 방식을 논의할 것으로 기대하는 것이 옳습니다. 우리는 SOLID¹ 원칙 중 두 가지를 논의하는 것으로 시작한 다음, 그것들을 적용하여 계층형 아키텍처의 문제를 해결하는 클린 또는 헥사고날 아키텍처를 만들 것입니다.

## 단일 책임 원칙
소프트웨어 개발에 종사하는 모든 사람은 아마도 단일 책임 원칙(SRP)을 알거나 적어도 안다고 가정할 것입니다. 이 원칙에 대한 일반적인 해석은 다음과 같습니다.

> 구성 요소는 한 가지만 수행하고 올바르게 수행해야 한다.

그것은 좋은 조언이지만, SRP의 실제 의도는 아닙니다.
한 가지만 하는 것은 실제로 "단일 책임"의 가장 명백한 해석이므로 SRP가 자주 이렇게 해석되는 것은 놀라운 일이 아닙니다. SRP의 이름이 오해의 소지가 있다는 점을 관찰해 봅시다.
SRP의 실제 정의는 다음과 같습니다.

> 구성 요소는 변경해야 할 이유가 하나만 있어야 한다.

보시다시피, "책임"은 실제로 "한 가지만 하라" 대신 "변경 이유"로 번역되어야 합니다. 아마도 우리는 SRP를 "단일 변경 이유 원칙"으로 이름을 바꿔야 할 것입니다.
구성 요소에 변경 이유가 하나만 있다면, 다른 이유로 소프트웨어를 변경하더라도 이 구성 요소에 대해 전혀 걱정할 필요가 없습니다. 왜냐하면 우리는 그것이 여전히 예상대로 작동할 것이라는 것을 알기 때문입니다.

> 1 SOLID는 단일 책임 원칙, 개방-폐쇄 원칙, 리스코프 치환 원칙, 인터페이스 분리 원칙, 의존성 역전 원칙을 의미합니다. 이러한 원칙에 대한 자세한 내용은 로버트 C. 마틴의 『클린 아키텍처』나 위키피디아(https://en.wikipedia.org/wiki/SOLID)에서 읽을 수 있습니다.

슬프게도, 변경 이유는 구성 요소의 의존성을 통해 다른 구성 요소로 코드를 통해 전파되기 매우 쉽습니다(그림 3.1 참조).

![[tom_hombergs_13.png]]
*그림 3.1 – 구성 요소의 각 의존성은 그것이 단지 전이적 의존성(점선 화살표)일지라도 이 구성 요소를 변경할 수 있는 가능한 이유이다*

앞의 그림에서 구성 요소 A는 다른 많은 구성 요소(직접적으로 또는 전이적으로)에 의존하는 반면, 구성 요소 E는 전혀 의존성이 없습니다.
구성 요소 E를 변경해야 하는 유일한 이유는 일부 새로운 요구사항으로 인해 E의 기능이 변경되어야 할 때입니다. 그러나 구성 요소 A는 다른 구성 요소 중 하나가 변경될 때 변경되어야 할 수 있습니다. 왜냐하면 그것들에 의존하기 때문입니다.
많은 코드 베이스는 SRP가 위반되기 때문에 시간이 지남에 따라 변경하기가 더 어려워지고 따라서 더 비싸집니다. 시간이 지남에 따라 구성 요소는 점점 더 많은 변경 이유를 수집합니다. 많은 변경 이유를 수집한 후, 한 구성 요소를 변경하면 다른 구성 요소가 실패할 수 있습니다.

## 부작용에 대한 이야기
저는 한때 제 팀이 다른 소프트웨어 업체에서 만든 10년 된 코드 베이스를 물려받은 프로젝트에 참여한 적이 있습니다. 클라이언트는 지속적인 유지보수 비용을 줄이고 새로운 기능에 대한 개발 속도를 향상시키기 위해 개발팀을 교체하기로 결정했습니다. 그래서 저희가 계약을 따냈습니다.
예상대로, 코드가 실제로 무엇을 하는지 이해하기 쉽지 않았고, 코드 베이스의 한 영역에서 변경한 내용이 다른 영역에서 종종 부작용을 일으켰습니다. 하지만 우리는 철저한 테스트, 자동화된 테스트 추가, 그리고 많은 리팩토링을 통해 관리했습니다.
코드 베이스를 성공적으로 유지보수하고 확장한 지 얼마 후, 클라이언트가 새로운 기능을 요청했습니다. 그리고 그들은 소프트웨어 사용자들에게 매우 어색한 방식으로 그것을 구축하기를 원했습니다.
그래서 저는 전반적인 변경이 덜 필요하기 때문에 구현 비용이 훨씬 저렴한 더 사용자 친화적인 방식으로 하도록 제안했습니다. 그러나 그것은 특정 매우 중앙적인 구성 요소에 작은 변경이 필요했습니다.
클라이언트는 거절하고 더 어색하고 비싼 솔루션을 주문했습니다. 이유를 물었을 때, 그들은 이전 개발팀이 그 한 구성 요소에 변경을 가했을 때 과거에 항상 다른 무언가를 망가뜨렸기 때문에 부작용을 두려워한다고 말했습니다.
슬프게도, 이것은 잘못 설계된 소프트웨어를 수정하는 데 추가 비용을 지불하도록 클라이언트를 세뇌시키는 방법의 한 예입니다. 다행히도 대부분의 클라이언트는 이 게임에 동참하지 않을 것이므로, 대신 잘 설계된 소프트웨어를 구축하려고 노력합시다.

## 의존성 역전 원칙
계층형 아키텍처에서 계층 간 의존성은 항상 다음 계층으로 아래를 향합니다. 높은 수준에서 단일 책임 원칙을 적용하면 상위 계층이 하위 계층보다 변경 이유가 더 많다는 것을 알 수 있습니다.
따라서 도메인 계층이 영속성 계층에 의존하기 때문에, 영속성 계층의 각 변경은 잠재적으로 도메인 계층의 변경을 요구합니다. 그러나 도메인 코드는 우리 애플리케이션에서 가장 중요한 코드입니다! 우리는 영속성 코드에서 무언가 변경될 때 그것을 변경하고 싶지 않습니다!
그렇다면 이 의존성을 어떻게 제거할 수 있을까요?
의존성 역전 원칙(DIP)이 답을 제공합니다.
SRP와 대조적으로, DIP는 이름이 의미하는 바를 의미합니다.

> 우리는 코드 베이스 내의 모든 의존성의 방향을 뒤집을(역전시킬) 수 있습니다.²

어떻게 작동할까요? 도메인 코드와 영속성 코드 사이의 의존성을 역전시켜 영속성 코드가 도메인 코드에 의존하도록 하여 도메인 코드를 변경해야 하는 이유의 수를 줄여 봅시다.
우리는 2장, 계층형 아키텍처의 문제점은 무엇인가?의 그림 2.2와 같은 구조로 시작합니다. 도메인 계층에는 영속성 계층의 엔티티 및 리포지토리와 함께 작동하는 서비스가 있습니다.
우선, 우리는 엔티티를 도메인 계층으로 끌어올리고 싶습니다. 왜냐하면 그것들은 우리의 도메인 객체를 나타내고 우리 도메인 코드는 거의 그 엔티티들의 상태를 변경하는 것을 중심으로 돌아가기 때문입니다.

> 2 실제로, 우리는 의존성의 양쪽 끝에 있는 코드를 제어할 수 있을 때만 의존성을 역전시킬 수 있습니다. 타사 라이브러리에 대한 의존성이 있는 경우, 해당 라이브러리의 코드를 제어하지 않으므로 역전시킬 수 없습니다.

하지만 이제 영속성 계층의 리포지토리가 이제 도메인 계층에 있는 엔티티에 의존하기 때문에 두 계층 사이에 순환 의존성이 있습니다. 여기가 바로 DIP를 적용하는 곳입니다. 우리는 도메인 계층에 리포지토리에 대한 인터페이스를 만들고 영속성 계층의 실제 리포지토리가 그것을 구현하도록 합니다. 결과는 그림 3.2와 같습니다.

![[tom_hombergs_14.png]]
*그림 3.2 – 도메인 계층에 인터페이스를 도입함으로써, 영속성 계층이 도메인 계층에 의존하도록 의존성을 역전시킬 수 있다*

이 트릭으로, 우리는 도메인 로직을 영속성 코드의 억압적인 의존성에서 해방시켰습니다. 이것은 앞으로 논의할 두 가지 아키텍처 스타일의 핵심 기능입니다.

## 클린 아키텍처
로버트 C. 마틴은 그의 동명 저서에서 "클린 아키텍처"라는 용어를 만들었습니다.³ 그의 의견에 따르면, 클린 아키텍처에서 비즈니스 규칙은 설계상 테스트 가능하며 프레임워크, 데이터베이스, UI 기술 및 기타 외부 애플리케이션이나 인터페이스와 독립적입니다.
이것은 도메인 코드가 외부를 향한 의존성을 가져서는 안 된다는 것을 의미합니다. 대신, DIP의 도움으로 모든 의존성은 도메인 코드를 향합니다.
그림 3.3은 그러한 아키텍처가 추상적인 수준에서 어떻게 보일 수 있는지를 보여줍니다.

> 3 로버트 C. 마틴, 『클린 아키텍처』, 프렌티스 홀, 2017, 22장.

![[tom_hombergs_15.png]]
*그림 3.3 – 클린 아키텍처에서는 모든 의존성이 도메인 로직을 향해 안쪽으로 향한다 (출처: 로버트 C. 마틴의 클린 아키텍처)*

이 아키텍처의 계층들은 동심원으로 서로 감싸여 있습니다. 이러한 아키텍처의 주요 규칙은 "의존성 규칙"으로, 이러한 계층 간의 모든 의존성은 안쪽을 향해야 한다고 명시합니다.
아키텍처의 핵심에는 주변 유스케이스에 의해 접근되는 도메인 엔티티가 포함됩니다. 유스케이스는 우리가 이전에 서비스라고 불렀던 것이지만, 단일 책임(즉, 변경에 대한 단일 이유)을 갖도록 더 세분화되어 있어, 이전에 논의했던 광범위한 서비스의 문제를 피합니다.
이 핵심 주위에는 비즈니스 규칙을 지원하는 애플리케이션의 다른 모든 구성 요소를 찾을 수 있습니다. 이 지원은 예를 들어 영속성을 제공하거나 UI를 제공하는 것을 의미할 수 있습니다. 또한 외부 계층은 다른 타사 구성 요소에 대한 어댑터를 제공할 수 있습니다.
도메인 코드는 어떤 영속성 또는 UI 프레임워크가 사용되는지 전혀 모르기 때문에, 해당 프레임워크에 특정한 코드를 포함할 수 없으며 비즈니스 규칙에 집중할 것입니다. 우리는 도메인 코드를 모델링하는 데 원하는 모든 자유를 가집니다. 예를 들어, 도메인 주도 설계(DDD)를 가장 순수한 형태로 적용할 수 있습니다. 영속성 또는 UI 관련 문제에 대해 생각할 필요가 없다는 것이 그것을 훨씬 쉽게 만듭니다.
예상할 수 있듯이, 클린 아키텍처에는 비용이 따릅니다. 도메인 계층이 영속성 및 UI 계층과 같은 외부 계층과 완전히 분리되어 있기 때문에, 우리는 각 계층에서 애플리케이션 엔티티의 모델을 유지해야 합니다.
예를 들어, 영속성 계층에서 객체-관계 매핑(ORM) 프레임워크를 사용한다고 가정해 봅시다. ORM 프레임워크는 일반적으로 데이터베이스 구조와 객체 필드와 데이터베이스 열의 매핑을 설명하는 메타데이터를 포함하는 특정 엔티티 클래스를 기대합니다. 도메인 계층은 영속성 계층을 모르기 때문에, 도메인 계층에서 동일한 엔티티 클래스를 사용할 수 없으며 두 계층 모두에서 생성해야 합니다. 이것은 영속성 계층이 도메인 엔티티를 자체 표현으로 매핑해야 함을 의미합니다. 유사한 매핑이 도메인 계층과 다른 외부 계층 사이에도 적용됩니다.
하지만 그건 좋은 일입니다! 이 분리는 바로 우리가 프레임워크 관련 문제로부터 도메인 코드를 해방시키기 위해 달성하고자 했던 것입니다. 예를 들어, 자바 세계의 표준 객체-관계 API인 자바 영속성 API는 ORM 관리 엔티티가 우리가 도메인 모델에서 피하고 싶을 수 있는 인수가 없는 기본 생성자를 갖도록 요구합니다. 9장, 경계 간 매핑에서, 우리는 도메인과 영속성 계층 간의 결합을 그냥 받아들이는 매핑 없음 전략을 포함하여 다른 매핑 전략에 대해 이야기할 것입니다.
로버트 C. 마틴의 클린 아키텍처는 다소 추상적이므로, 한 단계 더 자세히 들어가 클린 아키텍처 원칙에 더 구체적인 형태를 부여하는 헥사고날 아키텍처를 살펴보겠습니다.

## 헥사고날 아키텍처
헥사고날 아키텍처라는 용어는 알리스테어 콕번에서 유래했으며 꽤 오랫동안 사용되어 왔습니다.⁴ 이것은 로버트 C. 마틴이 나중에 클린 아키텍처에서 더 일반적인 용어로 설명한 것과 동일한 원칙을 적용합니다.

![[tom_hombergs_16.png]]
*그림 3.4 – 헥사고날 아키텍처는 애플리케이션 코어가 각 어댑터와 상호 작용할 특정 포트를 제공하기 때문에 "포트와 어댑터" 아키텍처라고도 불린다*

> 4 "헥사고날 아키텍처"라는 용어의 주요 출처는 알리스테어 콕번의 웹사이트에 있는 기사인 것 같습니다: https://alistair.cockburn.us/hexagonal-architecture/.

그림 3.4는 헥사고날 아키텍처가 어떻게 보일 수 있는지를 보여줍니다. 애플리케이션 코어는 육각형으로 표현되어 이 아키텍처 스타일에 그 이름을 부여합니다. 그러나 육각형 모양은 의미가 없으므로, 팔각형을 그리고 "팔각형 아키텍처"라고 부를 수도 있습니다. 전설에 따르면, 육각형은 단순히 일반적인 사각형 대신 사용되어 애플리케이션이 다른 시스템이나 어댑터에 연결되는 네 개 이상의 면을 가질 수 있음을 보여주기 위함이었습니다.
육각형 안에는 도메인 엔티티와 해당 엔티티와 함께 작동하는 유스케이스가 있습니다. 육각형에는 나가는 의존성이 없으므로 마틴의 클린 아키텍처의 의존성 규칙이 적용됩니다. 대신 모든 의존성은 중앙을 향합니다.
육각형 외부에는 애플리케이션과 상호 작용하는 다양한 어댑터가 있습니다. 웹 브라우저와 상호 작용하는 웹 어댑터, 외부 시스템과 상호 작용하는 일부 어댑터, 그리고 영속성을 위해 데이터베이스와 상호 작용하는 어댑터가 있을 수 있습니다.
왼쪽의 어댑터는 우리 애플리케이션을 구동하는 어댑터(우리 애플리케이션 코어를 호출하기 때문에)이고, 오른쪽의 어댑터는 우리 애플리케이션에 의해 구동되는 어댑터(우리 애플리케이션 코어에 의해 호출되기 때문에)입니다.
애플리케이션 코어와 어댑터 간의 통신을 허용하기 위해 애플리케이션 코어는 특정 포트를 제공합니다. 구동 어댑터의 경우, 이러한 포트는 코어의 유스케이스 클래스 중 하나에 의해 구현되고 어댑터에 의해 호출되는 인터페이스일 수 있습니다. 피동 어댑터의 경우, 어댑터에 의해 구현되고 코어에 의해 호출되는 인터페이스일 수 있습니다. 우리는 심지어 동일한 포트를 구현하는 여러 어댑터를 가질 수도 있습니다. 예를 들어, 실제 외부 시스템과 통신하기 위한 것과 테스트에 사용할 모의와 통신하기 위한 것입니다.
헥사고날 아키텍처의 핵심 속성을 명확히 하기 위해, 애플리케이션 코어(육각형)는 외부(포트)와의 인터페이스를 정의하고 소유합니다. 그런 다음 어댑터는 이 인터페이스와 함께 작동합니다. 이것은 아키텍처 수준에서 적용된 의존성 역전 원칙입니다.
중심 개념 때문에 이 아키텍처 스타일은 포트와 어댑터 아키텍처라고도 알려져 있습니다.
클린 아키텍처와 마찬가지로, 이 헥사고날 아키텍처를 계층으로 구성할 수 있습니다. 가장 바깥쪽 계층은 애플리케이션과 다른 시스템 간에 변환하는 어댑터로 구성됩니다.
다음으로, 포트와 유스케이스 구현을 결합하여 애플리케이션 계층을 형성할 수 있습니다. 왜냐하면 그것들이 우리 애플리케이션의 인터페이스를 정의하기 때문입니다. 최종 계층에는 비즈니스 규칙을 구현하는 도메인 엔티티가 포함됩니다.
비즈니스 로직은 유스케이스 클래스와 엔티티에 구현됩니다. 유스케이스 클래스는 단일 유스케이스만 구현하는 좁은 도메인 서비스입니다. 물론 여러 유스케이스를 더 넓은 도메인 서비스로 결합하도록 선택할 수 있지만, 이상적으로는 유지보수성을 높이기 위해 유스케이스가 함께 자주 사용될 때만 이렇게 합니다.
잠재적으로, 우리는 애플리케이션 서비스의 개념도 도입하고 싶을 것입니다. 애플리케이션 서비스는 그림 3.5와 같이 유스케이스(도메인 서비스)에 대한 호출을 조정하는 서비스입니다.

![[tom_hombergs_17.png]]
*그림 3.5 – DDD의 애플리케이션 및 도메인 서비스 개념을 사용하는 헥사고날 아키텍처*

여기서 애플리케이션 서비스는 입력 및 출력 포트와 도메인 서비스 사이를 변환하여 도메인 서비스를 외부 세계로부터 보호하고 잠재적으로 도메인 서비스 간에 조정합니다. 도메인 서비스 상자는 그림 3.4의 유스케이스 상자와 동의어입니다. 우리는 지금 DDD에서 빌린 용어를 사용하고 있을 뿐입니다.
이 논의가 암시하듯이, 우리는 육각형 내부에서 우리 애플리케이션 코드를 적절하다고 생각하는 대로 자유롭게 설계할 수 있습니다. 우리는 애플리케이션의 복잡성과 크기에 맞춰 단순하게 또는 정교하게 갈 수 있습니다. 13장, 여러 바운디드 컨텍스트 관리하기에서 우리 육각형 내에서 코드를 관리하는 방법에 대해 더 많이 배울 것입니다.
다음 장에서는 이러한 아키텍처를 코드로 구성하는 방법을 논의할 것입니다.

### 이것이 유지보수 가능한 소프트웨어를 구축하는 데 어떻게 도움이 되는가?
"클린 아키텍처", "헥사고날 아키텍처" 또는 "포트와 어댑터 아키텍처"라고 부르든, 의존성을 역전시켜 도메인 코드가 외부에 대한 의존성을 갖지 않도록 함으로써, 우리는 도메인 로직을 모든 영속성 및 UI 관련 문제로부터 분리하고 코드 베이스 전체에서 변경해야 하는 이유의 수를 줄일 수 있습니다. 그리고 변경 이유가 적을수록 유지보수성이 향상됩니다.
도메인 코드는 비즈니스 문제에 가장 적합하게 모델링될 수 있으며, 영속성 및 UI 코드는 영속성 및 UI 문제에 가장 적합하게 모델링될 수 있습니다.
이 책의 나머지 부분에서는 헥사고날 아키텍처 스타일을 웹 애플리케이션에 적용할 것입니다. 우리는 애플리케이션의 패키지 구조를 만들고 의존성 주입의 역할을 논의하는 것으로 시작할 것입니다.

---

# 4. 코드 구성하기
코드를 보는 것만으로 아키텍처를 인식할 수 있다면 좋지 않을까요?
이 장에서는 코드를 구성하는 다양한 방법을 살펴보고 헥사고날 아키텍처를 직접 반영하는 표현력 있는 패키지 구조를 소개합니다.
그린필드 소프트웨어 프로젝트에서 우리가 가장 먼저 제대로 하려고 하는 것은 패키지 구조입니다. 우리는 프로젝트의 나머지 기간 동안 사용할 멋진 구조를 설정합니다. 그런 다음 프로젝트 중에 일이 바빠지고, 많은 곳에서 패키지 구조가 구조화되지 않은 코드 덩어리를 위한 멋진 외관에 불과하다는 것을 깨닫습니다. 한 패키지의 클래스가 가져와서는 안 되는 다른 패키지의 클래스를 가져옵니다.
서문에서 소개된 BuckPal 예제 애플리케이션의 코드를 구성하는 다양한 옵션에 대해 논의할 것입니다. 더 구체적으로, 사용자가 자신의 계정에서 다른 계정으로 돈을 이체할 수 있게 해주는 '송금' 유스케이스를 살펴볼 것입니다.

## 계층별 구성
코드를 구성하는 첫 번째 접근 방식은 계층별입니다. 다음과 같이 코드를 구성할 수 있습니다.

```bash
buckpal
├── domain
│   ├── Account
│   ├── AccountRepository
│   ├── AccountService
│   └── Activity
├── persistence
│   └── AccountRepositoryImpl
└── web
    └── AccountController
```

웹, 도메인, 영속성 각 계층에 대해 전용 패키지가 있습니다. 2장, 계층형 아키텍처의 문제점은 무엇인가?에서 논의했듯이, 단순한 계층은 여러 가지 이유로 코드에 가장 좋은 구조가 아닐 수 있으므로, 여기서는 이미 의존성 역전 원칙을 적용하여 도메인 패키지의 도메인 코드를 향한 의존성만 허용했습니다. 우리는 도메인 패키지에 `AccountRepository` 인터페이스를 도입하고 영속성 패키지에서 그것을 구현함으로써 이것을 했습니다.
그러나 이 패키지 구조가 최적이 아닌 데에는 적어도 세 가지 이유가 있습니다.

- 첫째, 애플리케이션의 기능적 슬라이스나 기능 사이에 패키지 경계가 없습니다. 사용자 관리 기능을 추가하면 웹 패키지에 `UserController`를 추가하고, 도메인 패키지에 `UserService`, `UserRepository`, `User`를 추가하고, 영속성 패키지에 `UserRepositoryImpl`을 추가할 것입니다. 추가적인 구조가 없으면 이것은 빠르게 클래스의 혼란이 되어 애플리케이션의 관련 없어 보이는 기능들 사이에 원치 않는 부작용을 초래할 수 있습니다.
- 둘째, 우리 애플리케이션이 어떤 유스케이스를 제공하는지 볼 수 없습니다. `AccountService`나 `AccountController` 클래스가 어떤 유스케이스를 구현하는지 말할 수 있습니까? 특정 기능을 찾고 있다면, 어떤 서비스가 그것을 구현하는지 추측한 다음 해당 서비스 내에서 책임 있는 메서드를 검색해야 합니다.
- 마지막으로, 패키지 구조 내에서 우리의 목표 아키텍처를 볼 수 없습니다. 우리가 헥사고날 아키텍처 스타일을 따랐다고 추측한 다음 웹 및 영속성 패키지의 클래스를 탐색하여 웹 및 영속성 어댑터를 찾을 수 있습니다. 그러나 웹 어댑터에 의해 어떤 기능이 호출되고 영속성 어댑터가 도메인 계층에 어떤 기능을 제공하는지 한눈에 볼 수 없습니다. 들어오고 나가는 포트는 코드에 숨겨져 있습니다.

"계층별 구성" 접근 방식의 몇 가지 문제를 해결해 봅시다.

## 기능별 구성
다음 접근 방식은 기능별로 코드를 구성하는 것입니다.

```
buckpal
└── account
    ├── Account
    ├── SendMoneyController
    ├── AccountRepository
    ├── AccountRepositoryImpl
    └── SendMoneyService
```

본질적으로, 우리는 계정과 관련된 모든 코드를 상위 수준 패키지 `account`에 넣었습니다. 또한 계층 패키지를 제거했습니다.
새로운 기능 그룹은 `account` 옆에 새로운 상위 수준 패키지를 얻게 되며, 외부에서 접근해서는 안 되는 클래스에 대해 패키지-전용 가시성을 사용하여 기능 간의 패키지 경계를 강제할 수 있습니다.
패키지 경계는 패키지-전용 가시성과 결합되어 기능 간의 원치 않는 의존성을 피할 수 있게 해줍니다.
또한 `AccountService`를 `SendMoneyService`로 이름을 변경하여 책임을 좁혔습니다(실제로 패키지별 계층 접근 방식에서도 그렇게 할 수 있었습니다). 이제 클래스 이름을 보는 것만으로 코드가 '송금' 유스케이스를 구현한다는 것을 알 수 있습니다. 애플리케이션의 기능을 코드에 보이게 만드는 것을 로버트 마틴은 "소리치는 아키텍처"라고 부릅니다. 왜냐하면 그것이 우리에게 그 의도를 소리치기 때문입니다.¹
그러나 기능별 패키지 접근 방식은 계층별 패키지 접근 방식보다 코드에서 우리 아키텍처를 훨씬 덜 명확하게 만듭니다. 어댑터를 식별할 패키지 이름이 없으며, 들어오고 나가는 포트도 여전히 보이지 않습니다. 게다가, 도메인 코드와 영속성 코드 사이의 의존성을 역전시켜 `SendMoneyService`가 `AccountRepository` 인터페이스만 알고 그 구현은 모르게 했음에도 불구하고, 패키지-전용 가시성을 사용하여 도메인 코드를 영속성 코드에 대한 우발적인 의존성으로부터 보호할 수 없습니다.
그렇다면 목표 아키텍처를 한눈에 볼 수 있게 하려면 어떻게 해야 할까요? 그림 3.4와 같은 아키텍처 다이어그램의 상자를 손가락으로 가리키고 코드의 어느 부분이 그 상자를 책임지는지 즉시 알 수 있다면 좋을 것입니다.
이를 지원할 만큼 표현력이 풍부한 패키지 구조를 만들기 위해 한 걸음 더 나아가 봅시다.

> 1 소리치는 아키텍처: 로버트 C. 마틴, 『클린 아키텍처』, 프렌티스 홀, 2017, 21장.

## 아키텍처를 표현하는 패키지 구조
헥사고날 아키텍처에서는 엔티티, 유스케이스, 입출력 포트, 그리고 입출력(또는 "구동" 및 "피동") 어댑터가 주요 아키텍처 요소입니다. 이 아키텍처를 표현하는 패키지 구조에 그것들을 맞춰 봅시다.

```buckpal
buckpal
├── adapter
│   ├── in
│   │   └── web
│   │       └── SendMoneyController
│   └── out
│       ├── AccountPersistenceAdapter
│       ├── persistence
│       └── SpringDataAccountRepository
├── application
│   ├── domain
│   │   ├── model
│   │   │   └── Account
│   │   └── service
│   │       └── SendMoneyService
│   └── port
│       ├── in
│       │   └── SendMoneyUseCase
│       └── out
│           └── UpdateAccountStatePort
└── common
```

아키텍처의 각 요소를 패키지 중 하나에 직접 매핑할 수 있습니다. 최상위 수준에는 `adapter`와 `application` 패키지가 있습니다.
`adapter` 패키지에는 애플리케이션의 인커밍 포트를 호출하는 인커밍 어댑터와 애플리케이션의 아웃고잉 포트에 대한 구현을 제공하는 아웃고잉 어댑터가 포함됩니다. 우리의 경우, 웹 및 영속성 어댑터가 있는 간단한 웹 애플리케이션을 구축하고 있으며, 각각 고유한 하위 패키지를 가지고 있습니다.
어댑터의 코드를 자체 패키지로 옮기면 필요할 경우 한 어댑터를 다른 구현으로 매우 쉽게 교체할 수 있다는 이점이 있습니다. 필요한 접근 패턴을 알고 있다고 생각했기 때문에 간단한 키-값 데이터베이스에 대해 영속성 어댑터를 구현하기 시작했지만, 그 패턴이 변경되어 이제 SQL 데이터베이스가 더 나을 것이라고 상상해보십시오. 우리는 단순히 새로운 어댑터 패키지에서 모든 관련 아웃고잉 포트를 구현한 다음 이전 패키지를 제거합니다.
`application` 패키지에는 우리 애플리케이션 코드인 "헥사곤"이 포함됩니다. 이 코드는 `domain` 패키지에 있는 우리 도메인 모델과 `port` 패키지에 있는 포트 인터페이스로 구성됩니다.
왜 포트가 그 옆이 아니라 `application` 패키지 안에 있을까요? 포트는 의존성 역전 원칙을 적용하는 우리의 방법입니다. 애플리케이션은 외부 세계와 통신하기 위해 이러한 포트를 정의합니다. `port` 패키지를 `application` 패키지 안에 넣는 것은 애플리케이션이 포트를 소유한다는 것을 표현합니다.
`domain` 패키지에는 입력 포트를 구현하고 도메인 엔티티 간에 조정하는 도메인 엔티티와 도메인 서비스가 포함됩니다.
마지막으로, 코드 베이스의 나머지 부분에서 공유되는 일부 코드를 포함하는 `common` 패키지가 있습니다.
휴, 기술적인 이름의 패키지가 많네요. 혼란스럽지 않나요?
사무실 벽에 걸려 있는 헥사고날 아키텍처의 상위 수준 뷰가 있고, 우리가 소비하는 타사 API의 클라이언트를 수정하는 것에 대해 동료와 이야기하고 있다고 상상해보십시오. 이것을 논의하는 동안, 우리는 서로를 더 잘 이해하기 위해 포스터의 해당 아웃고잉 어댑터를 가리킬 수 있습니다.
그런 다음, 이야기가 끝나면 IDE 앞에 앉아 바로 클라이언트 작업을 시작할 수 있습니다. 왜냐하면 우리가 이야기했던 API 클라이언트의 코드는 `adapter/out/<adapter-name>` 패키지에서 찾을 수 있기 때문입니다. 혼란스럽기보다는 오히려 도움이 되지 않나요?
이 패키지 구조는 소위 아키텍처/코드 갭 또는 모델/코드 갭에 맞서는 강력한 요소입니다.² 이러한 용어는 대부분의 소프트웨어 개발 프로젝트에서 아키텍처가 코드에 직접 매핑될 수 없는 추상적인 개념일 뿐이라는 사실을 설명합니다. 시간이 지남에 따라 패키지 구조(다른 것들 중에서)가 아키텍처를 반영하지 않으면 코드는 일반적으로 목표 아키텍처에서 점점 더 벗어날 것입니다.
또한, 이 표현력 있는 패키지 구조는 아키텍처에 대한 적극적인 사고를 촉진합니다. 우리는 코드를 어떤 패키지에 넣을지 적극적으로 결정해야 합니다. 하지만 그렇게 많은 패키지가 있다는 것은 패키지 간 접근을 허용하기 위해 모든 것이 공개되어야 한다는 것을 의미하지 않나요?
적어도 어댑터 패키지의 경우, 이것은 사실이 아닙니다. 그들이 포함하는 모든 클래스는 애플리케이션 패키지 내에 있는 포트 인터페이스를 통해서만 외부 세계에서 호출되기 때문에 패키지-전용일 수 있습니다. 따라서 애플리케이션 계층에서 어댑터 클래스로의 우발적인 의존성은 없습니다.
그러나 애플리케이션 패키지 내에서는 일부 클래스가 실제로 공개되어야 합니다. 포트는 설계상 어댑터에서 접근할 수 있어야 하므로 공개되어야 합니다. 도메인 모델은 서비스 및 잠재적으로 어댑터에서 접근할 수 있도록 공개되어야 합니다. 서비스는 인커밍 포트 인터페이스 뒤에 숨겨질 수 있으므로 공개될 필요가 없습니다.
따라서, 예, 이와 같은 세분화된 패키지 구조는 더 거친 패키지 구조에서 패키지-전용일 수 있는 일부 클래스를 공개하도록 요구합니다. 12장, 아키텍처 경계 강제하기에서 이러한 공개 클래스에 대한 원치 않는 접근을 포착하는 방법을 살펴볼 것입니다.
이 패키지 구조에는 계정 거래를 처리하는 도메인인 단 하나의 도메인만 포함되어 있다는 것을 알 수 있습니다. 그러나 많은 애플리케이션에는 둘 이상의 도메인의 코드가 포함됩니다.

> 2 모델/코드 갭: 조지 페어뱅크스, 『Just Enough Architecture』, 마샬 & 브레이너드, 2010, 167페이지.

13장, 여러 바운디드 컨텍스트 관리하기에서 배우게 될 것처럼, 헥사고날 아키텍처는 여러 도메인을 관리하는 방법을 실제로 알려주지 않습니다. 물론, 각 도메인의 코드를 도메인 패키지 아래의 자체 하위 패키지에 넣고 이런 식으로 도메인을 분리할 수 있습니다. 그러나 도메인별로 포트와 어댑터를 분리하는 것에 대해 생각하고 있다면, 이것이 빠르게 매핑 악몽으로 변할 수 있으므로 주의하십시오. 이에 대한 자세한 내용은 13장에서 다룹니다.
모든 구조와 마찬가지로, 소프트웨어 프로젝트의 수명 동안 이 패키지 구조를 유지하려면 규율이 필요합니다. 또한, 패키지 구조가 맞지 않아 아키텍처/코드 갭을 넓히고 아키텍처를 반영하지 않는 패키지를 만드는 것 외에는 다른 방법이 없는 경우도 있을 것입니다. 완벽함은 없습니다. 그러나 표현력 있는 패키지 구조를 사용하면 적어도 코드와 아키텍처 사이의 갭을 줄일 수 있습니다.

## 의존성 주입의 역할
앞서 설명한 패키지 구조는 클린 아키텍처를 달성하는 데 큰 도움이 되지만, 이러한 아키텍처의 필수 요구사항은 3장, 의존성 역전에서 배운 것처럼 애플리케이션 계층이 인커밍 및 아웃고잉 어댑터에 대한 의존성을 갖지 않는다는 것입니다.
웹 어댑터와 같은 인커밍 어댑터의 경우, 제어 흐름이 어댑터와 도메인 코드 간의 의존성과 동일한 방향을 가리키기 때문에 쉽습니다. 어댑터는 단순히 애플리케이션 계층 내의 서비스를 호출합니다. 애플리케이션에 대한 진입점을 명확하게 나타내기 위해 실제 서비스를 포트 인터페이스 뒤에 숨기고 싶을 것입니다.
영속성 어댑터와 같은 아웃고잉 어댑터의 경우, 제어 흐름의 방향에 대해 의존성을 바꾸기 위해 의존성 역전 원칙을 사용해야 합니다.
우리는 이미 그것이 어떻게 작동하는지 보았습니다. 우리는 애플리케이션 계층 내에 인터페이스를 만들고, 어댑터 내의 클래스가 그것을 구현하도록 합니다. 우리의 헥사고날 아키텍처 내에서 이 인터페이스는 포트입니다. 그런 다음 애플리케이션 계층은 이 포트 인터페이스를 호출하여 그림 4.1과 같이 어댑터의 기능을 호출합니다.

![[tom_hombergs_21.png]]
*그림 4.1 – 웹 컨트롤러는 서비스에 의해 구현되는 인커밍 포트를 호출하고, 서비스는 어댑터에 의해 구현되는 아웃고잉 포트를 호출한다*

하지만 누가 애플리케이션에 포트 인터페이스를 구현하는 실제 객체를 제공할까요? 우리는 어댑터에 대한 의존성을 도입하고 싶지 않기 때문에 애플리케이션 계층 내에서 포트를 수동으로 인스턴스화하고 싶지 않습니다.
여기가 바로 의존성 주입이 필요한 곳입니다. 우리는 모든 계층에 대한 의존성을 가진 중립적인 구성 요소를 도입합니다. 이 구성 요소는 우리 아키텍처를 구성하는 대부분의 클래스를 인스턴스화하는 역할을 합니다.
앞의 예제 그림에서, 중립적인 의존성 주입 구성 요소는 `SendMoneyController`, `SendMoneyService`, `AccountPersistenceAdapter` 클래스의 인스턴스를 생성합니다. `SendMoneyController`는 `SendMoneyUseCase`가 필요하기 때문에, 의존성 주입 메커니즘은 생성 중에 `SendMoneyService` 클래스의 인스턴스를 제공합니다. 컨트롤러는 인터페이스만 알면 되기 때문에 실제로 `SendMoneyService` 인스턴스를 받았는지 모릅니다.
마찬가지로, `SendMoneyService` 인스턴스를 생성할 때, 의존성 주입 메커니즘은 `UpdateAccountStatePort` 인터페이스를 가장한 `AccountPersistenceAdapter` 클래스의 인스턴스를 주입합니다. 서비스는 인터페이스 뒤에 있는 실제 클래스를 결코 알지 못합니다.
10장, 애플리케이션 조립하기에서 스프링 프레임워크를 예로 들어 애플리케이션을 초기화하는 것에 대해 더 이야기할 것입니다.

## 이것이 유지보수 가능한 소프트웨어를 구축하는 데 어떻게 도움이 되는가?
우리는 실제 코드 구조를 가능한 한 목표 아키텍처에 가깝게 만드는 헥사고날 아키텍처의 패키지 구조를 살펴보았습니다. 코드에서 아키텍처의 요소를 찾는 것은 이제 아키텍처 다이어그램의 특정 상자 이름을 따라 패키지 구조를 탐색하는 문제이며, 이는 커뮤니케이션, 개발 및 유지보수에 도움이 됩니다.
다음 장에서는 애플리케이션 계층에서 유스케이스를 구현하고, 웹 어댑터와 영속성 어댑터를 구현하면서 이 패키지 구조와 의존성 주입이 실제로 작동하는 것을 볼 것입니다.

---

# 5. 유스케이스 구현하기
드디어 우리가 논의한 아키텍처를 실제 코드로 어떻게 나타낼 수 있는지 살펴보겠습니다.
애플리케이션, 웹, 영속성 계층이 우리 아키텍처에서 매우 느슨하게 결합되어 있기 때문에, 우리는 도메인 코드를 우리가 적합하다고 생각하는 대로 자유롭게 모델링할 수 있습니다. 도메인 주도 설계(DDD)를 하거나, 풍부하거나 빈약한 도메인 모델을 구현하거나, 우리만의 방식을 발명할 수 있습니다.
이 장에서는 이전 장에서 소개한 헥사고날 아키텍처 스타일 내에서 유스케이스를 구현하는 독단적인 방법을 설명합니다.
도메인 중심 아키텍처에 걸맞게, 우리는 도메인 엔티티로 시작한 다음 그 주위에 유스케이스를 구축할 것입니다.

## 도메인 모델 구현하기
한 계정에서 다른 계정으로 돈을 보내는 유스케이스를 구현하고 싶습니다. 이것을 객체 지향 방식으로 모델링하는 한 가지 방법은 출금 계좌에서 돈을 인출하고 대상 계좌에 입금할 수 있게 해주는 `Account` 엔티티를 만드는 것입니다.

```java
package buckpal.application.domain.model;

public class Account {

    private AccountId id;
    private Money baselineBalance;
    private ActivityWindow activityWindow;

    // constructors and getters omitted

    public Money calculateBalance() {
        return Money.add(
            this.baselineBalance,
            this.activityWindow.calculateBalance(this.id));
    }

    public boolean withdraw(Money money, AccountId targetAccountId) {
        if (!mayWithdraw(money)) {
            return false;
        }

        Activity withdrawal = new Activity(
            this.id,
            this.id,
            targetAccountId,
            LocalDateTime.now(),
            money);
        this.activityWindow.addActivity(withdrawal);
        return true;
    }

    private boolean mayWithdraw(Money money) {
        return Money.add(
            this.calculateBalance(),
            money.negate())
            .isPositive();
    }

    public boolean deposit(Money money, AccountId sourceAccountId) {
        Activity deposit = new Activity(
            this.id,
            sourceAccountId,
            this.id,
            LocalDateTime.now(),
            money);
        this.activityWindow.addActivity(deposit);
        return true;
    }
}
```

`Account` 엔티티는 실제 계정의 현재 스냅샷을 제공합니다. 계정에서의 모든 인출 및 입금은 `Activity` 엔티티에 기록됩니다. 계정의 모든 활동을 항상 메모리에 로드하는 것은 현명하지 않으므로, `Account` 엔티티는 `ActivityWindow` 값 객체에 캡처된 최근 며칠 또는 몇 주 동안의 활동 창만 보유합니다.
현재 계정 잔액을 계산할 수 있도록, `Account` 엔티티는 활동 창의 첫 번째 활동 직전의 계정 잔액을 나타내는 `baselineBalance` 속성을 추가로 가집니다. 그러면 총 잔액은 기준 잔액에 창의 모든 활동 잔액을 더한 값이 됩니다.
이 모델을 사용하면, `withdraw()` 및 `deposit()` 메서드에서 수행되는 것처럼 계좌에 돈을 인출하고 입금하는 것은 활동 창에 새로운 활동을 추가하는 문제입니다. 인출하기 전에, 우리는 계좌를 초과 인출할 수 없다는 비즈니스 규칙을 확인합니다.
이제 돈을 인출하고 입금할 수 있는 `Account`가 있으므로, 그 주위에 유스케이스를 구축하기 위해 바깥쪽으로 이동할 수 있습니다.

## 유스케이스란 무엇인가
먼저, 유스케이스가 실제로 무엇을 하는지 논의해 봅시다. 보통 다음 단계를 따릅니다.

1. 입력을 받는다.
2. 비즈니스 규칙을 검증한다.
3. 모델 상태를 조작한다.
4. 출력을 반환한다.

유스케이스는 인커밍 어댑터로부터 입력을 받습니다. 첫 번째 단계를 '입력 검증'이라고 부르지 않은 이유가 궁금할 수 있습니다. 그 이유는 유스케이스 코드는 도메인 로직에만 관련되어야 하며 입력 검증으로 오염시키지 않아야 한다고 생각하기 때문입니다. 그래서 우리는 곧 보게 될 다른 곳에서 입력 검증을 할 것입니다.
그러나 유스케이스는 비즈니스 규칙을 검증할 책임이 있습니다. 이 책임은 도메인 엔티티와 공유합니다. 이 장의 뒷부분에서 입력 검증과 비즈니스 규칙 검증의 차이점에 대해 논의할 것입니다.
비즈니스 규칙이 충족되면, 유스케이스는 입력에 따라 모델의 상태를 어떤 식으로든 조작합니다. 보통, 도메인 객체의 상태를 변경하고 이 새로운 상태를 영속성 어댑터에 의해 구현된 포트로 전달하여 영속화합니다. 유스케이스가 영속성 이외의 다른 부작용을 유발하는 경우, 각 부작용에 대해 적절한 어댑터를 호출합니다.
마지막 단계는 아웃고잉 어댑터의 반환 값을 호출 어댑터로 반환될 출력 객체로 변환하는 것입니다.
이러한 단계를 염두에 두고, '송금' 유스케이스를 어떻게 구현할 수 있는지 봅시다.
2장, 계층형 아키텍처의 문제점은 무엇인가?에서 논의된 광범위한 서비스의 문제를 피하기 위해, 모든 유스케이스를 단일 서비스 클래스에 넣는 대신 각 유스케이스에 대해 별도의 서비스 클래스를 만들 것입니다.
여기 티저가 있습니다.

```java
package buckpal.application.domain.service;

@RequiredArgsConstructor
@Transactional
public class SendMoneyService implements SendMoneyUseCase {

    private final LoadAccountPort loadAccountPort;
    private final UpdateAccountStatePort updateAccountStatePort;

    @Override
    public boolean sendMoney(SendMoneyCommand command) {
        // TODO: validate business rules
        // TODO: manipulate model state
        // TODO: return output
    }
}
```

서비스는 `SendMoneyUseCase` 인커밍 포트 인터페이스를 구현하고, 계정을 로드하기 위해 `LoadAccountPort` 아웃고잉 포트 인터페이스를 호출하고, 업데이트된 계정 상태를 데이터베이스에 영속화하기 위해 `UpdateAccountStatePort` 포트를 호출합니다.
서비스는 또한 `@Transactional` 어노테이션에 의해 암시된 대로 데이터베이스 트랜잭션의 경계를 설정합니다. 이에 대한 자세한 내용은 7장, 영속성 어댑터 구현하기에서 다룹니다.

그림 5.1은 관련 구성 요소의 시각적 개요를 제공합니다.

![[tom_hombergs_24.png]]
*그림 5.1 – 서비스는 유스케이스를 구현하고, 도메인 모델을 수정하며, 수정된 상태를 영속화하기 위해 아웃고잉 포트를 호출한다*

> **참고**
> 이 예에서 `UpdateAccountStatePort`와 `LoadAccountPort`는 영속성 어댑터에 의해 구현되는 포트 인터페이스입니다. 만약 그것들이 자주 함께 사용된다면, 우리는 그것들을 더 넓은 인터페이스로 결합할 수도 있습니다. 우리는 심지어 DDD 언어에 충실하기 위해 그 인터페이스를 `AccountRepository`라고 부를 수도 있습니다. 이 예와 이 책의 나머지 부분에서, 저는 "Repository"라는 이름을 영속성 어댑터에서만 사용하기로 선택했지만, 여러분은 다른 이름을 선택할 수 있습니다!

앞의 코드에 남겨둔 `TODO` 주석을 처리해 봅시다.

## 입력 유효성 검사
이제 입력 유효성 검사에 대해 이야기하고 있지만, 방금 그것이 유스케이스 클래스의 책임이 아니라고 주장했습니다. 그러나 저는 여전히 그것이 애플리케이션 계층에 속한다고 생각하므로, 여기서 논의할 곳입니다.
호출하는 어댑터가 유스케이스로 보내기 전에 입력을 검증하도록 하지 않는 이유는 무엇일까요? 글쎄요, 우리는 호출자가 유스케이스에 필요한 모든 것을 검증했다고 신뢰하고 싶을까요? 또한, 유스케이스는 둘 이상의 어댑터에 의해 호출될 수 있으므로, 검증은 각 어댑터에 의해 구현되어야 하며, 하나는 잘못하거나 완전히 잊어버릴 수 있습니다.
애플리케이션 계층은 입력 유효성 검사에 신경 써야 합니다. 왜냐하면, 그렇지 않으면 애플리케이션 코어 외부에서 유효하지 않은 입력을 받을 수 있기 때문입니다. 이것은 우리 모델의 상태에 손상을 줄 수 있습니다.
하지만 유스케이스 클래스가 아니라면 입력 유효성 검사를 어디에 둘까요?
우리는 입력 모델이 그것을 처리하도록 할 것입니다. '송금' 유스케이스의 경우, 입력 모델은 이전 코드 예제에서 이미 본 `SendMoneyCommand` 클래스입니다. 더 정확하게는, 생성자 내에서 유효성 검사를 수행할 것입니다.

```java
package buckpal.application.port.in;

public record SendMoneyCommand(
    AccountId sourceAccountId,
    AccountId targetAccountId,
    Money money) {

    public SendMoneyCommand(
        AccountId sourceAccountId,
        AccountId targetAccountId,
        Money money) {
        requireNonNull(sourceAccountId);
        requireNonNull(targetAccountId);
        requireNonNull(money);
        requireGreaterThan(money, 0);
        this.sourceAccountId = sourceAccountId;
        this.targetAccountId = targetAccountId;
        this.money = money;
    }
}
```

돈을 보내려면, 출금 계좌와 입금 계좌의 ID, 그리고 이체할 금액이 필요합니다. 매개변수 중 어느 것도 null이 될 수 없으며 금액은 0보다 커야 합니다.
이러한 조건 중 하나라도 위반되면, 생성 중에 예외를 발생시켜 객체 생성을 거부합니다.
`SendMoneyCommand`를 구현하기 위해 레코드를 사용함으로써, 우리는 그것을 불변으로 만듭니다. 따라서 성공적으로 생성되면, 상태가 유효하고 유효하지 않은 것으로 변경될 수 없다는 것을 확신할 수 있습니다.
`SendMoneyCommand`는 유스케이스 API의 일부이므로, 인커밍 포트 패키지에 위치합니다. 따라서 유효성 검사는 애플리케이션의 핵심(우리 아키텍처의 육각형 가장자리)에 남아 있지만, 신성한 유스케이스 코드를 오염시키지 않습니다.
하지만 우리를 위해 더러운 일을 해줄 수 있는 라이브러리가 있는데, 각 유효성 검사 검사를 직접 구현하고 싶을까요? 저는 종종 "모델 클래스에서 라이브러리를 사용해서는 안 된다"와 같은 말을 들었습니다. 물론, 의존성을 최소한으로 줄이는 데는 지혜가 있지만, 시간을 절약해주는 작은 풋프린트 의존성으로 넘어갈 수 있다면, 왜 사용하지 않을까요? 자바의 빈 유효성 검사 API로 이것이 어떻게 보일 수 있는지 탐색해 봅시다.¹

> 1 빈 유효성 검사: https://beanvalidation.org/.

빈 유효성 검사를 사용하면 필요한 유효성 검사 규칙을 클래스의 필드에 어노테이션으로 표현할 수 있습니다.

```java
package buckpal.application.port.in;

public record SendMoneyCommand(
    @NotNull AccountId sourceAccountId,
    @NotNull AccountId targetAccountId,
    @NotNull @PositiveMoney Money money) {

    public SendMoneyCommand(
        AccountId sourceAccountId,
        AccountId targetAccountId,
        Money money) {
        this.sourceAccountId = sourceAccountId;
        this.targetAccountId = targetAccountId;
        this.money = money;
        Validator.validate(this);
    }
}
```

`Validator` 클래스는 `validate()` 메서드를 제공하며, 생성자의 마지막 문장으로 간단히 호출합니다. 이것은 필드의 빈 유효성 검사 어노테이션(@NotNull, 이 경우)을 평가하고 위반 시 예외를 발생시킵니다. 기본 빈 유효성 검사 어노테이션이 특정 유효성 검사에 충분히 표현력이 없다면, `@PositiveMoney` 어노테이션으로 했던 것처럼 우리 자신의 어노테이션과 유효성 검사기를 구현할 수 있습니다.²
`Validator` 클래스의 구현은 다음과 같을 수 있습니다.

```java
public class Validator {

    private final static jakarta.validation.Validator validator =
        Validation.buildDefaultValidatorFactory()
            .getValidator();

    /**
     * Evaluates all Bean Validation annotations on the subject.
     */
    public static <T> void validate(T subject) {
        Set<ConstraintViolation<T>> violations = validator.validate(subject);
        if (!violations.isEmpty()) {
            throw new ConstraintViolationException(violations);
        }
    }
}
```

> 2 `@PositiveMoney` 어노테이션과 유효성 검사기를 구현하는 전체 코드는 깃허브 저장소 https://github.com/thombergs/buckpal에서 찾을 수 있습니다.

입력 모델에 유효성 검사를 위치시킴으로써, 우리는 유스케이스 구현 주위에 부패 방지 계층을 만들었습니다. 이것은 계층형 아키텍처의 의미에서 계층이 아니며, 그 아래의 다음 계층을 호출하는 것이 아니라, 대신 나쁜 입력을 호출자에게 되돌려 보내는 유스케이스 주위의 얇은 보호막입니다.
`SendMoneyCommand` 클래스에서 사용된 "커맨드"라는 용어는 "커맨드 패턴"의 일반적인 해석과 일치하지 않는다는 점에 유의하십시오.³ 커맨드 패턴에서 커맨드는 실행 가능합니다. 즉, 실제로 유스케이스를 호출하는 `execute()`라는 메서드를 가집니다. 우리의 경우, 커맨드는 커맨드를 실행하는 유스케이스 서비스에 필요한 매개변수를 전송하는 데이터 전송 객체일 뿐입니다. 우리는 그것을 `SendMoneyDTO`라고 부를 수도 있지만, 이 유스케이스로 모델 상태를 변경하고 있다는 것을 매우 명확하게 하기 위해 "커맨드"라는 용어를 좋아합니다.

## 생성자의 힘
우리의 입력 모델인 `SendMoneyCommand`는 생성자에 많은 책임을 부여합니다. 클래스가 불변이기 때문에, 생성자의 인수 목록에는 클래스의 각 속성에 대한 매개변수가 포함됩니다. 그리고 생성자는 매개변수도 검증하기 때문에, 유효하지 않은 상태의 객체를 생성하는 것은 불가능합니다.
우리의 경우, 생성자에는 세 개의 매개변수만 있습니다. 매개변수가 더 많았다면 어땠을까요? 사용하기 더 편리하게 만들기 위해 빌더 패턴을 사용할 수 없을까요? 긴 매개변수 목록을 가진 생성자를 비공개로 만들고 빌더의 `build()` 메서드에서 그 호출을 숨길 수 있습니다. 그런 다음 20개의 매개변수를 가진 생성자를 호출하는 대신, 다음과 같이 객체를 빌드할 수 있습니다.

```java
new SendMoneyCommandBuilder()
    .sourceAccountId(new AccountId(41L))
    .targetAccountId(new AccountId(42L))
    // ... initialize many other fields
    .build();
```

우리는 여전히 생성자가 유효성 검사를 하도록 할 수 있으므로 빌더는 유효하지 않은 상태의 객체를 생성할 수 없습니다.
좋게 들리나요? `SendMoneyCommandBuilder`에 다른 필드를 추가해야 할 때 어떤 일이 일어나는지 생각해보십시오(소프트웨어 프로젝트의 수명 동안 꽤 여러 번 일어날 것입니다). 생성자와 빌더에 새 필드를 추가합니다. 그런 다음 동료(또는 전화, 이메일, 나비...)가 우리의 생각의 흐름을 방해합니다. 휴식 후, 우리는 코딩으로 돌아가서 객체를 생성하기 위해 빌더를 호출하는 코드에 새 필드를 추가하는 것을 잊어버립니다.
컴파일러로부터 유효하지 않은 상태의 불변 객체를 생성하려고 한다는 경고 한마디도 받지 못합니다! 물론, 런타임에 – 바라건대 단위 테스트에서 – 우리의 유효성 검사 로직이 여전히 작동하여 매개변수를 놓쳤기 때문에 오류를 발생시킬 것입니다.

> 3 커맨드 패턴: https://en.wikipedia.org/wiki/Command_pattern.

그러나 빌더 뒤에 숨기는 대신 생성자를 직접 사용하면, 새 필드가 추가되거나 기존 필드가 제거될 때마다 컴파일 오류의 흔적을 따라 코드 베이스의 나머지 부분에 해당 변경 사항을 반영할 수 있습니다.
긴 매개변수 목록은 보기 좋게 서식 지정할 수 있으며, 좋은 IDE는 매개변수 이름 힌트로 도움이 됩니다.

```java
new ClassWithManyFields(
    name: "Donald",
    LocalDate.of(year: 1934, month: 6, dayOfMonth: 9),
    socialSecurityNumber: "1234567",
    birthPlace: "Duckburg",
    street: "Duckstreet 42",
    city: "Duckburg",
    zipcode: "12345",
    country: "USA",
    state: "Calisota");
```
*그림 5.2 – IDE는 우리가 길을 잃지 않도록 매개변수 목록에 매개변수 이름 힌트를 보여준다*

앞의 코드를 더 읽기 쉽고 안전하게 작업하기 위해, 생성자 매개변수로 사용했던 일부 기본형을 대체하기 위해 불변 값 객체를 도입할 수 있습니다. 값 객체는 그 값이 정체성인 객체입니다. 동일한 값을 가진 두 값 객체는 동일한 것으로 간주됩니다.
거리, 도시, 우편번호, 국가 및 주를 별도로 전달하는 대신, 예를 들어 그것들이 함께 속하기 때문에 `Address` 값 객체로 결합할 수 있습니다. 우리는 심지어 한 걸음 더 나아가 예를 들어 `City` 및 `ZipCode` 값 객체를 만들 수도 있습니다. 이것은 한 문자열 매개변수를 다른 문자열 매개변수와 혼동할 가능성을 줄여줄 것입니다. 왜냐하면 컴파일러는 `ZipCode` 매개변수에 `City`를 전달하려고 하면 불평할 것이기 때문입니다.
그러나 빌더가 더 나은 해결책일 수 있는 경우가 있습니다. 예를 들어, 앞의 예의 `ClassWithManyFields`의 일부 매개변수가 선택 사항인 경우, 생성자에 `null` 값을 전달해야 하며, 이는 기껏해야 보기 흉합니다. 빌더를 사용하면 필요한 매개변수만 정의할 수 있습니다. 그러나 빌더를 사용하는 경우, 컴파일러가 우리를 위해 확인해주지 않기 때문에 필요한 매개변수를 정의하는 것을 잊었을 때 `build()` 메서드가 큰 소리로 실패하도록 해야 합니다!

## 다른 유스케이스를 위한 다른 입력 모델
우리는 다른 유스케이스에 대해 동일한 입력 모델을 사용하고 싶은 유혹을 받을 수 있습니다. '계정 등록'과 '계정 세부 정보 업데이트' 유스케이스를 고려해 봅시다. 둘 다 처음에는 사용자 이름 및 이메일 주소와 같은 일부 계정 세부 정보인 거의 동일한 입력이 필요합니다.
그러나 '업데이트' 유스케케이스는 업데이트해야 하는 계정의 ID가 필요한 반면, '등록' 유스케이스는 그렇지 않습니다. 두 유스케이스가 동일한 입력 모델을 사용하는 경우, '등록' 유스케이스에 항상 `null` 계정 ID를 전달해야 합니다. 이것은 기껏해야 성가시고, 최악의 경우 해롭습니다. 왜냐하면 두 유스케이스가 이제 함께 발전하도록 결합되었기 때문입니다.
불변 커맨드 객체의 필드에 `null`을 유효한 상태로 허용하는 것은 그 자체로 코드 스멜입니다. 하지만 더 중요한 것은, 이제 입력 유효성 검사를 어떻게 처리할까요? '등록'과 '업데이트' 유스케이스에 대한 유효성 검사는 하나는 ID가 필요하고 다른 하나는 필요하지 않기 때문에 달라야 합니다. 우리는 유스케이스 자체에 사용자 지정 유효성 검사 로직을 구축하여 신성한 비즈니스 코드를 입력 유효성 검사 문제로 오염시켜야 합니다.
또한, '계정 등록' 유스케이스에서 계정 ID 필드에 우연히 `null`이 아닌 값이 있으면 어떻게 해야 할까요? 오류를 발생시켜야 할까요? 아니면 그냥 무시해야 할까요? 이것들은 코드를 볼 때 유지보수 엔지니어(미래의 우리 포함)가 물어볼 질문입니다.
각 유스케이스에 대한 전용 입력 모델은 유스케이스를 훨씬 더 명확하게 만들고 다른 유스케이스와 분리하여 원치 않는 부작용을 방지합니다. 그러나 들어오는 데이터를 다른 유스케이스에 대해 다른 입력 모델로 매핑해야 하기 때문에 비용이 발생합니다. 9장, 경계 간 매핑에서 다른 매핑 전략과 함께 이 매핑 전략에 대해 논의할 것입니다.

## 비즈니스 규칙 유효성 검사
입력 유효성 검사는 유스케이스 로직의 일부가 아니지만, 비즈니스 규칙 유효성 검사는 확실히 그렇습니다. 비즈니스 규칙은 애플리케이션의 핵심이며 적절한 주의를 기울여 처리해야 합니다. 하지만 언제 입력 유효성 검사를 다루고 언제 비즈니스 규칙을 다루고 있을까요?
둘 사이의 매우 실용적인 구별은 비즈니스 규칙을 검증하려면 도메인 모델의 현재 상태에 대한 접근이 필요한 반면, 입력 검증은 그렇지 않다는 것입니다. 입력 검증은 이전에 `@NotNull` 어노테이션으로 했던 것처럼 선언적으로 구현할 수 있는 반면, 비즈니스 규칙은 더 많은 컨텍스트가 필요합니다.
우리는 또한 입력 유효성 검사는 구문적 유효성 검사인 반면, 비즈니스 규칙은 유스케이스의 맥락에서 의미론적 유효성 검사라고 말할 수도 있습니다.
'출금 계좌는 초과 인출되어서는 안 된다'는 규칙을 예로 들어 보겠습니다. 이전 정의에 따르면, 이것은 출금 계좌의 잔액을 확인하기 위해 모델의 현재 상태에 접근해야 하므로 비즈니스 규칙입니다.
반면에, '이체 금액은 0보다 커야 한다'는 규칙은 모델에 접근하지 않고도 검증할 수 있으므로 입력 유효성 검사의 일부로 구현될 수 있습니다.
이 구분이 논쟁의 여지가 있을 수 있다는 것을 알고 있습니다. 이체 금액이 너무 중요해서 어떤 경우에도 비즈니스 규칙으로 간주되어야 한다고 주장할 수도 있습니다.
그러나 이 구분은 코드 베이스 내에 특정 유효성 검사를 배치하고 나중에 쉽게 다시 찾는 데 도움이 됩니다. 유효성 검사가 현재 모델 상태에 접근해야 하는지 여부에 대한 질문에 답하는 것만큼 간단합니다. 이것은 규칙을 처음 구현하는 데 도움이 될 뿐만 아니라 미래의 유지보수 엔지니어가 다시 찾는 데도 도움이 됩니다. 이것은 또한 1장, 유지보수성에서 제가 주장한 유지보수성이 의사결정을 지원한다는 주장의 훌륭한 예입니다.
그렇다면 비즈니스 규칙을 어떻게 구현할까요?
가장 좋은 방법은 '출금 계좌는 초과 인출되어서는 안 된다'는 규칙에 대해 했던 것처럼 비즈니스 규칙을 도메인 엔티티에 넣는 것입니다.

```java
package buckpal.application.domain.service;

@RequiredArgsConstructor
@Transactional
public class SendMoneyService implements SendMoneyUseCase {

    // ...

    @Override
    public boolean sendMoney(SendMoneyCommand command) {
        requireAccountExists(command.sourceAccountId());
        requireAccountExists(command.targetAccountId());
        ...
    }
}
```

이런 식으로, 비즈니스 규칙은 이 규칙이 존중되어야 하는 비즈니스 로직 바로 옆에 있기 때문에 찾고 추론하기 쉽습니다.
도메인 엔티티에서 비즈니스 규칙을 검증하는 것이 불가능한 경우, 도메인 엔티티 작업을 시작하기 전에 유스케이스 코드에서 할 수 있습니다.

```java
package buckpal.application.domain.model;

public class Account {

// ...

    public boolean withdraw(
        Money money,
        AccountId targetAccountId) {
        if (!mayWithdraw(money)) {
            return false;
        }
        // ...
    }
}
```

실제 유효성 검사를 수행하고 이 유효성 검사가 실패하면 전용 예외를 발생시키는 메서드를 호출합니다. 그러면 사용자와 상호 작용하는 어댑터가 이 예외를 사용자에게 오류 메시지로 표시하거나 적절하다고 판단하는 다른 방식으로 처리할 수 있습니다.
앞의 경우, 유효성 검사는 단순히 출금 계좌와 입금 계좌가 실제로 데이터베이스에 존재하는지 확인합니다. 더 복잡한 비즈니스 규칙은 데이터베이스에서 도메인 모델을 먼저 로드한 다음 그 상태에 대해 일부 검사를 수행해야 할 수 있습니다. 어쨌든 도메인 모델을 로드해야 하는 경우, '출금 계좌는 초과 인출되어서는 안 된다'는 규칙으로 했던 것처럼 도메인 엔티티 자체에 비즈니스 규칙을 구현해야 합니다.

## 풍부한 도메인 모델 대 빈약한 도메인 모델
우리 아키텍처 스타일은 도메인 모델을 어떻게 구현할지 열어둡니다. 이것은 우리 상황에 맞는 것을 할 수 있기 때문에 축복이지만, 우리를 도울 지침이 없기 때문에 저주이기도 합니다.
빈번한 논의는 DDD 철학을 따르는 풍부한 도메인 모델을 구현할 것인지, 아니면 "빈약한" 도메인 모델을 구현할 것인지입니다. 이들 각각이 우리 아키텍처에 어떻게 들어맞는지 논의해 봅시다.
풍부한 도메인 모델에서는 가능한 한 많은 도메인 로직이 애플리케이션의 핵심에 있는 엔티티 내에 구현됩니다. 엔티티는 상태를 변경하는 메서드를 제공하고 비즈니스 규칙에 따라 유효한 변경만 허용합니다. 이것이 우리가 이전에 `Account` 엔티티를 추구했던 방식입니다.
이 시나리오에서 우리의 유스케이스 구현은 어디에 있습니까?
이 경우, 우리의 유스케이스는 도메인 모델의 진입점 역할을 합니다. 그러면 유스케이스는 사용자의 의도를 나타낼 뿐이며, 실제 작업을 수행하는 도메인 엔티티에 대한 오케스트레이션된 메서드 호출로 변환합니다. 많은 비즈니스 규칙이 유스케이스 구현 대신 엔티티에 위치합니다.
'송금' 유스케이스 서비스는 출금 및 입금 계정 엔티티를 로드하고, 그들의 `withdraw()` 및 `deposit()` 메서드를 호출하고, 데이터베이스로 다시 보냅니다.⁴
"빈약한" 도메인 모델에서 엔티티 자체는 매우 얇습니다. 그들은 보통 상태를 유지하기 위한 필드와 상태를 읽고 변경하기 위한 게터 및 세터 메서드만 제공합니다. 그들은 어떤 도메인 로직도 포함하지 않습니다.
이것은 도메인 로직이 유스케이스 클래스에 구현된다는 것을 의미합니다. 그들은 비즈니스 규칙을 검증하고, 엔티티의 상태를 변경하고, 데이터베이스에 저장하는 책임을 지는 아웃고잉 포트로 전달하는 책임을 집니다. "풍부함"은 엔티티 대신 유스케이스 내에 포함됩니다.
어떤 스타일이든, 그리고 다른 많은 스타일이든, 이 책에서 논의된 아키텍처 접근 방식을 사용하여 구현할 수 있습니다. 필요에 맞는 것을 자유롭게 선택하십시오.

> 4 실제로, '송금' 유스케이스는 계좌 초과 인출을 피하기 위해 출금 및 입금 계좌에 대한 다른 송금이 동시에 발생하지 않도록 해야 합니다.

## 다른 유스케이스를 위한 다른 출력 모델
유스케이스가 작업을 완료하면 호출자에게 무엇을 반환해야 할까요?
입력과 마찬가지로, 출력이 유스케이스에 가능한 한 구체적일 경우 이점이 있습니다. 출력은 호출자가 작업하는 데 정말로 필요한 데이터만 포함해야 합니다.
'송금' 유스케이스의 예제 코드에서 우리는 불리언을 반환합니다. 이것은 이 맥락에서 우리가 반환할 수 있는 최소이자 가장 구체적인 값입니다.
업데이트된 엔티티와 함께 완전한 `Account`를 호출자에게 반환하고 싶은 유혹을 받을 수 있습니다. 아마도 호출자는 계정의 새로운 잔액에 관심이 있을 것입니다.
하지만 우리는 정말로 '송금' 유스케이스가 이 데이터를 반환하게 하고 싶을까요? 호출자가 정말로 그것을 필요로 할까요? 그렇다면, 다른 호출자가 사용할 수 있는 해당 데이터에 접근하기 위한 전용 유스케이스를 만들어야 하지 않을까요?
이러한 질문에 대한 단일 정답은 없습니다. 그러나 우리는 유스케이스를 가능한 한 구체적으로 유지하기 위해 그것들을 물어봐야 합니다. 의심스러울 때는 가능한 한 적게 반환하십시오.
유스케이스 간에 동일한 출력 모델을 공유하는 것은 또한 해당 유스케이스를 긴밀하게 결합하는 경향이 있습니다. 유스케이스 중 하나가 출력 모델에 새 필드를 필요로 하는 경우, 다른 유스케이스도 관련이 없더라도 이 필드를 처리해야 합니다. 공유 모델은 장기적으로 여러 가지 이유로 종양처럼 성장하는 경향이 있습니다. 단일 책임 원칙을 적용하고 모델을 분리하여 유지하는 것은 유스케이스를 분리하는 데 도움이 됩니다.
같은 이유로, 우리는 도메인 엔티티를 출력 모델로 사용하려는 유혹에 저항하고 싶을 수 있습니다. 우리는 도메인 엔티티가 필요한 것보다 더 많은 이유로 변경되는 것을 원하지 않습니다. 그러나 11장, 의식적으로 지름길 택하기에서 엔티티를 입력 또는 출력 모델로 사용하는 것에 대해 더 이야기할 것입니다.

## 읽기 전용 유스케이스는 어떤가?
지금까지 우리는 모델의 상태를 수정하는 유스케이스를 어떻게 구현할 수 있는지 논의했습니다. 읽기 전용 케이스는 어떻게 구현할까요? UI가 계정의 잔액을 표시해야 한다고 가정해 봅시다. 이를 위해 특정 유스케이스 구현을 만들까요?
이와 같은 읽기 전용 작업에 대해 유스케이스라고 말하는 것은 어색합니다. 물론, UI는 '계정 잔액 보기'라고 부를 수 있는 유스케이스에 대한 데이터가 필요하지만, 어떤 경우에는 이것을 "유스케이스"라고 부르는 것이 약간 인위적입니다. 이것이 프로젝트의 맥락에서 유스케이스로 간주된다면, 우리는 다른 것들과 마찬가지로 그것을 구현해야 합니다.
그러나 애플리케이션 코어의 관점에서 보면, 이것은 데이터에 대한 간단한 쿼리입니다. 따라서 프로젝트의 맥락에서 유스케이스로 간주되지 않는 경우, 실제 유스케이스와 구별하기 위해 쿼리로 구현할 수 있습니다.
우리 아키텍처 스타일 내에서 이것을 하는 한 가지 방법은 쿼리에 대한 전용 인커밍 포트를 만들고 "쿼리 서비스"에서 그것을 구현하는 것입니다.

```java
package buckpal.application.domain.service;

@RequiredArgsConstructor
class GetAccountBalanceService implements GetAccountBalanceUseCase {

    private final LoadAccountPort loadAccountPort;

    public Money getAccountBalance(GetAccountBalanceQuery query) {
        return loadAccountPort.loadAccount(query.accountId(), LocalDateTime.now())
                .calculateBalance();
    }
}
```

쿼리 서비스는 "커맨드" 유스케이스 서비스와 마찬가지로 작동합니다. `GetAccountBalanceUseCase`라는 인커밍 포트를 구현하고, 데이터베이스에서 실제로 데이터를 로드하기 위해 아웃고잉 포트인 `LoadAccountPort`를 호출합니다. 입력 모델로 `GetAccountBalanceQuery` 유형을 사용하고 있습니다.
이런 식으로, 읽기 전용 쿼리는 우리 코드 베이스에서 수정 유스케이스(또는 "커맨드")와 명확하게 구별됩니다. 우리는 어떤 것을 다루고 있는지 알기 위해 입력 유형의 이름만 보면 됩니다. 이것은 커맨드-쿼리 분리(CQS) 및 커맨드-쿼리 책임 분리(CQRS)와 같은 개념과 잘 어울립니다.
앞의 코드에서, 서비스는 쿼리를 아웃고잉 포트로 전달하는 것 외에는 실제로 아무 작업도 하지 않습니다. 만약 우리가 계층 간에 동일한 모델을 사용한다면, 클라이언트가 아웃고잉 포트를 직접 호출하도록 하는 지름길을 택할 수 있습니다. 11장, 의식적으로 지름길 택하기에서 이 지름길에 대해 이야기할 것입니다.

## 이것이 유지보수 가능한 소프트웨어를 구축하는 데 어떻게 도움이 되는가?
우리 아키텍처는 우리가 적합하다고 생각하는 대로 도메인 로직을 구현하게 해주지만, 유스케이스의 입력과 출력을 독립적으로 모델링하면 원치 않는 부작용을 피할 수 있습니다.
예, 유스케이스 간에 모델을 공유하는 것보다 더 많은 작업이 필요합니다. 각 유스케이스에 대해 별도의 모델을 도입하고 이 모델과 우리 엔티티 간에 매핑해야 합니다.
그러나 유스케이스별 모델은 유스케이스에 대한 명확한 이해를 가능하게 하여 장기적으로 유지보수하기 쉽게 만듭니다. 또한 여러 개발자가 서로 발을 밟지 않고 병렬로 다른 유스케이스에 대해 작업할 수 있게 해줍니다.
엄격한 입력 유효성 검사와 함께, 유스케이스별 입력 및 출력 모델은 유지보수 가능한 코드 베이스를 향한 큰 진전입니다.
다음 장에서는 애플리케이션의 중심에서 "바깥쪽으로" 한 걸음 나아가 사용자가 우리 유스케이스와 대화할 수 있는 채널을 제공하는 웹 어댑터를 구축하는 것을 탐색할 것입니다.

---

# 6. 웹 어댑터 구현하기
오늘날 대부분의 애플리케이션에는 웹 브라우저를 통해 상호 작용할 수 있는 UI 또는 다른 시스템이 애플리케이션과 상호 작용하기 위해 호출할 수 있는 HTTP API와 같은 일종의 웹 인터페이스가 있습니다.
우리의 목표 아키텍처에서 외부 세계와의 모든 통신은 어댑터를 통해 이루어집니다. 따라서 이러한 웹 인터페이스를 제공하는 어댑터를 어떻게 구현할 수 있는지 논의해 봅시다.

## 의존성 역전
그림 6.1은 웹 어댑터에 대한 논의와 관련된 아키텍처 요소, 즉 어댑터 자체와 애플리케이션 코어와 상호 작용하는 포트에 대한 확대된 뷰를 제공합니다.

![[tom_hombergs_33.png]]
*그림 6.1 – 인커밍 어댑터는 도메인 서비스에 의해 구현되는 전용 인커밍 포트를 통해 애플리케이션 계층과 통신한다*

웹 어댑터는 "구동" 또는 "인커밍" 어댑터입니다. 외부로부터 요청을 받아 우리 애플리케이션 코어로의 호출로 변환하여 무엇을 해야 할지 알려줍니다. 제어 흐름은 웹 어댑터의 컨트롤러에서 애플리케이션 계층의 서비스로 이동합니다.
애플리케이션 계층은 웹 어댑터가 통신할 수 있는 특정 포트를 제공합니다. 각 포트는 이전 장에서 "유스케이스"라고 불렀던 것이며, 애플리케이션 계층의 도메인 서비스에 의해 구현됩니다.
자세히 살펴보면, 이것이 의존성 역전 원칙이 실제로 작동하는 것임을 알 수 있습니다. 제어 흐름이 왼쪽에서 오른쪽으로 가기 때문에, 그림 6.2와 같이 웹 어댑터가 유스케이스를 직접 호출하게 할 수도 있습니다.

![[tom_hombergs_34.png]]
*그림 6.2 – 포트 인터페이스를 제거하고 서비스를 직접 호출할 수 있다*

그렇다면 왜 어댑터와 유스케이스 사이에 또 다른 간접 계층을 추가할까요? 그 이유는 포트가 외부 세계가 우리 애플리케이션 코어와 상호 작용할 수 있는 장소의 사양이기 때문입니다. 포트를 마련함으로써, 우리는 외부 세계와의 어떤 통신이 일어나는지 정확히 알 수 있으며, 이는 레거시 코드 베이스에서 작업하는 모든 유지보수 엔지니어에게 귀중한 정보입니다.
애플리케이션을 구동하는 포트를 아는 것은 또한 애플리케이션에 대한 테스트 드라이버를 구축할 수 있게 해줍니다. 이 테스트 드라이버는 특정 사용 시나리오를 시뮬레이션하고 테스트하기 위해 입력 포트를 호출하는 어댑터입니다 – 8장, 아키텍처 요소 테스트하기에서 테스트에 대해 더 자세히 설명합니다.
입력 포트의 중요성에 대해 이야기했지만, 11장, 의식적으로 지름길 택하기에서 이야기할 지름길 중 하나는 인커밍 포트를 그냥 두고 애플리케이션 서비스를 직접 호출하는 것입니다.
하지만 고도로 상호작용적인 애플리케이션과 관련된 한 가지 질문이 남아 있습니다. 서버 애플리케이션이 웹소켓을 통해 사용자의 브라우저로 실시간 데이터를 보낸다고 상상해보십시오. 애플리케이션 코어는 이 실시간 데이터를 웹 어댑터로 어떻게 보내고, 웹 어댑터는 다시 사용자의 브라우저로 어떻게 보낼까요?
이 시나리오에서는 포트가 반드시 필요합니다. 왜냐하면 포트가 없으면 애플리케이션이 어댑터 구현에 의존해야 하므로, 애플리케이션을 외부 의존성으로부터 자유롭게 유지하려는 우리의 노력이 깨지기 때문입니다. 이 포트는 그림 6.3과 같이 웹 어댑터에 의해 구현되고 애플리케이션 코어에 의해 호출되어야 합니다.

![[tom_hombergs_35.png]]
*그림 6.3 – 애플리케이션이 웹 어댑터에 능동적으로 알려야 하는 경우, 의존성을 올바른 방향으로 유지하기 위해 아웃고잉 포트를 통해야 한다*

왼쪽의 `WebSocketController`는 `out` 패키지의 포트 인터페이스를 구현하고, 애플리케이션 코어의 서비스는 이 포트를 호출하여 사용자의 브라우저로 실시간 데이터를 보낼 수 있습니다.
기술적으로 말하면, 이것은 아웃고잉 포트가 될 것이고 웹 어댑터를 인커밍 및 아웃고잉 어댑터로 만들 것입니다. 하지만 동일한 어댑터가 동시에 둘 다일 수 없는 이유는 없습니다. 이 장의 나머지 부분에서는 웹 어댑터가 가장 일반적인 경우인 인커밍 어댑터라고 가정할 것입니다.

## 웹 어댑터의 책임
### 웹 어댑터의 책임
웹 어댑터는 실제로 무엇을 할까? BuckPal 애플리케이션을 위한 REST API를 제공하고 싶다고 가정해 보자. 웹 어댑터의 책임은 어디서 시작하고 어디서 끝날까?
웹 어댑터는 보통 다음 작업들을 수행한다:
1.  들어오는 HTTP 요청을 객체에 매핑한다.
2.  권한 부여 확인을 수행한다.
3.  입력을 검증한다.
4.  요청 객체를 유스케이스의 입력 모델에 매핑한다.
5.  유스케이스를 호출한다.
6.  유스케이스의 출력을 다시 HTTP로 매핑한다.
7.  HTTP 응답을 반환한다.

우선, 웹 어댑터는 URL 경로, HTTP 메서드, 콘텐츠 유형과 같은 특정 기준과 일치하는 HTTP 요청을 수신해야 한다. 일치하는 HTTP 요청의 매개변수와 내용은 우리가 작업할 수 있는 객체로 역직렬화되어야 한다.
일반적으로 웹 어댑터는 인증 및 권한 부여 확인을 수행하고 실패하면 오류를 반환한다.
들어오는 객체의 상태는 그 후에 검증될 수 있다. 하지만 우리는 이미 유스케이스의 입력 모델의 책임으로 입력 유효성 검사를 논의하지 않았는가? 그렇다, 유스케이스의 입력 모델은 유스케이스의 맥락에서 유효한 입력만 허용해야 한다. 하지만 여기서 우리는 웹 어댑터의 입력 모델에 대해 이야기하고 있다. 그것은 유스케이스의 입력 모델과 완전히 다른 구조와 의미를 가질 수 있으므로, 다른 유효성 검사를 수행해야 할 수도 있다.
나는 웹 어댑터에서 유스케이스의 입력 모델에서 이미 수행한 것과 동일한 유효성 검사를 구현하는 것을 옹호하지 않는다. 대신, 웹 어댑터의 입력 모델을 유스케이스의 입력 모델로 변환할 수 있는지 검증해야 한다. 이 변환을 막는 모든 것은 유효성 검사 오류이다.
이것은 우리를 웹 어댑터의 다음 책임으로 이끈다: 변환된 입력 모델로 특정 유스케이스를 호출하는 것이다. 어댑터는 그런 다음 유스케이스의 출력을 가져와 HTTP 응답으로 직렬화하여 호출자에게 다시 보낸다.
만약 도중에 문제가 발생하여 예외가 발생하면, 웹 어댑터는 오류를 호출자에게 다시 보내는 메시지로 변환해야 한다.
그것은 우리 웹 어댑터의 어깨에 많은 책임을 지우는 것이다. 하지만 그것은 또한 애플리케이션 계층이 신경 쓰지 않아야 할 많은 책임이기도 하다. HTTP와 관련된 모든 것은 애플리케이션 계층으로 유출되어서는 안 된다. 만약 애플리케이션 코어가 우리가 외부에서 HTTP를 다루고 있다는 것을 안다면, 우리는 HTTP를 사용하지 않는 다른 인커밍 어댑터에서 동일한 도메인 로직을 수행할 수 있는 옵션을 잃게 된다. 유지보수 가능한 아키텍처에서는 옵션을 열어두고 싶다.
웹 어댑터와 애플리케이션 계층 사이의 이 경계는 웹 계층 대신 도메인 및 애플리케이션 계층으로 개발을 시작하면 자연스럽게 생긴다는 점에 유의하라. 특정 인커밍 어댑터를 생각하지 않고 유스케이스를 먼저 구현하면 경계를 흐리게 하려는 유혹을 받지 않는다.

### 컨트롤러 분할하기
자바 세계의 스프링 MVC와 같은 대부분의 웹 프레임워크에서 우리는 이전에 논의한 책임을 수행하는 컨트롤러 클래스를 만든다. 그렇다면 우리 애플리케이션으로 향하는 모든 요청에 응답하는 단일 컨트롤러를 구축해야 할까? 그럴 필요는 없다. 웹 어댑터는 확실히 하나 이상의 클래스로 구성될 수 있다.
그러나 4장, 코드 구성하기에서 논의했듯이, 이러한 클래스를 동일한 패키지 계층에 넣어 함께 속해 있음을 표시하도록 주의해야 한다.
그렇다면 얼마나 많은 컨트롤러를 만들어야 할까? 나는 너무 적게 만드는 것보다 너무 많이 만드는 것이 낫다고 말하고 싶다. 각 컨트롤러가 가능한 한 좁은 웹 어댑터의 슬라이스를 구현하고 다른 컨트롤러와 가능한 한 적게 공유하도록 해야 한다.
BuckPal 애플리케이션 내의 계정 엔티티에 대한 작업을 예로 들어보자. 인기 있는 접근 방식은 계정과 관련된 모든 작업에 대한 요청을 수락하는 단일 `AccountController`를 만드는 것이다.

REST API를 제공하는 스프링 컨트롤러는 다음 코드 조각과 같을 수 있다:

```java
package buckpal.adapter.in.web;

@RestController
@RequiredArgsConstructor
class AccountController {

    private final GetAccountBalanceUseCase getAccountBalanceUseCase;
    private final ListAccountsQuery listAccountsQuery;
    private final LoadAccountQuery loadAccountQuery;
    
    private final SendMoneyUseCase sendMoneyUseCase;
    private final CreateAccountUseCase createAccountUseCase;

    @GetMapping("/accounts")
    List<AccountResource> listAccounts() {
        ...
    }

    @GetMapping("/accounts/{id}")
    AccountResource getAccount(@PathVariable("id") Long accountId) {
        ...
    }

    @GetMapping("/accounts/{id}/balance")
    Long getAccountBalance(@PathVariable("id") Long accountId) {
        ...
    }

    @PostMapping("/accounts")
    AccountResource createAccount(@RequestBody AccountResource account) {
        ...
    }

    @PostMapping("/accounts/send/{sourceAccountId}/{targetAccountId}/{amount}")
    void sendMoney(
            @PathVariable("sourceAccountId") Long sourceAccountId,
            @PathVariable("targetAccountId") Long targetAccountId,
            @PathVariable("amount") Long amount) {
        ...
    }
}
```

계정 리소스에 관한 모든 것이 단일 클래스에 있어 기분이 좋다. 하지만 이 접근 방식의 단점을 논의해 보자.
첫째, 클래스당 코드가 적을수록 좋다. 나는 가장 큰 클래스가 30,000줄의 코드를 가진 레거시 프로젝트에서 일한 적이 있다.¹ 그것은 재미가 없다. 컨트롤러가 수년에 걸쳐 200줄의 코드만 축적하더라도, 메서드로 깔끔하게 분리되어 있더라도 50줄보다 파악하기가 더 어렵다.
동일한 주장이 테스트 코드에도 유효하다. 컨트롤러 자체에 코드가 많으면 테스트 코드도 많아질 것이다. 그리고 종종 테스트 코드는 더 추상적인 경향이 있기 때문에 프로덕션 코드보다 파악하기가 더 어렵다. 우리는 또한 특정 프로덕션 코드 조각에 대한 테스트를 쉽게 찾을 수 있기를 원하며, 이는 작은 클래스에서 더 쉽다.
그러나 똑같이 중요한 것은 모든 작업을 단일 컨트롤러 클래스에 넣는 것이 데이터 구조의 재사용을 장려한다는 것이다. 앞의 코드 예제에서 많은 작업이 `AccountResource` 모델 클래스를 공유한다. 그것은 모든 작업에 필요한 모든 것을 담는 버킷 역할을 한다. `AccountResource`에는 아마도 `id` 필드가 있을 것이다. 이것은 생성 작업에는 필요하지 않으며 아마도 도움이 되기보다는 혼란을 줄 것이다. `Account`가 `User` 객체와 일대다 관계를 가지고 있다고 상상해보라. 계정을 생성하거나 업데이트할 때 해당 `User` 객체를 포함해야 할까? 사용자가 목록 작업에 의해 반환될까? 이것은 쉬운 예이지만, 실제 크기 이상의 프로젝트에서는 어느 시점에서 이러한 질문을 하게 될 것이다.
그래서 나는 각 작업에 대해 별도의 컨트롤러를, 잠재적으로 별도의 패키지에 만드는 접근 방식을 옹호한다. 또한, 메서드와 클래스의 이름을 가능한 한 유스케이스에 가깝게 지정해야 한다:

```java
package buckpal.adapter.in.web;

@RestController
@RequiredArgsConstructor
public class SendMoneyController {

    private final SendMoneyUseCase sendMoneyUseCase;

    @PostMapping(
        "/accounts/sendMoney/{sourceAccountId}/{targetAccountId}/{amount}"
    )
    void sendMoney(
            @PathVariable("sourceAccountId") Long sourceAccountId,
            @PathVariable("targetAccountId") Long targetAccountId,
            @PathVariable("amount") Long amount) {

        SendMoneyCommand command = new SendMoneyCommand(
            new AccountId(sourceAccountId),
            new AccountId(targetAccountId),
            Money.of(amount));

        sendMoneyUseCase.sendMoney(command);
    }
}
```

> 1 30,000줄의 코드: 실제로 30,000줄이 단일 클래스에 있게 된 것은 의식적인 아키텍처 결정(우리 전임자들의 생각)이었다: 재배포 없이 런타임에 시스템을 변경하기 위해, `.class` 파일에 컴파일된 자바 바이트코드를 업로드할 수 있게 했다. 그리고 단일 파일만 업로드할 수 있었기 때문에 이 파일에는 모든 코드가 포함되어야 했다.

예제에서 `sourceAccountId`, `targetAccountId`, `amount`와 같이 원시 타입을 입력으로 받을 수 있다. 하지만 각 컨트롤러는 자체 입력 모델을 가질 수도 있다. `AccountResource`와 같은 일반적인 모델 대신, `CreateAccountResource` 또는 `UpdateAccountResource`와 같은 유스케이스에 특정한 모델을 가질 수 있다. 이러한 특화된 모델 클래스는 우발적인 재사용을 방지하기 위해 컨트롤러의 패키지에 비공개일 수도 있다. 컨트롤러는 여전히 모델을 공유할 수 있지만, 다른 패키지의 공유 클래스를 사용하면 더 많이 생각하게 되고 아마도 필드의 절반이 필요 없다는 것을 알게 되어 결국 우리 자신의 것을 만들게 될 것이다.
또한, 컨트롤러와 서비스의 이름에 대해 신중하게 생각해야 한다. 예를 들어, `CreateAccount` 대신 `RegisterAccount`가 더 나은 이름이 아닐까? BuckPal 애플리케이션에서 계정을 만드는 유일한 방법은 사용자가 등록하는 것이다. 그래서 우리는 클래스 이름에 "register"라는 단어를 사용하여 그 의미를 더 잘 전달한다. 물론 `Create...`, `Update...`, `Delete...`와 같은 일반적인 용의자들이 유스케이스를 충분히 설명하는 경우도 있지만, 실제로 사용하기 전에 두 번 생각하고 싶을 것이다.
이러한 분할 스타일의 또 다른 이점은 다른 작업에 대한 병렬 작업을 쉽게 만든다는 것이다. 두 명의 개발자가 다른 작업에 대해 작업하더라도 병합 충돌이 발생하지 않을 것이다.

### 이것이 유지보수 가능한 소프트웨어를 구축하는 데 어떻게 도움이 되는가?
애플리케이션에 대한 웹 어댑터를 구축할 때, 우리는 HTTP 프로토콜을 애플리케이션의 유스케이스에 대한 메서드 호출로 변환하고, 결과를 다시 HTTP로 변환하며, 어떤 도메인 로직도 수행하지 않는 어댑터를 구축하고 있다는 점을 명심해야 한다.
반면에 애플리케이션 계층은 HTTP를 수행해서는 안 되므로, HTTP 세부 정보가 유출되지 않도록 해야 한다. 이렇게 하면 필요할 경우 웹 어댑터를 다른 어댑터로 교체할 수 있다.
웹 컨트롤러를 분할할 때, 모델을 공유하지 않는 많은 작은 클래스를 만드는 것을 두려워해서는 안 된다. 그것들은 파악하고 테스트하기가 더 쉽고, 병렬 작업을 지원한다. 처음에는 이렇게 세분화된 컨트롤러를 설정하는 데 더 많은 작업이 필요하지만, 유지보수 중에 보상을 받을 것이다.
애플리케이션의 인커밍 측면을 살펴봤으니, 이제 아웃고잉 측면과 영속성 어댑터를 구현하는 방법을 살펴보겠다.

---

# 7. 영속성 어댑터 구현하기
2장, 계층형 아키텍처의 문제점은 무엇인가?에서 나는 전통적인 계층형 아키텍처에 대해 불평했고, 궁극적으로 모든 것이 영속성 계층에 의존하기 때문에 데이터베이스 주도 설계를 조장한다고 주장했다. 이 장에서는 영속성 계층을 애플리케이션 계층의 플러그인으로 만들어 이 의존성을 역전시키는 방법을 살펴볼 것이다.

## 의존성 역전
영속성 계층 대신, 도메인 서비스에 영속성 기능을 제공하는 영속성 어댑터에 대해 이야기할 것이다. 그림 7.1은 의존성 역전 원칙을 적용하여 바로 그 작업을 수행하는 방법을 보여준다:

![[tom_hombergs_38.png]]
*그림 7.1 – 코어의 서비스는 포트를 사용하여 영속성 어댑터에 접근한다*

우리 도메인 서비스는 영속성 기능에 접근하기 위해 포트 인터페이스를 호출한다. 이러한 포트는 실제 영속성 작업을 수행하고 데이터베이스와 통신하는 역할을 하는 영속성 어댑터 클래스에 의해 구현된다.

헥사고날 아키텍처 용어로, 영속성 어댑터는 우리 애플리케이션에 의해 호출되기 때문에 "피동(driven)" 또는 "아웃고잉(outgoing)" 어댑터이다.
포트는 사실상 도메인 서비스와 영속성 코드 사이의 간접 계층이다.
우리가 이 간접 계층을 추가하는 이유는 영속성 문제에 대해 생각할 필요 없이, 즉 영속성 계층에 대한 코드 의존성 없이 도메인 코드를 발전시킬 수 있기 위함이라는 것을 상기하자. 영속성 코드의 리팩토링은 코어의 코드 변경으로 이어지지 않을 것이다.
물론, 런타임에는 여전히 애플리케이션 코어에서 영속성 어댑터로의 의존성이 있다.
예를 들어, 영속성 계층의 코드를 수정하고 버그를 도입하면 애플리케이션 코어의 기능이 깨질 수 있다. 그러나 포트의 계약이 이행되는 한, 우리는 코어에 영향을 주지 않고 영속성 어댑터에서 원하는 작업을 자유롭게 수행할 수 있다.

### 영속성 어댑터의 책임
영속성 어댑터가 일반적으로 수행하는 작업을 살펴보자:
1.  입력을 받는다.
2.  입력을 데이터베이스 형식으로 매핑한다.
3.  입력을 데이터베이스로 보낸다.
4.  데이터베이스 출력을 애플리케이션 형식으로 매핑한다.
5.  출력을 반환한다.

영속성 어댑터는 포트 인터페이스를 통해 입력을 받는다. 입력 모델은 인터페이스에 의해 지정된 대로 도메인 엔티티 또는 특정 데이터베이스 작업을 위한 전용 객체일 수 있다.
그런 다음 입력 모델을 데이터베이스를 수정하거나 쿼리하는 데 사용할 수 있는 형식으로 매핑한다. 자바 프로젝트에서는 일반적으로 데이터베이스와 통신하기 위해 자바 영속성 API(JPA)를 사용하므로, 입력을 데이터베이스 테이블의 구조를 반영하는 JPA 엔티티 객체로 매핑할 수 있다. 컨텍스트에 따라 입력 모델을 JPA 엔티티로 매핑하는 것은 적은 이득을 위해 많은 작업이 될 수 있으므로, 9장, 경계 간 매핑에서 매핑 없는 전략에 대해 이야기할 것이다.
JPA나 다른 객체-관계 매핑 프레임워크를 사용하는 대신, 데이터베이스와 통신하기 위해 다른 기술을 사용할 수도 있다. 입력 모델을 일반 SQL 문으로 매핑하고 이러한 문을 데이터베이스로 보내거나, 들어오는 데이터를 파일로 직렬화하고 거기서 다시 읽을 수도 있다.
중요한 부분은 영속성 어댑터에 대한 입력 모델이 영속성 어댑터 자체가 아니라 애플리케이션 코어 내에 있다는 것이다. 그래야 영속성 어댑터의 변경이 코어에 영향을 미치지 않는다.
다음으로, 영속성 어댑터는 데이터베이스를 쿼리하고 쿼리 결과를 받는다.
마지막으로, 데이터베이스 응답을 포트에서 예상하는 출력 모델로 매핑하고 반환한다. 다시 말하지만, 의존성이 올바른 방향을 가리키도록 출력 모델이 영속성 어댑터가 아닌 애플리케이션 코어 내에 있는 것이 중요하다.
입력 및 출력 모델이 영속성 어댑터 자체가 아닌 애플리케이션 코어에 있다는 사실을 제외하고, 책임은 전통적인 영속성 계층의 책임과 실제로 다르지 않다.
그러나 여기에 설명된 대로 영속성 어댑터를 구현하면 전통적인 영속성 계층을 구현할 때 우리가 너무 익숙해서 생각하지 않는 몇 가지 질문이 필연적으로 제기될 것이다.

### 포트 인터페이스 분할하기
서비스를 구현할 때 떠오르는 한 가지 질문은 애플리케이션 코어에서 사용할 수 있는 데이터베이스 작업을 정의하는 포트 인터페이스를 어떻게 분할할 것인가이다.
그림 7.2에 설명된 것처럼 특정 엔티티에 대한 모든 데이터베이스 작업을 제공하는 단일 리포지토리 인터페이스를 만드는 것이 일반적인 관행이다.

![[tom_hombergs_39.png]]
*그림 7.2 – 모든 데이터베이스 작업을 단일 아웃고잉 포트 인터페이스에 중앙 집중화하면 모든 서비스가 필요하지 않은 메서드에 의존하게 된다*

데이터베이스 작업에 의존하는 각 서비스는 인터페이스에서 단일 메서드만 사용하더라도 이 단일 "광범위한" 포트 인터페이스에 대한 의존성을 갖게 된다. 이는 코드 베이스에 불필요한 의존성이 있음을 의미한다.
우리 컨텍스트에서 필요하지 않은 메서드에 대한 의존성은 코드를 이해하고 테스트하기 어렵게 만든다. 앞의 그림에서 `RegisterAccountService`에 대한 단위 테스트를 작성한다고 상상해보라. `AccountRepository` 인터페이스의 어떤 메서드에 대해 모의(mock)를 만들어야 할까? 먼저 서비스가 실제로 호출하는 `AccountRepository` 메서드를 찾아야 한다.
인터페이스의 일부만 모의 처리하면 다른 문제가 발생할 수 있다. 해당 테스트에서 작업하는 다음 사람이 인터페이스가 완전히 모의 처리될 것으로 예상하고 오류에 부딪힐 수 있기 때문이다. 그래서 그들은 다시 조사를 해야 한다.
로버트 C. 마틴의 말을 빌리자면, "필요하지 않은 짐을 싣고 있는 것에 의존하면 예상치 못한 문제를 일으킬 수 있다."¹
인터페이스 분리 원칙은 이 문제에 대한 답을 제공한다. 이 원칙은 클라이언트가 필요한 메서드만 알 수 있도록 광범위한 인터페이스를 특정 인터페이스로 분할해야 한다고 명시한다. 이를 아웃고잉 포트에 적용하면 그림 7.3과 같은 결과를 얻을 수 있다.

![[tom_hombergs_40.png]]
*그림 7.3 – 인터페이스 분리 원칙을 적용하면 불필요한 의존성을 제거하고 기존 의존성을 더 잘 보이게 만든다*

이제 각 서비스는 실제로 필요한 메서드에만 의존한다. 더욱이, 포트의 이름은 그것들이 무엇에 관한 것인지 명확하게 명시한다. 테스트에서 더 이상 어떤 메서드를 모의 처리해야 할지 생각할 필요가 없다. 대부분의 경우 포트당 하나의 메서드만 있기 때문이다.
이와 같은 매우 좁은 포트를 사용하면 코딩이 플러그 앤 플레이 경험이 된다. 서비스에서 작업할 때 필요한 포트를 "연결"하기만 하면 된다. 가지고 다닐 짐이 없다.
물론, "포트당 하나의 메서드" 접근 방식이 모든 상황에 적용 가능한 것은 아닐 수 있다. 매우 응집력이 있고 자주 함께 사용되는 데이터베이스 작업 그룹이 있어 단일 인터페이스에 함께 묶고 싶을 수도 있다.

### 영속성 어댑터 분할하기
앞의 그림에서 우리는 모든 영속성 포트를 구현하는 단일 영속성 어댑터 클래스를 보았다. 그러나 모든 영속성 포트가 구현되는 한, 하나 이상의 영속성 어댑터를 만드는 것을 금지하는 규칙은 없다.

> 1. 인터페이스 분리 원칙: 로버트 C. 마틴의 『클린 아키텍처』, 86페이지.

예를 들어, 그림 7.4와 같이 영속성 작업이 필요한 도메인 엔티티 그룹(또는 도메인 주도 설계 용어로 애그리게잇)당 하나의 영속성 어댑터를 구현하도록 선택할 수 있다.

![[tom_hombergs_41.png]]
*그림 7.4 – 각 애그리게잇에 대해 하나씩 여러 영속성 어댑터를 만들 수 있다*

이런 식으로, 우리 영속성 어댑터는 우리가 영속성 기능으로 지원하는 도메인의 경계를 따라 자동으로 분할된다.
우리는 영속성 어댑터를 더 많은 클래스로 분할할 수도 있다. 예를 들어, JPA(또는 다른 객체-관계 매퍼)를 사용하여 몇 개의 영속성 포트를 구현하고 더 나은 성능을 위해 일반 SQL을 사용하여 다른 일부 포트를 구현하고 싶을 때이다. 그러면 우리는 하나의 JPA 어댑터와 하나의 일반 SQL 어댑터를 만들 수 있으며, 각각 영속성 포트의 하위 집합을 구현한다.
우리 도메인 코드는 어떤 클래스가 궁극적으로 영속성 포트에 의해 정의된 계약을 이행하는지에 대해 신경 쓰지 않는다는 것을 기억하라. 모든 포트가 구현되는 한, 우리는 영속성 계층에서 적절하다고 생각하는 대로 자유롭게 할 수 있다.
애그리게잇당 하나의 영속성 어댑터 접근 방식은 또한 미래에 여러 바운디드 컨텍스트에 대한 영속성 요구를 분리하기 위한 좋은 기반이 된다. 시간이 지나서 청구 관련 유스케이스를 담당하는 바운디드 컨텍스트를 식별했다고 가정해 보자. 그림 7.5는 해당 새로운 도메인을 애플리케이션에 추가한다.

![[tom_hombergs_42.png]]
*그림 7.5 – 바운디드 컨텍스트 간에 엄격한 경계를 만들고 싶다면, 각 바운디드 컨텍스트는 자체 영속성 어댑터를 가져야 한다*

각 바운디드 컨텍스트는 자체 영속성 어댑터(또는 잠재적으로 하나 이상)를 가진다. "바운디드 컨텍스트"라는 용어는 경계를 의미하며, 이는 계정 컨텍스트의 서비스가 청구 컨텍스트의 영속성 어댑터에 접근할 수 없으며 그 반대도 마찬가지라는 것을 의미한다. 한 컨텍스트가 다른 컨텍스트의 무언가를 필요로 하는 경우, 서로의 도메인 서비스를 호출하거나, 바운디드 컨텍스트 간의 조정자로서 애플리케이션 서비스를 도입할 수 있다. 이 주제에 대해서는 13장, 여러 바운디드 컨텍스트 관리하기에서 더 자세히 다룰 것이다.

### 스프링 데이터 JPA 예제
앞의 그림에서 `AccountPersistenceAdapter`를 구현하는 코드 예제를 살펴보자. 이 어댑터는 데이터베이스에 계정을 저장하고 로드해야 한다. 우리는 이미 5장, 유스케이스 구현하기에서 `Account` 엔티티를 보았지만, 참조를 위해 여기에 다시 그 골격을 제시한다:

```java
package buckpal.application.domain.model;

public class Account {

    private AccountId id;
    private Money baselineBalance;
    private ActivityWindow activityWindow;

    // constructors and getters omitted

    public static Account withoutId(
            Money baselineBalance,
            ActivityWindow activityWindow) {
        return new Account(null, baselineBalance, activityWindow);
    }

    public static Account withId(
            AccountId accountId,
            Money baselineBalance,
            ActivityWindow activityWindow) {
        return new Account(accountId, baselineBalance, activityWindow);
    }

    public Money calculateBalance() {
        // ...
    }

    public boolean withdraw(Money money, AccountId targetAccountId) {
        // ...
    }

    public boolean deposit(Money money, AccountId sourceAccountId) {
        // ...
    }
}
```

> **참고**
> `Account` 클래스는 게터와 세터가 있는 단순한 데이터 클래스가 아니라 가능한 한 불변성을 유지하려고 노력한다. 유효한 상태의 계정을 생성하는 팩토리 메서드만 제공하며, 모든 변경 메서드는 돈을 인출하기 전에 계좌 잔액을 확인하는 것과 같은 일부 유효성 검사를 수행하므로 유효하지 않은 도메인 모델을 만들 수 없다.

데이터베이스와 통신하기 위해 스프링 데이터 JPA를 사용할 것이므로, 계정의 데이터베이스 상태를 나타내는 `@Entity` 어노테이션이 달린 클래스도 필요하다:

```java
package buckpal.adapter.out.persistence;

@Entity
@Table(name = "account")
@Data
@AllArgsConstructor
@NoArgsConstructor
class AccountJpaEntity {

    @Id
    @GeneratedValue
    private Long id;

}
```

```java
package buckpal.adapter.out.persistence;

@Entity
@Table(name = "activity")
@Data
@AllArgsConstructor
@NoArgsConstructor
class ActivityJpaEntity {

    @Id
    @GeneratedValue
    private Long id;

    @Column private LocalDateTime timestamp;
    @Column private Long ownerAccountId;
    @Column private Long sourceAccountId;
    @Column private Long targetAccountId;
    @Column private Long amount;

}
```

계정의 상태는 이 단계에서는 ID만으로 구성된다. 나중에 사용자 ID와 같은 추가 필드가 추가될 수 있다. 더 흥미로운 것은 특정 계정의 모든 활동을 포함하는 `ActivityJpaEntity`이다. JPA의 `@ManyToOne` 또는 `@OneToMany` 어노테이션을 통해 `ActivitiyJpaEntity`와 `AccountJpaEntity`를 연결하여 그들 사이의 관계를 표시할 수 있었지만, 데이터베이스 쿼리에 부작용을 추가하기 때문에 지금은 이것을 생략하기로 결정했다. 사실, 이 단계에서는 영속성 어댑터를 구현하기 위해 JPA보다 더 간단한 객체-관계 매퍼를 사용하는 것이 아마도 더 쉬울 것이지만, 미래에 필요할 것이라고 생각하기 때문에 어쨌든 사용할 것이다.²
다음으로, 스프링 데이터를 사용하여 기본적으로 생성, 읽기, 업데이트 및 삭제(CRUD) 기능을 제공하는 리포지토리 인터페이스와 데이터베이스에서 특정 활동을 로드하기 위한 사용자 지정 쿼리를 만들 것이다:

```java
interface AccountRepository extends JpaRepository<AccountJpaEntity, Long> {
}
```

```java
interface ActivityRepository extends JpaRepository<ActivityJpaEntity, Long> {

    @Query("""
        select a from ActivityJpaEntity a
        where a.ownerAccountId = :ownerAccountId
        and a.timestamp >= :since
        """)
    List<ActivityJpaEntity> findByOwnerSince(
            @Param("ownerAccountId") Long ownerAccountId,
            @Param("since") LocalDateTime since);

    @Query("""
        select sum(a.amount) from ActivityJpaEntity a
        where a.targetAccountId = :accountId
        and a.ownerAccountId = :accountId
        and a.timestamp < :until
        """)
    Optional<Long> getDepositBalanceUntil(
            @Param("accountId") Long accountId,
            @Param("until") LocalDateTime until);

    @Query("""
        select sum(a.amount) from ActivityJpaEntity a
        where a.sourceAccountId = :accountId
        and a.ownerAccountId = :accountId
        and a.timestamp < :until
        """)
    Optional<Long> getWithdrawalBalanceUntil(
            @Param("accountId") Long accountId,
            @Param("until") LocalDateTime until);
}
```

> 2. 자바 영속성 API: 익숙하게 들리는가? 이 문제에 사람들이 사용하는 것이기 때문에 OR 매퍼로 JPA를 선택한다. 개발에 몇 달이 지나면, 즉시 로딩과 지연 로딩, 그리고 캐싱 기능에 저주를 퍼부으며 더 간단한 것을 원하게 된다. JPA는 훌륭한 도구이지만, 많은 문제에 대해 더 간단한 해결책이, 글쎄, 더 간단할 수 있다. 대안으로 스프링 데이터 JDBC나 jOOQ를 살펴보라.

스프링 부트는 이러한 리포지토리를 자동으로 찾고, 스프링 데이터는 실제로 데이터베이스와 통신할 리포지토리 인터페이스 뒤에 구현을 제공하기 위해 마법을 부릴 것이다.
JPA 엔티티와 리포지토리가 준비되었으므로, 애플리케이션에 영속성 기능을 제공하는 영속성 어댑터를 구현할 수 있다:

```java
@RequiredArgsConstructor
@Component
class AccountPersistenceAdapter implements
        LoadAccountPort,
        UpdateAccountStatePort {

    private final AccountRepository accountRepository;
    private final ActivityRepository activityRepository;
    private final AccountMapper accountMapper;

    @Override
    public Account loadAccount(
            AccountId accountId,
            LocalDateTime baselineDate) {

        AccountJpaEntity account =
                accountRepository.findById(accountId.getValue())
                        .orElseThrow(EntityNotFoundException::new);

        List<ActivityJpaEntity> activities =
                activityRepository.findByOwnerSince(
                        accountId.getValue(),
                        baselineDate);

        Long withdrawalBalance = activityRepository
                .getWithdrawalBalanceUntil(
                        accountId.getValue(),
                        baselineDate)
                .orElse(0L);

        Long depositBalance = activityRepository
                .getDepositBalanceUntil(
                        accountId.getValue(),
                        baselineDate)
                .orElse(0L);
				
        return accountMapper.mapToDomainEntity(
                account,
                activities,
                withdrawalBalance,
                depositBalance);
    }

    @Override
    public void updateActivities(Account account) {
        for (Activity activity : account.getActivityWindow().getActivities()) {
            if (activity.getId() == null) {
                activityRepository.save(accountMapper.mapToJpaEntity(activity));
            }
        }
    }

    private Long orZero(Long value) {
        return value == null ? 0L : value;
    }
}
```

영속성 어댑터는 애플리케이션에 필요한 두 개의 포트, `LoadAccountPort`와 `UpdateAccountStatePort`를 구현한다.
데이터베이스에서 계정을 로드하기 위해, `AccountRepository`에서 로드한 다음 `ActivityRepository`를 통해 특정 시간 창에 대한 이 계정의 활동을 로드한다.
유효한 `Account` 도메인 엔티티를 생성하려면, 이 활동 창이 시작되기 전의 계정 잔액도 필요하므로, 데이터베이스에서 이 계정의 모든 인출 및 입금 합계를 가져온다.
마지막으로, 이 모든 데이터를 `Account` 도메인 엔티티에 매핑하고 호출자에게 반환한다.
계정의 상태를 업데이트하기 위해, `Account` 엔티티의 모든 활동을 반복하고 ID가 있는지 확인한다. ID가 없으면 새로운 활동이므로 `ActivityRepository`를 통해 영속화한다.
앞서 설명한 시나리오에서, 우리는 `Account` 및 `Activity` 도메인 모델과 `AccountJpaEntity` 및 `ActivityJpaEntity` 데이터베이스 모델 간에 양방향 매핑을 가지고 있다. 왜 우리는 앞뒤로 매핑하는 수고를 할까? `Account` 및 `Activity` 클래스에 JPA 어노테이션을 옮기고 데이터베이스에 엔티티로 직접 저장할 수는 없을까?
9장, 경계 간 매핑에서 매핑 전략에 대해 이야기할 때 보게 될 것처럼, 이러한 매핑 없음 전략은 유효한 선택일 수 있다. 그러나 JPA는 도메인 모델에서 타협을 강요한다. 예를 들어, JPA는 엔티티에 인수가 없는 생성자가 있어야 한다고 요구한다. 또는, 영속성 계층에서는 성능 관점에서 "다대일" 관계가 의미가 있지만, 도메인 모델에서는 이 관계가 반대이기를 원할 수 있다.
따라서 영속성 계층에 타협하지 않고 풍부한 도메인 모델을 만들고 싶다면, 도메인 모델과 영속성 모델 간에 매핑해야 한다.

### 데이터베이스 트랜잭션은 어떤가?
우리는 아직 데이터베이스 트랜잭션 주제를 다루지 않았다. 트랜잭션 경계는 어디에 둘까?
트랜잭션은 특정 유스케이스 내에서 수행되는 데이터베이스에 대한 모든 쓰기 작업을 포함해야 하며, 그 중 하나가 실패할 경우 모든 작업이 함께 롤백될 수 있도록 보장해야 한다.
영속성 어댑터는 동일한 유스케이스의 일부인 다른 데이터베이스 작업을 알지 못하므로, 트랜잭션을 열고 닫을 시기를 결정할 수 없다. 우리는 이 책임을 영속성 어댑터에 대한 호출을 조정하는 서비스에 위임해야 한다.
자바와 스프링으로 이를 수행하는 가장 쉬운 방법은 도메인 서비스 클래스에 `@Transactional` 어노테이션을 추가하여 스프링이 모든 공개 메서드를 트랜잭션으로 래핑하도록 하는 것이다:

```java
package buckpal.application.domain.service;

@Transactional
public class SendMoneyService implements SendMoneyUseCase {
    ...
}
```

하지만 `@Transactional` 어노테이션이 우리가 소중한 도메인 코드에 갖고 싶지 않은 프레임워크에 대한 의존성을 도입하지 않는가? 글쎄, 그렇다, 우리는 어노테이션에 대한 의존성을 가지고 있지만, 그 의존성에 대해 트랜잭션 처리를 얻는다! 코드를 "순수하게" 유지하기 위해 우리 자신의 트랜잭션 메커니즘을 구축하고 싶지는 않을 것이다.

### 이것이 유지보수 가능한 소프트웨어를 구축하는 데 어떻게 도움이 되는가?
도메인 코드의 플러그인 역할을 하는 영속성 어댑터를 구축하면 도메인 코드가 영속성 세부 정보에서 해방되어 풍부한 도메인 모델을 구축할 수 있다.

이것이 유지보수 가능한 소프트웨어를 구축하는 데 어떻게 도움이 되는가?

좁은 포트 인터페이스를 사용하면, 한 포트는 한 가지 방식으로, 다른 포트는 다른 방식으로, 아마도 다른 영속성 기술로 구현할 수 있는 유연성을 갖게 되며, 애플리케이션은 이를 알아차리지 못한다.
포트 계약이 준수되는 한, 전체 영속성 계층을 교체할 수도 있다.³
이제 도메인 모델과 일부 어댑터를 구축했으니, 그것들이 실제로 우리가 기대하는 대로 작동하는지 테스트하는 방법을 살펴보자.

> 3. 영속성 계층 교체: 몇 번 본 적이 있지만(그리고 좋은 이유로), 전체 영속성 계층을 교체해야 할 확률은 보통 다소 낮다. 그렇다 하더라도, 전용 영속성 포트를 갖는 것은 테스트 용이성을 높이기 때문에 여전히 가치가 있다. 예를 들어, 테스트에 사용할 인메모리 영속성 어댑터를 쉽게 구현할 수 있다.

---

# 8. 아키텍처 요소 테스트하기
내가 목격한 많은 프로젝트, 특히 오랫동안 존재해 왔고 시간이 지남에 따라 많은 개발자가 교체된 프로젝트에서 자동화된 테스트는 미스터리이다. 모든 사람이 위키에 문서화된 어떤 낡은 규칙에 의해 요구되기 때문에 적합하다고 생각하는 대로 테스트를 작성하지만, 팀의 테스트 전략에 대한 구체적인 질문에 답할 수 있는 사람은 아무도 없다.
이 장에서는 헥사고날 아키텍처에 대한 테스트 전략을 제공한다. 아키텍처의 각 요소에 대해, 그것을 다루는 테스트 유형을 논의할 것이다.

## 테스트 피라미드
그림 8.1의 테스트 피라미드¹의 라인을 따라 테스트에 대한 논의를 시작하자. 이것은 우리가 어떤 유형의 테스트를 얼마나 많이 목표로 해야 하는지 결정하는 데 도움이 되는 은유이다.

![[tom_hombergs_51.png]]
*그림 8.1 – 테스트 피라미드에 따르면, 저렴한 테스트는 많이 만들고 비싼 테스트는 적게 만들어야 한다*

> 1 테스트 피라미드는 2009년 마이크 콘의 저서 『Succeeding with Agile』에서 유래했다.

피라미드의 기본 진술은 우리가 구축하기 저렴하고, 유지하기 쉽고, 빠르게 실행되며, 안정적인 세분화된 테스트에 대한 높은 커버리지를 가져야 한다는 것이다. 이것들은 단일 단위(보통 클래스)가 예상대로 작동하는지 확인하는 단위 테스트이다.
테스트가 여러 단위를 결합하고 단위 경계, 아키텍처 경계 또는 시스템 경계를 넘어가면, 구축하는 데 더 비싸고, 실행하는 데 더 느리고, 더 취약해지는 경향이 있다(기능적 오류 대신 일부 구성 오류로 인해 실패). 피라미드는 이러한 테스트가 비싸질수록 높은 커버리지를 목표로 해서는 안 된다고 말한다. 그렇지 않으면 새로운 기능을 구축하는 대신 테스트를 구축하는 데 너무 많은 시간을 소비하게 될 것이다.
컨텍스트에 따라 테스트 피라미드는 종종 다른 계층으로 표시된다. 헥사고날 아키텍처 테스트를 논의하기 위해 내가 선택한 계층을 살펴보자.

> **참고**
> 단위 테스트, 통합 테스트 및 시스템 테스트의 정의는 컨텍스트에 따라 다르다. 한 프로젝트에서는 다른 프로젝트와 다른 의미를 가질 수 있다.

다음은 이 장에서 사용할 다양한 테스트 유형에 대한 해석이다:
- 단위 테스트는 피라미드의 기반이다. 단위 테스트는 보통 단일 클래스를 인스턴스화하고 인터페이스를 통해 기능을 테스트한다. 테스트 대상 클래스가 다른 클래스에 대한 사소하지 않은 의존성을 갖는 경우, 테스트에서 요구하는 대로 실제 객체의 동작을 시뮬레이션하는 모의 객체로 해당 의존성을 대체할 수 있다.
- 통합 테스트는 피라미드의 다음 계층을 형성한다. 이러한 테스트는 여러 단위의 네트워크를 인스턴스화하고 진입 클래스의 인터페이스를 통해 일부 데이터를 전송하여 이 네트워크가 예상대로 작동하는지 확인한다. 우리의 해석에서, 통합 테스트는 두 계층 사이의 경계를 넘을 것이므로, 객체 네트워크가 완전하지 않거나 어느 시점에서 모의에 대해 작동해야 한다.
- 시스템 테스트는 마지막으로, 우리 애플리케이션을 구성하는 전체 객체 네트워크를 가동하고 특정 유스케이스가 애플리케이션의 모든 계층을 통해 예상대로 작동하는지 확인한다.

시스템 테스트 위에는 애플리케이션의 UI를 포함하는 엔드투엔드 테스트 계층이 있을 수 있다.
이 책에서는 백엔드 아키텍처만 논의하므로 엔드투엔드 테스트는 고려하지 않을 것이다.

> **참고**
> 테스트 피라미드는 다른 지침과 마찬가지로 테스트 전략에 대한 만병통치약이 아니다. 좋은 기본값이지만, 컨텍스트에서 통합 또는 시스템 테스트를 저렴하게 생성하고 유지할 수 있다면, 단위 테스트보다 구현 세부 정보 변경에 덜 취약하므로 이러한 테스트를 더 많이 생성할 수 있고 생성해야 한다. 이렇게 하면 피라미드의 측면이 더 가파르게 되거나 심지어 역전될 수도 있다.

이제 몇 가지 테스트 유형을 정의했으니, 헥사고날 아키텍처의 각 계층에 어떤 유형의 테스트가 가장 적합한지 살펴보자.

### 단위 테스트로 도메인 엔티티 테스트하기
아키텍처의 중심에 있는 도메인 엔티티를 살펴보는 것으로 시작하겠다. 5장, 유스케이스 구현하기의 `Account` 엔티티를 상기해보자. `Account`의 상태는 과거 특정 시점의 계정 잔액(기준 잔액)과 그 이후에 이루어진 입출금(활동) 목록으로 구성된다.
이제 `withdraw()` 메서드가 예상대로 작동하는지 확인하고 싶다:

```java
class AccountTest {

    @Test
    void withdrawalSucceeds() {
        AccountId accountId = new AccountId(1L);
        Account account = defaultAccount()
                .withAccountId(accountId)
                .withBaselineBalance(Money.of(555L))
                .withActivityWindow(new ActivityWindow(
	                defaultActivity()
		                .withTargetAccount(accountId)
		                .withMoney(Money.of(999L)).build(),
					defaultActivity()
						.withTargetAccount(accountId)
						.withMoney(Money.of(1L)).build()))
                .build();

        AccountId randomTargetAccount = new AccountId(99L);
        boolean success = account.withdraw(Money.of(555L), randomTargetAccount);

        assertThat(success).isTrue();
        assertThat(account
                .getActivityWindow()
                .getActivities())
                .hasSize(3);
        assertThat(account.calculateBalance())
                .isEqualTo(Money.of(1000L));
    }
}
```

앞의 테스트는 특정 상태의 `Account`를 인스턴스화하고, `withdraw()` 메서드를 호출하고, 인출이 성공적이었고 `Account` 객체의 상태에 예상된 부작용이 있었는지 확인하는 일반적인 단위 테스트이다.
테스트는 설정하기가 매우 쉽고, 이해하기 쉬우며, 매우 빠르게 실행된다. 이보다 더 간단한 테스트는 거의 없다. 이와 같은 단위 테스트는 도메인 엔티티 내에 인코딩된 비즈니스 규칙을 확인하는 최선의 방법이다. 도메인 엔티티 동작은 다른 클래스에 대한 의존성이 거의 또는 전혀 없기 때문에 다른 유형의 테스트는 필요하지 않다.

### 단위 테스트로 유스케이스 테스트하기
한 계층 바깥으로 나가면, 테스트할 다음 아키텍처 요소는 도메인 서비스로 구현된 유스케이스이다. 5장, 유스케이스 구현하기에서 논의된 `SendMoneyService`에 대한 테스트를 살펴보자. 송금 유스케이스는 출금 계좌에서 돈을 인출하고 대상 계좌에 입금한다. 트랜잭션이 성공했을 때 모든 것이 예상대로 작동하는지 확인하고 싶다:

```java
class SendMoneyServiceTest {

    // declaration of fields omitted

    @Test
    void transactionSucceeds() {

        // given
        Account sourceAccount = givenSourceAccount();
        Account targetAccount = givenTargetAccount();

        givenWithdrawalWillSucceed(sourceAccount);
        givenDepositWillSucceed(targetAccount);

        Money money = Money.of(500L);

        SendMoneyCommand command = new SendMoneyCommand(
                sourceAccount.getId(),
                targetAccount.getId(),
                money);

        // when
        boolean success = sendMoneyService.sendMoney(command);

        // then
        assertThat(success).isTrue();

        AccountId sourceAccountId = sourceAccount.getId();
        AccountId targetAccountId = targetAccount.getId();

        then(sourceAccount).should().withdraw(eq(money), eq(targetAccountId));
        then(targetAccount).should().deposit(eq(money), eq(sourceAccountId));
        thenAccountsHaveBeenUpdated(sourceAccountId, targetAccountId);
    }

    // helper methods omitted
}
```

테스트를 좀 더 읽기 쉽게 만들기 위해, 일반적으로 행동 주도 개발(Behavior-Driven Development)에서 사용되는 given/when/then 섹션으로 구성되어 있다.
given 섹션에서는 출금 및 입금 `Account` 객체를 생성하고 `given...()`으로 시작하는 이름의 일부 메서드로 올바른 상태로 만든다. 또한 유스케이스에 대한 입력 역할을 할 `SendMoneyCommand` 객체를 생성한다. when 섹션에서는 단순히 `sendMoney()` 메서드를 호출하여 유스케이스를 호출한다. then 섹션에서는 트랜잭션이 성공했음을 단언하고 출금 및 입금 `Account` 객체에서 특정 메서드가 호출되었는지 확인한다.
내부적으로, 테스트는 `given...()` 메서드에서 모의 객체를 생성하기 위해 Mockito 라이브러리를 사용한다.² Mockito는 또한 `then()` 메서드를 제공하여 모의 객체에서 특정 메서드가 호출되었는지 확인한다.

> **참고**
> 너무 많이 사용하면, 모의는 잘못된 안전감을 줄 수 있다. 모의는 실제와 다르게 동작할 수 있으며, 테스트가 녹색이더라도 프로덕션에서 문제를 일으킬 수 있다. 추가 노력 없이 실제 객체를 사용할 수 있다면 아마도 그렇게 해야 할 것이다. 앞의 예에서, 예를 들어 모의 대신 실제 `Account` 객체로 작업하도록 선택할 수 있다. `Account` 클래스는 다른 클래스에 복잡한 의존성이 없는 도메인 모델 클래스이기 때문에 이것은 훨씬 더 많은 노력을 증명해서는 안 된다.

테스트 대상 유스케이스 서비스는 상태 비저장이므로 then 섹션에서 특정 상태를 확인할 수 없다.
대신, 테스트는 서비스가 (모의 처리된) 의존성에서 특정 메서드와 상호 작용했는지 확인한다. 이는 테스트가 테스트 대상 코드의 동작뿐만 아니라 구조 변경에도 취약하다는 것을 의미한다. 이는 결국 테스트 대상 코드가 리팩토링되면 테스트를 수정해야 할 가능성이 더 높다는 것을 의미한다.
이를 염두에 두고, 테스트에서 실제로 어떤 상호 작용을 확인하고 싶은지 신중하게 생각해야 한다. 앞의 테스트에서 했던 것처럼 모든 상호 작용을 확인하지 않고 대신 가장 중요한 것에 집중하는 것이 좋은 생각일 수 있다. 그렇지 않으면 테스트 대상 클래스에 대한 모든 단일 변경으로 테스트를 변경해야 하므로 테스트의 가치가 약화된다.
이 테스트는 여전히 단위 테스트이지만, 의존성에 대한 상호 작용을 테스트하기 때문에 통합 테스트에 가깝다. 그러나 모의로 작업하고 실제 의존성을 관리할 필요가 없기 때문에 완전한 통합 테스트보다 생성 및 유지 관리가 더 쉽다.

### 통합 테스트로 웹 어댑터 테스트하기
또 다른 계층을 바깥으로 이동하면 어댑터에 도달한다. 웹 어댑터 테스트에 대해 논의해 보자.
웹 어댑터는 예를 들어 JSON 문자열 형식의 입력을 HTTP를 통해 받고, 이에 대한 일부 유효성 검사를 수행하고, 입력을 유스케이스가 예상하는 형식으로 매핑한 다음, 해당 유스케이스에 전달한다는 것을 상기하자.
그런 다음 유스케이스의 결과를 다시 JSON으로 매핑하고 HTTP 응답을 통해 클라이언트에 반환한다.
웹 어댑터에 대한 테스트에서 우리는 이러한 모든 단계가 예상대로 작동하는지 확인하고 싶다:

```java
@WebMvcTest(controllers = SendMoneyController.class)
class SendMoneyControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private SendMoneyUseCase sendMoneyUseCase;

    private static final String ENDPOINT
            = "/accounts/sendMoney/{sourceAccountId}/{targetAccountId}/{amount}";

    @Test
    void testSendMoney() throws Exception {

        mockMvc.perform(
                post(ENDPOINT, 41L, 42L, 500)
                        .header("Content-Type", "application/json"))
                .andExpect(status().isOk());

        then(sendMoneyUseCase).should()
                .sendMoney(eq(new SendMoneyCommand(
                        new AccountId(41L),
                        new AccountId(42L),
                        Money.of(500L))));
    }
}
```

앞의 테스트는 스프링 부트 프레임워크로 구축된 `SendMoneyController`라는 웹 컨트롤러에 대한 표준 통합 테스트이다. `testSendMoney()` 메서드에서, 우리는 한 계정에서 다른 계정으로의 트랜잭션을 트리거하기 위해 웹 컨트롤러에 모의 HTTP 요청을 보낸다.
`isOk()` 메서드를 사용하여 HTTP 응답의 상태가 200인지 확인하고, 모의 처리된 유스케이스 클래스가 호출되었는지 확인한다.
웹 어댑터의 대부분의 책임은 이 테스트에서 다루어진다.
`MockMvc` 객체로 HTTP 프로토콜을 모의 처리하고 있기 때문에 실제로 HTTP 프로토콜을 통해 테스트하는 것은 아니다. 우리는 프레임워크가 모든 것을 HTTP로 또는 HTTP에서 제대로 변환한다고 신뢰한다. 프레임워크를 테스트할 필요는 없다.
그러나 JSON에서 `SendMoneyCommand` 객체로 입력을 매핑하는 전체 경로는 다루어진다. 5장, 유스케이스 구현하기에서 설명한 대로 `SendMoneyCommand` 객체를 자체 유효성 검사 명령으로 빌드하면 이 매핑이 유스케이스에 구문적으로 유효한 입력을 생성하는지 확인하기까지 한다. 또한, 유스케이스가 실제로 호출되고 HTTP 응답이 예상 상태를 갖는지 확인했다.
그렇다면 이것이 왜 단위 테스트가 아닌 통합 테스트일까? 이 테스트에서 단일 웹 컨트롤러 클래스만 테스트하는 것처럼 보이지만, 내부적으로는 훨씬 더 많은 일이 일어나고 있다. `@WebMvcTest` 어노테이션을 사용하여, 우리는 스프링에게 특정 요청 경로에 응답하고, 자바와 JSON 간에 매핑하고, HTTP 입력을 검증하는 등의 역할을 하는 전체 객체 네트워크를 인스턴스화하도록 지시한다. 그리고 이 테스트에서 우리는 우리 웹 컨트롤러가 이 네트워크의 일부로 작동하는지 확인한다.
웹 컨트롤러는 스프링 프레임워크와 긴밀하게 결합되어 있으므로, 격리된 상태에서 테스트하는 대신 이 프레임워크에 통합되었을 때 테스트하는 것이 합리적이다. 웹 컨트롤러를 일반 단위 테스트로 테스트하면 모든 매핑, 유효성 검사 및 HTTP 관련 내용을 다루지 못하게 되며, 프레임워크의 메커니즘에서 톱니바퀴에 불과한 프로덕션에서 실제로 작동하는지 확신할 수 없다.

### 통합 테스트로 영속성 어댑터 테스트하기
비슷한 이유로, 어댑터 내의 로직뿐만 아니라 데이터베이스로의 매핑도 확인하고 싶기 때문에 단위 테스트 대신 통합 테스트로 영속성 어댑터를 다루는 것이 합리적이다.
7장, 영속성 어댑터 구현하기에서 구축한 영속성 어댑터를 테스트하고 싶다.
어댑터에는 데이터베이스에서 `Account` 엔티티를 로드하는 메서드와 데이터베이스에 새 계정 활동을 저장하는 메서드의 두 가지 메서드가 있다:

```java
@DataJpaTest
@Import({AccountPersistenceAdapter.class, AccountMapper.class})
class AccountPersistenceAdapterTest {

    @Autowired
    private AccountPersistenceAdapter adapter;

    @Autowired
    private ActivityRepository activityRepository;

    @Test
    @Sql("AccountPersistenceAdapterTest.sql")
    void loadsAccount() {
        Account account = adapter.loadAccount(
                new AccountId(1L),
                LocalDateTime.of(2018, 8, 10, 0, 0));

        assertThat(account.getActivityWindow()
                .getActivities())
                .hasSize(2);
        assertThat(account.calculateBalance())
                .isEqualTo(Money.of(500));
    }

    @Test
    void updatesActivities() {
        Account account = defaultAccount()
                .withBaselineBalance(Money.of(555L))
                .withActivityWindow(new ActivityWindow(
                        defaultActivity()
                                .withId(null)
                                .withMoney(Money.of(1L)).build()))
                .build();

        adapter.updateActivities(account);

        assertThat(activityRepository.count()).isEqualTo(1);

        ActivityJpaEntity savedActivity = activityRepository
                .findAll()
                .get(0);
        assertThat(savedActivity.getAmount()).isEqualTo(1L);
    }
}
```

`@DataJpaTest`를 사용하여, 우리는 데이터베이스 접근에 필요한 객체 네트워크를 인스턴스화하도록 스프링에게 지시하며, 여기에는 데이터베이스에 연결하는 스프링 데이터 리포지토리도 포함된다. `@Import` 어노테이션을 사용하여 특정 객체가 해당 네트워크에 추가되도록 일부 추가 구성을 가져온다. 이러한 객체는 테스트 대상 어댑터가 들어오는 도메인 객체를 데이터베이스 객체로 매핑하는 등의 작업에 필요하다.
`loadAccount()` 메서드에 대한 테스트에서, 우리는 `AccountPersistenceAdapterTest.sql`이라는 이름의 SQL 스크립트를 사용하여 데이터베이스를 특정 상태로 만든다. 그런 다음, 어댑터 API를 통해 계정을 로드하고 SQL 스크립트의 데이터베이스 상태를 고려할 때 예상되는 상태를 가지고 있는지 확인한다.
`updateActivities()`에 대한 테스트는 반대 방향으로 진행된다. 새 계정 활동이 있는 `Account` 객체를 생성하고 영속화를 위해 어댑터에 전달한다. 그런 다음, `ActivityRepository`의 API를 통해 활동이 데이터베이스에 저장되었는지 확인한다.
이러한 테스트의 중요한 측면은 데이터베이스를 모의 처리하지 않는다는 것이다. 테스트는 실제로 데이터베이스에 접근한다. 데이터베이스를 모의 처리했다면, 테스트는 여전히 동일한 코드 라인을 다루어 동일한 높은 코드 라인 커버리지를 생성했을 것이다. 그러나 이러한 높은 커버리지에도 불구하고, SQL 문의 오류나 데이터베이스 테이블과 자바 객체 간의 예기치 않은 매핑 오류로 인해 실제 데이터베이스 설정에서 실패할 가능성이 상당히 높을 것이다.
기본적으로 스프링은 테스트 중에 사용할 인메모리 데이터베이스를 가동한다는 점에 유의하라. 이것은 아무것도 구성할 필요가 없고 테스트가 즉시 작동하기 때문에 매우 실용적이다. 그러나 이 인메모리 데이터베이스는 프로덕션에서 사용하는 데이터베이스가 아닐 가능성이 높기 때문에, 테스트가 인메모리 데이터베이스에 대해 완벽하게 작동하더라도 실제 데이터베이스에서 문제가 발생할 가능성이 여전히 크다. 예를 들어, 데이터베이스 공급업체는 자신만의 SQL 버전을 구현하는 것을 좋아한다.
이러한 이유로, 영속성 어댑터 테스트는 실제 데이터베이스에 대해 실행되어야 한다. Testcontainers와 같은 라이브러리는 이 점에서 큰 도움이 되며, 필요에 따라 데이터베이스가 있는 도커 컨테이너를 가동한다.³
실제 데이터베이스에 대해 실행하면 두 개의 다른 데이터베이스 시스템을 관리할 필요가 없다는 추가적인 이점이 있다. 테스트 중에 인메모리 데이터베이스를 사용하는 경우, 특정 방식으로 구성해야 하거나, 각 데이터베이스에 대해 별도의 데이터베이스 마이그레이션 스크립트 버전을 만들어야 할 수 있으며, 이는 테스트의 유지보수성에 큰 타격을 준다.

### 시스템 테스트로 주요 경로 테스트하기
피라미드의 맨 위에는 내가 시스템 테스트라고 부르는 것이 있다. 시스템 테스트는 전체 애플리케이션을 시작하고 API에 대한 요청을 실행하여 모든 계층이 함께 작동하는지 확인한다.
헥사고날 아키텍처는 애플리케이션과 외부 세계 사이에 잘 정의된 경계를 만드는 것에 관한 것이다. 그렇게 함으로써 애플리케이션 경계는 설계상 매우 테스트하기 쉬워진다. 애플리케이션을 로컬에서 테스트하려면 그림 8.2에 설명된 대로 어댑터를 모의 어댑터로 교체하기만 하면 된다.

> 3 Testcontainers: https://www.testcontainers.org/.

![[tom_hombergs_56.png]]
*그림 8.2 – 어댑터를 모의로 교체함으로써, 외부 세계에 대한 의존성 없이 애플리케이션을 실행하고 테스트할 수 있다*

왼쪽에서는 입력 어댑터를 애플리케이션의 입력 포트를 호출하여 상호 작용하는 테스트 드라이버로 교체할 수 있다. 테스트 드라이버는 자동화된 테스트 중에 사용자 행동을 시뮬레이션하는 특정 테스트 시나리오를 구현할 수 있다.
오른쪽에서는 출력 어댑터를 실제 어댑터의 동작을 시뮬레이션하고 미리 지정된 값을 반환하는 모의 어댑터로 교체할 수 있다.⁴
이런 식으로, 우리는 입력 포트에서 도메인 서비스 및 엔티티를 거쳐 출력 포트까지 애플리케이션의 "헥사곤"을 다루는 "애플리케이션 테스트"를 만들 수 있다.
그러나 나는 입력 및 출력 어댑터를 모의 처리하는 "애플리케이션 테스트"를 작성하는 대신, 실제 입력 어댑터에서 실제 출력 어댑터까지 전체 경로를 다루는 "시스템 테스트"를 작성하는 것을 목표로 해야 한다고 주장한다. 이러한 테스트는 입력 및 출력 어댑터를 모의 처리하면 잡을 수 없는 많은 미묘한 버그를 발견한다. 이러한 버그에는 계층 간의 매핑 오류나 단순히 애플리케이션과 통신하는 외부 시스템 간의 잘못된 기대가 포함된다.
이와 같은 "시스템 테스트"는 테스트 설정에서 애플리케이션이 통신하는 실제 외부 시스템을 가동할 수 있어야 한다.

> 4 모의: 누구에게 묻느냐와 테스트에서 무엇을 하느냐에 따라 "모의"라고 부르는 대신 "가짜" 또는 "스텁"이라고 불러야 할 수도 있다. 각 용어는 약간 다른 의미를 갖는 것 같지만, 결국에는 모두 "실제" 것을 테스트에 사용할 "모의" 것으로 대체한다. 나는 보통 사물의 이름을 올바르게 지정하는 것을 좋아하지만, 이 경우에는 모의가 끝나고 스텁이 시작되는 미묘한 차이를 논의하는 데 가치를 두지 않는다. 아니면 그 반대인가?

입력 측면에서는, 예를 들어 요청이 실제 웹 어댑터를 통과하도록 애플리케이션에 실제 HTTP 호출을 할 수 있는지 확인해야 한다. 그러나 애플리케이션을 로컬에서 시작하고 프로덕션 환경에서처럼 HTTP 호출을 수신하도록 하면 되므로 이는 매우 쉬워야 한다.
출력 측면에서는, 예를 들어 테스트가 실제 영속성 어댑터를 통과하도록 실제 데이터베이스를 가동해야 한다. 대부분의 데이터베이스는 오늘날 로컬에서 가동할 수 있는 도커 이미지를 제공하여 이를 쉽게 만든다. 애플리케이션이 데이터베이스가 아닌 타사 시스템과 통신하는 경우, 해당 시스템을 포함하는 도커 이미지를 찾아(또는 생성하여) 로컬 도커 컨테이너를 가동하여 애플리케이션을 테스트해야 한다.
주어진 외부 시스템에 대해 사용 가능한 도커 이미지가 없는 경우, 실제를 시뮬레이션하는 사용자 지정 모의 출력 어댑터를 작성할 수 있다. 헥사고날 아키텍처는 테스트 목적으로 실제 출력 어댑터를 이 모의로 쉽게 교체할 수 있게 해준다. 그리고 도커 이미지가 사용 가능해지면, 너무 많은 노력 없이 실제 출력 어댑터로 전환할 수 있다.
물론, 실제 어댑터 대신 모의 어댑터에 대해 테스트하는 데는 타당한 이유가 있다. 예를 들어, 애플리케이션이 여러 프로필에서 실행되고 각 프로필이 동일한 입력 및 출력 포트에 대해 구현된 다른 (실제) 입력 또는 출력 어댑터를 사용하는 경우, 어댑터의 오류로부터 애플리케이션의 오류를 격리하는 테스트를 원할 수 있다. 우리 헥사곤만 다루는 애플리케이션 테스트는 바로 우리가 원하는 도구이다. 그러나 데이터베이스가 있는 표준 웹 애플리케이션의 경우, 입력 및 출력 어댑터가 다소 정적이므로 대신 시스템 테스트에 집중하고 싶을 것이다.
시스템 테스트는 어떻게 생겼을까? 송금 유스케이스에 대한 시스템 테스트에서, 우리는 애플리케이션에 HTTP 요청을 보내고 응답과 계정의 새 잔액을 검증한다.
자바와 스프링 세계에서는 다음과 같을 수 있다:

```java
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class SendMoneySystemTest {

    @Autowired
    private TestRestTemplate restTemplate;

    private static final String ENDPOINT
            = "/accounts/sendMoney/{sourceAccountId}/{targetAccountId}/{amount}";

    @Test
    @Sql("SendMoneySystemTest.sql")
    void sendMoney() {

        Money initialSourceBalance = sourceAccount().calculateBalance();
        Money initialTargetBalance = targetAccount().calculateBalance();
		
        ResponseEntity response = whenSendMoney(
                sourceAccountId(),
                targetAccountId(),
                transferredAmount());

        then(response.getStatusCode())
                .isEqualTo(HttpStatus.OK);

        then(sourceAccount().calculateBalance())
                .isEqualTo(initialSourceBalance.minus(transferredAmount()));

        then(targetAccount().calculateBalance())
                .isEqualTo(initialTargetBalance.plus(transferredAmount()));
    }

    private ResponseEntity whenSendMoney(
            AccountId sourceAccountId,
            AccountId targetAccountId,
            Money amount) {
        HttpHeaders headers = new HttpHeaders();
        headers.add("Content-Type", "application/json");
        HttpEntity<Void> request = new HttpEntity<>(null, headers);

        return restTemplate.exchange(
                ENDPOINT,
                HttpMethod.POST,
                request,
                Object.class,
                sourceAccountId.getValue(),
                targetAccountId.getValue(),
                amount.getAmount());
    }

    // some helper methods omitted
}
```

`@SpringBootTest`를 사용하여, 우리는 스프링에게 애플리케이션을 구성하는 전체 객체 네트워크를 시작하도록 지시한다. 또한 애플리케이션이 임의의 포트에서 자신을 노출하도록 구성한다.
테스트 메서드에서는 단순히 요청을 생성하고, 애플리케이션에 보내고, 응답 상태와 계정의 새 잔액을 확인한다.
웹 어댑터 테스트에서 이전에 했던 것처럼 `MockMvc`가 아닌 `TestRestTemplate`을 사용하여 요청을 보낸다. 이는 테스트가 실제 HTTP 호출을 하여 테스트를 프로덕션 환경에 조금 더 가깝게 만든다는 것을 의미한다.
실제 HTTP를 통과하는 것처럼, 실제 출력 어댑터를 통과한다. 우리 경우에는 이것은 애플리케이션을 데이터베이스에 연결하는 영속성 어댑터일 뿐이다. 다른 시스템과 통신하는 애플리케이션에서는 추가 출력 어댑터가 있을 것이다. 시스템 테스트를 위해서라도 이러한 모든 타사 시스템을 가동하고 실행하는 것이 항상 가능한 것은 아니므로, 결국에는 그것들을 모의 처리할 수 있다.
우리 헥사고날 아키텍처는 몇 개의 출력 포트 인터페이스만 스텁 아웃하면 되므로 우리에게 이것을 가능한 한 쉽게 만들어준다.
테스트를 가능한 한 읽기 쉽게 만들기 위해 많은 노력을 기울였다는 점에 유의하라. 나는 헬퍼 메서드 내에 모든 보기 흉한 로직을 숨겼다. 이러한 메서드는 이제 사물의 상태를 확인하는 데 사용할 수 있는 도메인 특정 언어를 형성한다.
이와 같은 도메인 특정 언어는 모든 유형의 테스트에서 좋은 생각이지만, 시스템 테스트에서는 더욱 중요하다. 시스템 테스트는 단위 또는 통합 테스트보다 애플리케이션의 실제 사용자를 훨씬 더 잘 시뮬레이션하므로, 사용자의 관점에서 애플리케이션을 확인할 수 있다.
이것은 적절한 어휘가 있으면 훨씬 쉽다. 이 어휘는 또한 애플리케이션의 사용자를 가장 잘 구현하고 아마도 프로그래머가 아닌 도메인 전문가가 테스트에 대해 추론하고 피드백을 제공할 수 있게 한다. JGiven⁵과 같은 행동 주도 개발을 위한 전체 라이브러리가 있으며, 테스트를 위한 어휘를 만드는 프레임워크를 제공한다.
이전 섹션에서 설명한 대로 단위 및 통합 테스트를 생성하면 시스템 테스트는 동일한 코드의 많은 부분을 다룰 것이다. 추가적인 이점을 제공하기는 할까? 그렇다. 보통 단위 및 통합 테스트와는 다른 유형의 버그를 찾아낸다. 예를 들어, 계층 간의 일부 매핑이 잘못될 수 있으며, 이는 단위 및 통합 테스트만으로는 알아차리지 못할 것이다.
시스템 테스트는 여러 유스케이스를 결합하여 시나리오를 만들 때 가장 큰 강점을 발휘한다. 각 시나리오는 사용자가 일반적으로 애플리케이션을 통해 취하는 특정 경로를 나타낸다. 가장 중요한 시나리오가 통과하는 시스템 테스트로 다루어지면, 최신 수정으로 인해 그것들을 깨뜨리지 않았다고 가정하고 출시할 준비가 된 것이다.

### 얼마나 많은 테스트가 충분한가?
내가 참여했던 많은 프로젝트 팀이 답할 수 없었던 질문은 우리가 얼마나 많은 테스트를 해야 하는가이다.
테스트가 코드 라인의 80%를 커버하면 충분할까? 그보다 높아야 할까?
라인 커버리지는 테스트 성공을 측정하는 나쁜 지표이다. 100% 이외의 목표는 코드 베이스의 중요한 부분이 전혀 커버되지 않을 수 있기 때문에 완전히 의미가 없다.⁶ 그리고 100%에서도 모든 버그가 박멸되었다고 확신할 수 없다.
나는 소프트웨어를 출시하는 데 얼마나 편안한지로 테스트 성공을 측정할 것을 제안한다. 테스트를 실행한 후 출시할 만큼 테스트를 신뢰한다면, 우리는 괜찮다. 더 자주 출시할수록 테스트에 대한 신뢰가 더 커진다. 일년에 두 번만 출시하면 아무도 테스트를 신뢰하지 않을 것이다. 왜냐하면 일년에 두 번만 자신을 증명하기 때문이다.

> 5 JGiven: https://jgiven.org/.
> 6 테스트 커버리지: 100% 테스트 커버리지에 대해 더 읽고 싶다면, https://reflectoring.io/100-percent-test-coverage/에서 "왜 100% 코드 커버리지를 강제해야 하는가"라는 제목의 내 기사를 살펴보라.

이것은 처음 몇 번 출시할 때 신념의 도약을 필요로 하지만, 프로덕션의 버그를 수정하고 배우는 것을 우선순위로 삼는다면, 우리는 올바른 길을 가고 있는 것이다. 각 프로덕션 버그에 대해, "왜 우리 테스트가 이 버그를 잡지 못했을까?"라는 질문을 하고, 답을 문서화한 다음, 그것을 다루는 테스트를 추가해야 한다. 시간이 지남에 따라 이것은 우리를 출시에 편안하게 만들 것이고, 문서는 시간이 지남에 따라 개선 사항을 측정하는 지표를 제공할 것이다.
그러나 우리가 만들어야 할 테스트를 정의하는 전략으로 시작하는 것이 도움이 된다.
우리 헥사고날 아키텍처에 대한 그러한 전략 중 하나는 다음과 같다:
- 도메인 엔티티를 구현하는 동안 단위 테스트로 다룬다.
- 유스케이스 서비스를 구현하는 동안 단위 테스트로 다룬다.
- 어댑터를 구현하는 동안 통합 테스트로 다룬다.
- 사용자가 애플리케이션을 통해 취할 수 있는 가장 중요한 경로를 시스템 테스트로 다룬다.

구현하는 동안이라는 문구에 주목하라 – 기능 개발 중에 테스트가 수행되고 나중에가 아닐 때, 그것들은 개발 도구가 되고 더 이상 귀찮은 일처럼 느껴지지 않는다.
그러나 새 필드를 추가할 때마다 테스트를 수정하는 데 한 시간을 소비해야 한다면, 우리는 무언가 잘못하고 있는 것이다. 아마도 우리 테스트는 코드의 구조적 변경에 너무 취약하고, 그것을 개선하는 방법을 찾아야 할 것이다. 모든 리팩토링에 대해 수정해야 한다면 테스트는 가치를 잃는다.

### 이것이 유지보수 가능한 소프트웨어를 구축하는 데 어떻게 도움이 되는가?
헥사고날 아키텍처 스타일은 도메인 로직과 외부 지향 어댑터를 깔끔하게 분리한다. 이는 중앙 도메인 로직을 단위 테스트로, 어댑터를 통합 테스트로 다루는 명확한 테스트 전략을 정의하는 데 도움이 된다.
입력 및 출력 포트는 테스트에서 매우 눈에 띄는 모의 지점을 제공한다. 각 포트에 대해, 우리는 그것을 모의 처리할지 또는 실제 구현을 사용할지 결정할 수 있다. 포트가 각각 매우 작고 집중되어 있다면, 모의 처리는 귀찮은 일이 아니라 산들바람이다. 포트 인터페이스가 제공하는 메서드가 적을수록 테스트에서 어떤 메서드를 모의 처리해야 하는지에 대한 혼란이 적다.
만약 무언가를 모의 처리하는 것이 너무 부담스럽거나, 코드 베이스의 특정 부분을 다루기 위해 어떤 종류의 테스트를 사용해야 할지 모른다면, 그것은 경고 신호이다. 이와 관련하여, 우리 테스트는 아키텍처의 결함에 대해 경고하고 유지보수 가능한 코드 베이스를 만드는 길로 우리를 다시 안내하는 카나리아의 추가적인 책임을 진다.
지금까지 우리는 유스케이스와 어댑터를 대부분 격리하여 이야기했다. 그것들은 서로 어떻게 통신할까? 다음 장에서는 그것들 사이의 공통 언어를 구성하는 데이터 모델을 설계하는 방법에 대한 몇 가지 전략을 살펴볼 것이다.

---

# 9. 경계 간 매핑
이전 장에서는 웹, 애플리케이션, 도메인 및 영속성 계층과 각 계층이 유스케이스를 구현하는 데 기여하는 바를 논의했다.
그러나 우리는 각 계층의 모델 간의 두렵고 편재하는 매핑 주제에 대해서는 거의 다루지 않았다. 매퍼 구현을 피하기 위해 두 계층에서 동일한 모델을 사용할지 여부에 대해 어느 시점에서 논의한 적이 있을 것이다.
주장은 다음과 같았을 것이다:
매핑 찬성 개발자:
"계층 간에 매핑하지 않으면 두 계층에서 동일한 모델을 사용해야 하므로 계층이 긴밀하게 결합될 것이다!"
매핑 반대 개발자:
"하지만 계층 간에 매핑하면 많은 상용구 코드를 생성하게 되는데, 이는 CRUD만 수행하고 계층 전체에서 동일한 모델을 갖는 많은 유스케이스에 대해서는 과잉이다!"
이와 같은 논의에서 종종 그렇듯이, 주장의 양쪽 모두에 진실이 있다. 몇 가지 매핑 전략과 그 장단점을 논의하고 이러한 개발자들이 결정을 내리는 데 도움이 될 수 있는지 살펴보자.

### "매핑 없음" 전략
첫 번째 전략은 실제로 전혀 매핑하지 않는 것이다.

![[tom_hombergs_59.png]]
*그림 9.1 – 포트 인터페이스가 도메인 모델을 입력 및 출력 모델로 사용하는 경우, 계층 간에 매핑하지 않도록 선택할 수 있다*

그림 9.1은 BuckPal 예제 애플리케이션의 송금 유스케이스와 관련된 구성 요소를 보여준다.
웹 계층에서 웹 컨트롤러는 유스케이스를 실행하기 위해 `SendMoneyUseCase` 인터페이스를 호출한다.
이 인터페이스는 `Account` 객체를 인수로 받는다. 이는 웹 및 애플리케이션 계층 모두 `Account` 클래스에 접근해야 함을 의미한다 – 둘 다 동일한 모델을 사용한다.
애플리케이션의 다른 쪽에서는 영속성 및 애플리케이션 계층 간에 동일한 관계가 있다.
모든 계층이 동일한 모델을 사용하므로 그들 사이에 매핑을 구현할 필요가 없다.
하지만 이 설계의 결과는 무엇일까?
웹 및 영속성 계층은 모델에 대한 특별한 요구 사항이 있을 수 있다. 예를 들어, 웹 계층이 REST를 통해 모델을 노출하는 경우, 모델 클래스는 특정 필드를 JSON으로 직렬화하는 방법을 정의하는 일부 어노테이션이 필요할 수 있다. 객체-관계 매핑(ORM) 프레임워크를 사용하는 경우 영속성 계층도 마찬가지이며, 데이터베이스 매핑을 정의하는 일부 어노테이션이 필요할 수 있다. 프레임워크는 또한 클래스가 특정 계약을 따르도록 요구할 수 있다.
예제에서 이러한 모든 특별한 요구 사항은 도메인 및 애플리케이션 계층이 관심이 없음에도 불구하고 `Account` 도메인 모델 클래스에서 처리되어야 한다. 이는 `Account` 클래스가 웹, 애플리케이션 및 영속성 계층과 관련된 이유로 변경되어야 하므로 단일 책임 원칙을 위반한다.
기술적 요구 사항 외에도 각 계층은 `Account` 클래스에 특정 사용자 지정 필드를 요구할 수 있다. 이로 인해 특정 필드가 한 계층에서만 관련된 단편화된 도메인 모델이 발생할 수 있다.
그렇다면 이것이 "매핑 없음" 전략을 절대 구현해서는 안 된다는 것을 의미할까? 물론 아니다. 더럽게 느껴질 수 있지만 "매핑 없음" 전략은 완벽하게 유효할 수 있다.
간단한 CRUD 유스케이스를 고려해보자. 웹 모델에서 도메인 모델로, 그리고 도메인 모델에서 영속성 모델로 동일한 필드를 정말로 매핑해야 할까? 나는 그렇지 않다고 말하고 싶다.
그리고 도메인 모델의 JSON 또는 ORM 어노테이션은 어떤가? 그것들이 정말 우리를 괴롭히는가?
영속성 계층에서 무언가 변경되면 도메인 모델에서 어노테이션 한두 개를 변경해야 하더라도, 그게 뭐 대수인가?
모든 계층이 정확히 동일한 구조로 정확히 동일한 정보를 필요로 하는 한, "매핑 없음" 전략은 완벽하게 유효한 옵션이다.
애플리케이션 또는 도메인 계층에서 (아마도 어노테이션을 제외하고) 웹 또는 영속성 문제를 다루게 되는 즉시, 다른 매핑 전략으로 이동해야 한다.
여기서 서론의 두 개발자를 위한 교훈이 있다: 과거에 특정 매핑 전략을 결정했더라도 나중에 변경할 수 있다.
내 경험상 많은 유스케이스는 간단한 CRUD 유스케이스로 시작한다. 나중에 풍부한 동작과 유효성 검사를 갖춘 본격적인 비즈니스 유스케이스로 성장할 수 있으며, 이는 더 비싼 매핑 전략을 정당화한다. 또는 CRUD 상태를 영원히 유지할 수도 있으며, 이 경우 다른 매핑 전략에 투자하지 않은 것을 기쁘게 생각할 것이다.

### "양방향" 매핑 전략
각 계층이 자체 모델을 갖는 매핑 전략은 내가 "양방향" 매핑 전략이라고 부르는 것이며, 그림 9.2에 설명되어 있다.

![[tom_hombergs_60.png]]
*그림 9.2 – 각 어댑터가 자체 모델을 가지면, 어댑터는 자신의 모델을 도메인 모델로 매핑하고 다시 매핑하는 책임을 진다*

각 계층에는 자체 모델이 있으며, 이는 도메인 모델과 완전히 다른 구조를 가질 수 있다.
웹 계층은 웹 모델을 인커밍 포트에서 예상하는 입력 모델로 매핑한다. 또한 인커밍 포트에서 반환된 도메인 객체를 다시 웹 모델로 매핑한다.
영속성 계층은 아웃고잉 포트에서 사용되는 도메인 모델과 영속성 모델 간의 유사한 매핑을 담당한다.
두 계층 모두 두 방향으로 매핑하므로 "양방향" 매핑이라는 이름이 붙었다.
각 계층이 자체 모델을 가지면 (내용이 변경되지 않는 한) 다른 계층에 영향을 주지 않고 자체 모델을 수정할 수 있다. 웹 모델은 데이터의 최적 표현을 허용하는 구조를 가질 수 있다. 도메인 모델은 유스케이스를 구현하는 데 가장 적합한 구조를 가질 수 있다. 그리고 영속성 모델은 OR-매퍼가 객체를 데이터베이스에 영속화하는 데 필요한 구조를 가질 수 있다.
이 매핑 전략은 또한 웹 또는 영속성 문제로 더럽혀지지 않은 깨끗한 도메인 모델로 이어진다. JSON 또는 ORM 매핑 어노테이션을 포함하지 않는다. 단일 책임 원칙이 충족된다.
"양방향" 매핑의 또 다른 보너스는 "매핑 없음" 전략 다음으로 개념적으로 가장 간단한 매핑 전략이라는 것이다. 매핑 책임은 명확하다: 외부 계층/어댑터는 내부 계층의 모델로 매핑하고 다시 매핑한다. 내부 계층은 자신의 모델만 알고 매핑 대신 도메인 로직에 집중할 수 있다.
모든 매핑 전략과 마찬가지로 "양방향" 매핑에도 단점이 있다.
우선, 일반적으로 많은 상용구 코드로 끝난다. 코드 양을 줄이기 위해 많은 매핑 프레임워크 중 하나를 사용하더라도 모델 간의 매핑을 구현하는 데는 보통 상당한 시간이 걸린다. 이는 부분적으로 매핑 로직을 디버깅하는 것이 고통스럽기 때문이다 – 특히 내부 작업을 일반 코드 및 리플렉션 계층 뒤에 숨기는 매핑 프레임워크를 사용할 때 더욱 그렇다.
또 다른 잠재적인 단점은 인커밍 및 아웃고잉 포트가 도메인 객체를 입력 매개변수 및 반환 값으로 사용한다는 것이다. 어댑터는 이를 자신의 모델에 매핑하지만, 이는 다음에 논의할 "전체" 매핑 전략에서처럼 전용 "전송 모델"을 도입하는 것보다 계층 간에 더 많은 결합을 생성한다.
"매핑 없음" 전략과 마찬가지로 "양방향" 매핑 전략은 만병통치약이 아니다. 그러나 많은 프로젝트에서 이러한 종류의 매핑은 가장 간단한 CRUD 유스케이스에 대해서도 전체 코드 베이스에 걸쳐 준수해야 하는 신성한 법으로 간주된다. 이는 불필요하게 개발 속도를 늦춘다.
단일 매핑 전략을 철칙으로 간주해서는 안 된다. 대신, 각 유스케이스에 대해 결정해야 한다.

### "전체" 매핑 전략
또 다른 매핑 전략은 내가 "전체" 매핑 전략이라고 부르는 것이며, 그림 9.3에 설명되어 있다.

![[tom_hombergs_61.png]]
*그림 9.3 – 각 작업에 자체 모델이 필요한 경우, 웹 어댑터와 애플리케이션 계층은 각각 자신의 모델을 실행하려는 작업에서 예상하는 모델로 매핑한다*

이 매핑 전략은 작업당 별도의 입력 및 출력 모델을 도입한다. 계층 경계를 넘어 통신하기 위해 도메인 모델을 사용하는 대신, 그림의 `SendMoneyUseCase` 포트에 대한 입력 모델 역할을 하는 `SendMoneyCommand`와 같이 각 작업에 특정한 모델을 사용한다. 이러한 모델을 "명령", "요청" 또는 유사한 이름으로 부를 수 있다.
웹 계층은 입력을 애플리케이션 계층의 명령 객체로 매핑하는 책임을 진다.
이러한 명령은 애플리케이션 계층에 대한 인터페이스를 매우 명시적으로 만들고 해석의 여지를 거의 남기지 않는다. 각 유스케이스에는 자체 필드와 유효성 검사가 있는 자체 명령이 있다. 어떤 필드를 채워야 하고 어떤 필드를 비워두는 것이 더 나은지에 대한 추측이 없다. 그렇지 않으면 현재 유스케이스에 대해 원하지 않는 유효성 검사를 트리거할 수 있기 때문이다.
그런 다음 애플리케이션 계층은 명령 객체를 유스케이스에 따라 도메인 모델을 수정하는 데 필요한 모든 것으로 매핑하는 책임을 진다.
당연히, 한 계층에서 여러 다른 명령으로 매핑하려면 단일 웹 모델과 도메인 모델 간에 매핑하는 것보다 훨씬 더 많은 매핑 코드가 필요하다. 그러나 이 매핑은 단 하나의 유스케이스 대신 많은 유스케이스의 요구를 처리해야 하는 매핑보다 구현 및 유지 관리가 훨씬 쉽다.
나는 이 매핑 전략을 전역 패턴으로 옹호하지 않는다. 웹 계층(또는 다른 인커밍 어댑터)과 애플리케이션 계층 사이에서 애플리케이션의 상태 수정 유스케이스를 명확하게 구분하는 데 가장 큰 장점을 발휘한다. 매핑 오버헤드 때문에 애플리케이션 및 영속성 계층 사이에서는 사용하지 않을 것이다.
보통, 나는 이러한 종류의 매핑을 작업의 입력 모델로 제한하고 출력 모델로 도메인 객체를 간단히 사용할 것이다. 예를 들어, `SendMoneyUseCase`는 업데이트된 잔액이 있는 `Account` 객체를 반환할 수 있다.
이는 매핑 전략이 혼합될 수 있고 혼합되어야 함을 보여준다. 단일 매pping 전략이 모든 계층에 걸쳐 전역 규칙일 필요는 없다.

### "단방향" 매핑 전략
또 다른 장단점을 가진 또 다른 매핑 전략이 있다: 그림 9.4에 시각화된 "단방향" 전략이다.

![[tom_hombergs_62.png]]
*그림 9.4 – 도메인 모델과 어댑터 모델이 동일한 "상태" 인터페이스를 구현하면, 각 계층은 다른 계층에서 받은 객체를 단방향으로만 매핑하면 된다*

이 전략에서 모든 계층의 모델은 동일한 인터페이스를 구현하며, 이 인터페이스는 관련 속성에 대한 게터 메서드를 제공하여 도메인 모델의 상태를 캡슐화한다.
도메인 모델 자체는 풍부한 동작을 구현할 수 있으며, 애플리케이션 계층 내의 서비스에서 접근할 수 있다. 도메인 객체를 외부 계층에 전달하고 싶다면, 도메인 객체가 인커밍 및 아웃고잉 포트에서 예상하는 상태 인터페이스를 구현하므로 매핑 없이 그렇게 할 수 있다.
그런 다음 외부 계층은 인터페이스로 작업할 수 있는지 또는 자신의 모델로 매핑해야 하는지 결정할 수 있다. 수정 동작이 상태 인터페이스에 의해 노출되지 않으므로 도메인 객체의 상태를 실수로 수정할 수 없다.
외부 계층에서 애플리케이션 계층으로 전달하는 객체도 이 상태 인터페이스를 구현한다. 그런 다음 애플리케이션 계층은 동작에 접근하기 위해 실제 도메인 모델로 매핑해야 한다.
이 매핑은 도메인 주도 설계의 팩토리 개념과 잘 어울린다. DDD 측면에서 팩토리는 특정 상태에서 도메인 객체를 재구성하는 역할을 하며, 이것이 바로 우리가 하고 있는 일이다.¹
매핑 책임은 명확하다: 한 계층이 다른 계층에서 객체를 받으면, 해당 계층이 작업할 수 있는 것으로 매핑한다. 따라서 각 계층은 단방향으로만 매핑하므로 "단방향" 매핑 전략이 된다.
그러나 매핑이 계층에 분산되어 있기 때문에 이 전략은 다른 전략보다 개념적으로 더 어렵다.
이 전략은 계층 간의 모델이 유사할 때 가장 큰 강점을 발휘한다. 예를 들어, 읽기 전용 작업의 경우, 상태 인터페이스가 필요한 모든 정보를 제공하므로 웹 계층은 자신의 모델로 전혀 매핑할 필요가 없을 수 있다.

### 어떤 매핑 전략을 언제 사용해야 할까?
이것이 백만 달러짜리 질문이다, 그렇지 않은가?
답은 평소와 같이 불만족스러운 "상황에 따라 다르다"이다.
각 매핑 전략에는 다른 장점과 단점이 있으므로, 단일 전략을 전체 코드 베이스에 대한 확고한 전역 규칙으로 정의하려는 충동에 저항해야 한다. 이것은 동일한 코드 베이스 내에서 패턴을 혼합하는 것이 지저분하게 느껴지기 때문에 우리의 본능에 어긋난다. 그러나 단정함에 대한 우리의 감각을 만족시키기 위해 특정 작업에 가장 적합한 패턴이 아닌 패턴을 의도적으로 선택하는 것은 무책임하고 간단하다.

> 1 팩토리: 에릭 에반스의 『도메인 주도 설계』, 애디슨-웨슬리, 2004, 158페이지.

또한 소프트웨어가 시간이 지남에 따라 발전함에 따라 어제 작업에 가장 적합했던 전략이 오늘날에도 여전히 가장 적합하지 않을 수 있다. 고정된 매핑 전략으로 시작하여 시간이 지나도 유지하는 대신, 코드를 빠르게 발전시킬 수 있는 간단한 전략으로 시작하여 나중에 계층을 더 잘 분리하는 데 도움이 되는 더 복잡한 전략으로 이동할 수 있다.
어떤 전략을 언제 사용할지 결정하기 위해 팀 내에서 일련의 지침에 동의해야 한다. 이러한 지침은 어떤 상황에서 어떤 매핑 전략이 첫 번째 선택이어야 하는지에 대한 질문에 답해야 한다. 또한 그 이유가 시간이 지난 후에도 여전히 적용되는지 평가할 수 있도록 첫 번째 선택인 이유에 대해서도 답해야 한다.
예를 들어, 쿼리에 대해 수행하는 것보다 사용 사례를 수정하기 위해 다른 매핑 지침을 정의할 수 있다. 또한 웹 및 애플리케이션 계층과 애플리케이션 및 영속성 계층 간에 다른 매핑 전략을 사용하고 싶을 수도 있다.

이러한 상황에 대한 지침은 다음과 같을 수 있다.
- 수정 사용 사례에서 작업하는 경우, 사용 사례를 서로 분리하기 위해 웹 및 애플리케이션 계층 간에 "전체" 매핑 전략이 첫 번째 선택이다. 이렇게 하면 사용 사례별 유효성 검사 규칙이 명확해지고 특정 사용 사례에서 필요하지 않은 필드를 처리할 필요가 없다.
- 수정 사용 사례에서 작업하는 경우, 매핑 오버헤드 없이 코드를 빠르게 발전시킬 수 있도록 애플리케이션 및 영속성 계층 간에 "매핑 없음" 전략이 첫 번째 선택이다. 그러나 애플리케이션 계층에서 영속성 문제를 처리해야 하는 즉시, 영속성 문제를 영속성 계층에 유지하기 위해 "양방향" 매핑 전략으로 이동한다.
- 쿼리에서 작업하는 경우, 매핑 오버헤드 없이 코드를 빠르게 발전시킬 수 있도록 웹 및 애플리케이션 계층과 애플리케이션 및 영속성 계층 간에 "매핑 없음" 전략이 첫 번째 선택이다. 그러나 애플리케이션 계층에서 웹 또는 영속성 문제를 처리해야 하는 즉시, 웹 및 애플리케이션 계층 또는 애플리케이션 계층 및 영속성 계층 간에 각각 "양방향" 매핑 전략으로 이동한다.

이러한 지침을 성공적으로 적용하려면 개발자의 마음에 있어야 한다.
따라서 지침은 팀 노력으로 지속적으로 논의되고 수정되어야 한다.

### 이것이 유지보수 가능한 소프트웨어를 구축하는 데 어떻게 도움이 되는가?
인커밍 및 아웃고잉 포트는 애플리케이션 계층 간의 게이트키퍼 역할을 한다. 계층이 서로 통신하는 방법과 계층 간에 모델을 매핑하는 방법을 정의한다.
각 사용 사례에 대해 좁은 포트를 사용하면 다른 사용 사례에 대해 다른 매핑 전략을 선택하고 다른 사용 사례에 영향을 주지 않고 시간이 지남에 따라 발전시킬 수도 있으므로 특정 상황에 가장 적합한 전략을 선택할 수 있다.
각 사용 사례에 대해 다른 매핑 전략을 선택하는 것은 모든 상황에 대해 동일한 매핑 전략을 사용하는 것보다 더 어렵고 더 많은 의사 소통이 필요하지만, 매핑 지침이 알려져 있는 한, 필요한 작업을 수행하고 유지 관리가 더 쉬운 코드베이스로 팀에 보상할 것이다.
이제 애플리케이션을 구성하는 구성 요소와 통신 방법을 알았으므로 다른 구성 요소에서 작동하는 애플리케이션을 조립하는 방법을 탐색할 수 있다.

---

# 10. 애플리케이션 조립하기
이제 몇 가지 사용 사례, 웹 어댑터 및 영속성 어댑터를 구현했으므로 작동하는 애플리케이션으로 조립해야 한다. 4장, 코드 구성에서 논의했듯이, 클래스를 인스턴스화하고 시작 시 함께 연결하기 위해 종속성 주입 메커니즘에 의존한다.
이 장에서는 일반 Java와 Spring 및 Spring Boot 프레임워크를 사용하여 이를 수행하는 몇 가지 접근 방식에 대해 논의할 것이다.

## 조립에 신경 써야 하는 이유
필요할 때와 장소에서 사용 사례와 어댑터를 인스턴스화하지 않는 이유는 무엇인가? 코드 종속성을 올바른 방향으로 유지하고 싶기 때문이다. 기억하라: 모든 종속성은 애플리케이션의 도메인 코드를 향해 안쪽을 가리켜야 하므로 외부 계층에서 무언가 변경될 때 도메인 코드를 변경할 필요가 없다.
사용 사례가 영속성 어댑터를 호출해야 하고 자체적으로 인스턴스화하는 경우 잘못된 방향으로 코드 종속성을 생성한 것이다.
이것이 우리가 아웃고잉 포트 인터페이스를 만든 이유이다. 사용 사례는 인터페이스만 알고 런타임에 이 인터페이스의 구현이 제공된다.
이 프로그래밍 스타일의 좋은 부작용은 우리가 만드는 코드를 테스트하기가 훨씬 쉽다는 것이다. 클래스에 필요한 모든 객체를 생성자에 전달할 수 있다면 실제 객체 대신 모의를 전달하도록 선택할 수 있으므로 클래스에 대한 격리된 단위 테스트를 쉽게 만들 수 있다.
그렇다면 누가 우리 객체 인스턴스를 생성할 책임이 있는가? 그리고 종속성 규칙을 위반하지 않고 어떻게 할 수 있는가?
답은 아키텍처에 중립적이고 인스턴스화하기 위해 모든 클래스에 대한 종속성을 가진 구성 요소가 있어야 한다는 것이다(그림 10.1 참조).

![[tom_hombergs_63.png]]
*그림 10.1 – 중립 구성 요소는 인스턴스화하기 위해 모든 클래스에 액세스할 수 있다*

3장, 종속성 역전에서 소개된 클린 아키텍처에서 이 구성 요소는 종속성 규칙에 의해 정의된 대로 모든 내부 계층에 액세스할 수 있는 가장 바깥쪽 원에 있을 것이다.

구성 요소는 우리가 제공한 부품에서 작동하는 애플리케이션을 조립할 책임이 있다. 다음을 수행해야 한다.
- 웹 어댑터 인스턴스 생성
- HTTP 요청이 실제로 웹 어댑터로 라우팅되는지 확인
- 사용 사례 인스턴스 생성
- 웹 어댑터에 사용 사례 인스턴스 제공
- 영속성 어댑터 인스턴스 생성
- 사용 사례에 영속성 어댑터 인스턴스 제공
- 영속성 어댑터가 실제로 데이터베이스에 액세스할 수 있는지 확인

그 외에도 구성 요소는 구성 파일이나 명령줄 매개변수와 같은 특정 구성 매개변수 소스에 액세스할 수 있어야 한다. 애플리케이션 조립 중에 구성 요소는 이러한 매개변수를 애플리케이션 구성 요소에 전달하여 액세스할 데이터베이스나 이메일을 보낼 서버와 같은 동작을 제어한다.
이것들은 많은 책임(읽기: 변경 이유)이다. 여기서 단일 책임 원칙을 위배하는 것이 아닌가? 그렇다, 하지만 애플리케이션의 나머지 부분을 깨끗하게 유지하려면 배선을 처리하는 외부 구성 요소가 필요하다. 그리고 이 구성 요소는 작동하는 애플리케이션으로 조립하기 위해 모든 움직이는 부품을 알아야 한다.

### 일반 코드를 통한 조립
애플리케이션 조립을 담당하는 구성 요소를 구현하는 방법에는 여러 가지가 있다. 종속성 주입 프레임워크의 지원 없이 애플리케이션을 구축하는 경우 일반 코드로 이러한 구성 요소를 만들 수 있다.

```java
package buckpal.configuration;

class Application {

    public static void main(String[] args) {
        AccountRepository accountRepository = new AccountRepository();
        ActivityRepository activityRepository = new ActivityRepository();
        AccountPersistenceAdapter accountPersistenceAdapter =
                new AccountPersistenceAdapter(accountRepository, activityRepository);

        SendMoneyUseCase sendMoneyUseCase =
                new SendMoneyUseService(
                        accountPersistenceAdapter,  // LoadAccountPort
                        accountPersistenceAdapter); // UpdateAccountStatePort

        SendMoneyController sendMoneyController =
                new SendMoneyController(sendMoneyUseCase);

        startProcessingWebRequests(sendMoneyController);
    }
}
```

이 코드 조각은 이러한 구성 요소가 어떻게 보일 수 있는지에 대한 단순화된 예이다. Java에서 애플리케이션은 기본 메서드에서 시작된다. 이 메서드 내에서 웹 컨트롤러에서 영속성 어댑터에 이르기까지 필요한 모든 클래스를 인스턴스화하고 함께 연결한다.
마지막으로, 웹 컨트롤러를 HTTP를 통해 노출하는 신비한 메서드 `startProcessingWebRequests()`를 호출한다.¹ 그러면 애플리케이션이 요청을 처리할 준비가 된다.

> 1 `startProcessingWebRequests()` 메서드는 웹 어댑터를 HTTP를 통해 노출하는 데 필요한 모든 부트스트래핑 논리에 대한 자리 표시자일 뿐이다. 우리는 이것을 직접 구현하고 싶지 않다. 실제 애플리케이션에서는 프레임워크가 우리를 위해 이 작업을 수행한다.

이 일반 코드 접근 방식은 애플리케이션을 조립하는 가장 기본적인 방법이다. 그러나 몇 가지 단점이 있다.
- 우선, 앞의 코드는 단일 웹 컨트롤러, 사용 사례 및 영속성 어댑터만 있는 애플리케이션용이다. 본격적인 엔터프라이즈 애플리케이션을 부트스트랩하기 위해 이와 같은 코드를 얼마나 많이 생성해야 하는지 상상해보라!
- 둘째, 패키지 외부에서 모든 클래스를 직접 인스턴스화하기 때문에 해당 클래스는 모두 공개되어야 한다. 즉, 예를 들어 Java 컴파일러는 공개되어 있기 때문에 사용 사례가 영속성 어댑터에 직접 액세스하는 것을 막지 않는다. 패키지-비공개 가시성을 사용하여 이와 같은 원치 않는 종속성을 피할 수 있다면 좋을 것이다.

다행히도 패키지-비공개 종속성을 유지하면서 우리를 위해 더러운 작업을 수행할 수 있는 종속성 주입 프레임워크가 있다. Spring 프레임워크는 현재 Java 세계에서 가장 인기가 있다. Spring은 또한 웹 및 데이터베이스 지원을 비롯한 여러 가지 다른 기능을 제공하므로 결국 신비한 `startProcessingWebRequests()` 메서드를 구현할 필요가 없다.

### Spring의 클래스패스 스캐닝을 통한 조립
Spring 프레임워크를 사용하여 애플리케이션을 조립하면 결과는 애플리케이션 컨텍스트라고 한다.
애플리케이션 컨텍스트에는 애플리케이션을 구성하는 모든 객체(Java 용어로 빈)가 포함된다.
Spring은 애플리케이션 컨텍스트를 조립하는 여러 가지 접근 방식을 제공하며, 각각 고유한 장점과 단점이 있다. 가장 인기 있는(그리고 가장 편리한) 접근 방식인 클래스패스 스캐닝에 대해 논의하는 것으로 시작하자.
클래스패스 스캐닝을 사용하면 Spring은 클래스패스의 특정 슬라이스에서 사용 가능한 모든 클래스를 살펴보고 `@Component` 어노테이션이 있는 클래스를 검색한다. 그런 다음 프레임워크는 이러한 각 클래스에서 객체를 생성한다. 클래스에는 7장, 영속성 어댑터 구현하기의 `AccountPersistenceAdapter`와 같이 필요한 모든 필드를 인수로 사용하는 생성자가 있어야 한다.

```java
@Component
@RequiredArgsConstructor
class AccountPersistenceAdapter implements
        LoadAccountPort,
        UpdateAccountStatePort {

    private final AccountRepository accountRepository;
    private final ActivityRepository activityRepository;
    private final AccountMapper accountMapper;

    @Override
    public Account loadAccount(AccountId accountId, LocalDateTime baselineDate) {
        ...
    }

    @Override
    public void updateActivities(Account account) {
        ...
    }
}
```

이 경우 생성자를 직접 작성하지 않고 대신 `@RequiredArgsConstructor` 어노테이션을 사용하여 Lombok 라이브러리가 수행하도록 했다. 이 어노테이션은 모든 최종 필드를 인수로 사용하는 생성자를 생성한다.
Spring은 이 생성자를 찾아 필요한 인수 유형의 `@Component` 어노테이션이 있는 클래스를 검색하고 유사한 방식으로 인스턴스화하여 애플리케이션 컨텍스트에 추가한다. 필요한 모든 객체를 사용할 수 있게 되면 마침내 `AccountPersistenceAdapter`의 생성자를 호출하고 결과 객체를 애플리케이션 컨텍스트에 추가한다.
클래스패스 스캐닝은 애플리케이션을 조립하는 매우 편리한 방법이다. 코드베이스 전체에 `@Component` 어노테이션을 몇 개 뿌리고 올바른 생성자를 제공하기만 하면 된다.
Spring이 선택할 자체 스테레오타입 어노테이션을 만들 수도 있다. 예를 들어 `@PersistenceAdapter` 어노테이션을 만들 수 있다.

```java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface PersistenceAdapter {

    @AliasFor(annotation = Component.class)
    String value() default "";
}
```

이 어노테이션은 `@Component`로 메타 어노테이션되어 Spring이 클래스패스 스캐닝 중에 선택해야 함을 알린다. 이제 `@Component` 대신 `@PersistenceAdapter`를 사용하여 영속성 어댑터 클래스를 애플리케이션의 일부로 표시할 수 있다. 이 어노테이션을 사용하면 코드를 읽는 사람들에게 아키텍처를 더 명확하게 만들었다.
그러나 클래스패스 스캐닝 접근 방식에는 단점이 있다. 첫째, 클래스에 프레임워크별 어노테이션을 추가해야 하므로 침습적이다. 클린 아키텍처 강경파라면 코드를 특정 프레임워크에 바인딩하므로 금지된다고 말할 것이다.
일반적인 애플리케이션 개발에서는 클래스에 대한 단일 어노테이션이 그렇게 큰 문제가 아니며 필요한 경우 쉽게 리팩토링할 수 있다고 말하고 싶다.
그러나 다른 개발자가 사용할 라이브러리나 프레임워크를 구축하는 것과 같은 다른 컨텍스트에서는 Spring 프레임워크에 대한 종속성으로 사용자를 번거롭게 하고 싶지 않기 때문에 이것이 금기 사항일 수 있다.
클래스패스 스캐닝 접근 방식의 또 다른 잠재적인 단점은 마법 같은 일이 일어날 수 있다는 것이다.
그리고 마법이란 Spring 전문가가 아니라면 알아내는 데 며칠이 걸릴 수 있는 설명할 수 없는 효과를 일으키는 나쁜 종류의 마법을 의미한다.
마법은 클래스패스 스캐닝이 애플리케이션 조립에 사용하기에 매우 무딘 무기이기 때문에 발생한다. 우리는 단순히 Spring을 애플리케이션의 상위 패키지를 가리키고 이 패키지 내에서 `@Component` 어노테이션이 있는 클래스를 찾도록 지시한다.
애플리케이션 내에 존재하는 모든 단일 클래스를 마음속으로 알고 있는가? 아마도 아닐 것이다. 애플리케이션 컨텍스트에 실제로 원하지 않는 일부 클래스가 있을 수 있다. 아마도 이 클래스는 애플리케이션 컨텍스트를 악의적인 방식으로 조작하여 추적하기 어려운 오류를 일으킬 수도 있다.
조금 더 제어할 수 있는 대안적인 접근 방식을 살펴보자.

### Spring의 Java Config를 통한 조립
클래스패스 스캐닝이 애플리케이션 조립의 큰 망치라면 Spring의 Java Config는 메스이다.² 이 접근 방식은 이 장 앞부분에서 소개된 일반 코드 접근 방식과 유사하지만 덜 지저분하고 모든 것을 직접 코딩할 필요가 없도록 프레임워크를 제공한다.
이 접근 방식에서는 구성 클래스를 생성하며, 각 클래스는 애플리케이션 컨텍스트에 추가될 빈 집합을 구성할 책임이 있다.
예를 들어, 모든 영속성 어댑터를 인스턴스화할 책임이 있는 구성 클래스를 만들 수 있다.

> 2 큰 망치 대 메스: 나처럼 롤플레잉 비디오 게임에서 몬스터를 죽이는 데 너무 많은 시간을 보내지 않고 큰 망치가 무엇인지 모른다면, 큰 망치는 무게가 실린 끝이 있는 막대기로 무기로 사용할 수 있다. 특별히 잘 조준할 필요 없이 많은 피해를 줄 수 있는 매우 무딘 무기이다.

```java
@Configuration
@EnableJpaRepositories
class PersistenceAdapterConfiguration {

    @Bean
    AccountPersistenceAdapter accountPersistenceAdapter(
            AccountRepository accountRepository,
            ActivityRepository activityRepository,
            AccountMapper accountMapper) {
        return new AccountPersistenceAdapter(
                accountRepository,
                activityRepository,
                accountMapper);
    }

    @Bean
    AccountMapper accountMapper() {
        return new AccountMapper();
    }
}
```

`@Configuration` 어노테이션은 이 클래스를 Spring의 클래스패스 스캐닝에 의해 선택될 구성 클래스로 표시한다. 따라서 이 경우에도 여전히 클래스패스 스캐닝을 사용하지만 모든 단일 빈 대신 구성 클래스만 선택하므로 사악한 마법이 일어날 가능성이 줄어든다.
빈 자체는 구성 클래스의 `@Bean` 어노테이션이 있는 팩토리 메서드 내에서 생성된다. 앞의 경우 영속성 어댑터를 애플리케이션 컨텍스트에 추가한다. 생성자에 대한 입력으로 두 개의 리포지토리와 매퍼가 필요하다. Spring은 이러한 객체를 팩토리 메서드에 대한 입력으로 자동으로 제공한다.
하지만 Spring은 리포지토리 객체를 어디서 얻는가? 다른 구성 클래스의 팩토리 메서드에서 수동으로 생성된 경우 Spring은 앞의 코드 예제의 팩토리 메서드에 대한 매개변수로 자동으로 제공한다. 그러나 이 경우 `@EnableJpaRepositories` 어노테이션에 의해 트리거되어 Spring 자체에서 생성된다. Spring Boot가 이 어노테이션을 찾으면 우리가 정의한 모든 Spring Data 리포지토리 인터페이스에 대한 구현을 자동으로 제공한다.
Spring Boot에 익숙하다면 사용자 지정 구성 클래스 대신 기본 애플리케이션 클래스에 `@EnableJpaRepositories` 어노테이션을 추가할 수 있다는 것을 알 수 있다.
그렇다, 가능하지만 영속성이 실제로 필요하지 않은 테스트 내에서 애플리케이션을 시작하더라도 애플리케이션이 시작될 때마다 JPA 리포지토리를 활성화한다. 따라서 이러한 "기능 어노테이션"을 별도의 구성 "모듈"로 이동하면 훨씬 더 유연해지고 항상 전체를 시작할 필요 없이 애플리케이션의 일부를 시작할 수 있다.
`PersistenceAdapterConfiguration` 클래스를 사용하여 영속성 계층에 필요한 모든 객체를 인스턴스화하는 긴밀하게 범위가 지정된 영속성 모듈을 만들었다. 실제로 애플리케이션 컨텍스트에 추가되는 빈을 완전히 제어하면서 Spring의 클래스패스 스캐닝에 의해 자동으로 선택된다.
마찬가지로 웹 어댑터 또는 애플리케이션 계층 내의 특정 모듈에 대한 구성 클래스를 만들 수 있다. 이제 특정 모듈을 포함하지만 다른 모듈의 빈을 모의하는 애플리케이션 컨텍스트를 만들 수 있으므로 테스트에서 뛰어난 유연성을 제공한다. 이러한 각 모듈의 코드를 자체 코드베이스, 패키지 또는 JAR 파일로 푸시할 수도 있다.
또한 이 접근 방식은 클래스패스 스캐닝 접근 방식처럼 코드베이스 전체에 `@Component` 어노테이션을 뿌릴 필요가 없다. 따라서 Spring 프레임워크(또는 다른 프레임워크)에 대한 종속성 없이 애플리케이션 계층을 깨끗하게 유지할 수 있다.
그러나 이 솔루션에는 함정이 있다. 구성 클래스가 생성하는 빈의 클래스(이 경우 영속성 어댑터 클래스)와 동일한 패키지 내에 있지 않으면 해당 클래스는 공개되어야 한다. 가시성을 제한하기 위해 패키지를 모듈 경계로 사용하고 각 패키지 내에 전용 구성 클래스를 만들 수 있다. 그러나 이 방법으로는 12장, 아키텍처 경계 강제하기에서 논의할 하위 패키지를 사용할 수 없다.

### 이것이 유지보수 가능한 소프트웨어를 구축하는 데 어떻게 도움이 되는가?
Spring 및 Spring Boot(및 유사한 프레임워크)는 우리의 삶을 더 쉽게 만들어주는 많은 기능을 제공한다.
주요 기능 중 하나는 애플리케이션 개발자로서 우리가 제공하는 부품(클래스)에서 애플리케이션을 조립하는 것이다.
클래스패스 스캐닝은 매우 편리한 기능이다. Spring에 패키지를 가리키기만 하면 찾은 클래스에서 애플리케이션을 조립한다. 이를 통해 애플리케이션 전체를 생각하지 않고도 신속하게 개발할 수 있다.
그러나 코드베이스가 커지면 투명성이 부족해진다. 어떤 빈이 애플리케이션 컨텍스트에 정확히 로드되는지 알 수 없다. 또한 테스트에서 사용할 애플리케이션 컨텍스트의 격리된 부분을 쉽게 시작할 수 없다.
애플리케이션 조립을 담당하는 전용 구성 요소를 생성함으로써 애플리케이션 코드를 이 책임에서 해방시킬 수 있다(읽기: "변경 이유" – "SOLID"의 "S"를 기억하는가?). 우리는 서로 격리되어 시작할 수 있고 코드베이스 내에서 쉽게 이동할 수 있는 고도로 응집력 있는 모듈로 보상받는다. 평소와 같이 이 구성 요소를 유지 관리하는 데 약간의 추가 시간을 소비하는 대가가 따른다.
이전 장과 이 장에서 "올바른 방법"으로 일을 하는 방법에 대한 다양한 옵션에 대해 많이 이야기했다. 그러나 때로는 "올바른 방법"이 실현 가능하지 않다. 다음 장에서는 지름길, 그에 대한 대가, 그리고 언제 가치가 있는지에 대해 이야기할 것이다.

---

# 11. 의식적으로 지름길 택하기
이 책의 서문에서 나는 우리가 항상 지름길을 택하도록 강요받는다는 사실을 저주했다. 우리는 결코 갚을 기회가 없는 기술 부채의 큰 더미를 쌓는다.
지름길을 막으려면 식별할 수 있어야 한다. 따라서 이 장의 목표는 몇 가지 잠재적인 지름길에 대한 인식을 높이고 그 효과에 대해 논의하는 것이다.
이 정보를 통해 우발적인 지름길을 식별하고 수정할 수 있다. 또는 정당한 경우 지름길의 효과에 의식적으로 동의할 수도 있다.¹

## 지름길이 깨진 창문과 같은 이유
1969년 심리학자 필립 짐바르도는 나중에 깨진 창문 이론으로 알려지게 된 이론을 테스트하기 위해 실험을 수행했다.²
그의 팀은 번호판이 없는 차 한 대를 브롱크스 지역에, 다른 한 대는 팔로 알토의 소위 "더 나은" 지역에 주차했다. 그런 다음 그들은 기다렸다.
브롱크스의 차는 24시간 이내에 귀중한 부품이 모두 도난당했고, 그 후 행인들이 무작위로 파괴하기 시작했다.
팔로 알토의 차는 일주일 동안 아무도 건드리지 않았기 때문에 짐바르도의 팀은 창문을 깨뜨렸다. 그 후부터 그 차는 브롱크스의 차와 비슷한 운명을 맞았고, 지나가는 사람들에 의해 같은 짧은 시간 안에 파괴되었다.
자동차를 약탈하고 파괴하는 데 참여한 사람들은 모든 사회 계층에서 왔으며, 평소에는 법을 준수하고 예의 바른 시민이었던 사람들도 포함되었다.

> 1 건설 공학에 관한 책이나 더 무서운 것은 항공 전자 공학에 관한 책에서 지름길에 대해 이야기하는 것을 상상해보라! 그러나 우리 대부분은 마천루나 비행기의 소프트웨어 버전을 만들고 있지 않다. 그리고 소프트웨어는 부드럽고 하드웨어보다 쉽게 변경할 수 있으므로 때로는 (의식적으로!) 먼저 지름길을 택하고 나중에 (또는 결코) 수정하는 것이 실제로 더 경제적일 수 있다.
> 2 깨진 창문 이론: https://www.theatlantic.com/magazine/archive/1982/03/broken-windows/304465/.


이 인간의 행동은 깨진 창문 이론으로 알려지게 되었다. 내 말로 표현하자면:
무언가가 낡아 보이거나, 손상되었거나, 또는 일반적으로 방치된 것처럼 보이는 즉시, 인간의 뇌는 그것을 더 낡게, 손상되게 만드는 것이 괜찮다고 느낀다.

이 이론은 삶의 여러 영역에 적용된다:
- 기물 파손이 흔한 동네에서는 방치된 차를 약탈하거나 손상시키는 문턱이 낮다.
- 창문이 깨진 차는 "좋은" 동네에서도 더 손상시키는 문턱이 낮다.
- 지저분한 침실에서는 옷을 옷장에 넣는 대신 바닥에 던지는 문턱이 낮다.
- 학생들이 종종 수업을 방해하는 교실에서는 급우들에게 또 다른 농담을 하는 문턱이 낮다.

코드 작업에 적용하면 다음과 같은 의미이다:
- 품질이 낮은 코드베이스에서 작업할 때 품질이 낮은 코드를 더 추가하는 문턱이 낮다.
- 코딩 위반이 많은 코드베이스에서 작업할 때 또 다른 코딩 위반을 추가하는 문턱이 낮다.
- 지름길이 많은 코드베이스에서 작업할 때 또 다른 지름길을 추가하는 문턱이 낮다.

이 모든 것을 염두에 둘 때, 소위 "레거시" 코드베이스의 품질이 시간이 지남에 따라 그렇게 심하게 침식된 것이 정말 놀라운 일인가?

### 깨끗하게 시작할 책임
코드 작업은 실제로 자동차를 약탈하는 것과는 다르지만, 우리 모두는 무의식적으로 깨진 창문 심리학의 영향을 받는다. 이로 인해 가능한 한 적은 지름길과 기술 부채로 프로젝트를 깨끗하게 시작하는 것이 중요하다. 지름길이 스며드는 즉시 깨진 창문 역할을 하여 더 많은 지름길을 유인하기 때문이다.
소프트웨어 프로젝트는 종종 매우 비싸고 장기적인 노력이므로 깨진 창문을 막는 것은 소프트웨어 개발자로서 우리에게 큰 책임이다. 우리가 프로젝트를 끝내는 사람이 아닐 수도 있고 다른 사람이 인수해야 할 수도 있다. 그들에게는 아직 연결고리가 없는 레거시 코드베이스이므로 깨진 창문을 만드는 문턱이 더욱 낮아진다.
그러나 우리가 작업하는 코드 부분이 프로젝트 전체에 그다지 중요하지 않거나, 프로토타이핑 중이거나, 경제적인 이유로 지름길이 실용적인 것이라고 결정하는 경우가 있다.
마이클 나이가드가 그의 블로그에서 제안한 것처럼 아키텍처 결정 기록(ADR)의 형태로 이러한 의식적으로 추가된 지름길을 문서화하는 데 세심한 주의를 기울여야 한다.³ 우리는 미래의 우리 자신과 후임자들에게 그것을 빚지고 있다. 팀의 모든 구성원이 이 문서를 알고 있다면, 팀은 지름길이 의식적으로 그리고 좋은 이유로 취해졌다는 것을 알기 때문에 깨진 창문 효과를 줄일 것이다.
다음 섹션에서는 이 책에서 제시된 헥사고날 아키텍처 스타일에서 지름길로 간주될 수 있는 패턴에 대해 각각 논의한다. 지름길의 효과와 그것을 택하는 것에 찬성하고 반대하는 주장을 살펴볼 것이다.

### 유스케이스 간 모델 공유
5장, 유스케이스 구현하기에서 나는 다른 유스케이스는 다른 입력 및 출력 모델을 가져야 한다고 주장했다. 즉, 입력 매개변수의 유형과 반환 값의 유형이 달라야 한다는 의미이다.
그림 11.1은 두 유스케이스가 동일한 입력 모델을 공유하는 예를 보여준다.

![[tom_hombergs_68.png]]
*그림 11.1 – 유스케이스 간에 입력 또는 출력 모델을 공유하면 유스케이스 간에 결합이 발생한다*

> 3 아키텍처 결정 기록: http://thinkrelevance.com/blog/2011/11/15/documenting-architecture-decisions.

이 경우 공유의 효과는 `SendMoneyUseCase`와 `RevokeActivityUseCase`가 서로 결합된다는 것이다. 공유된 `SendMoneyCommand` 클래스 내에서 무언가를 변경하면 두 유스케이스 모두에 영향을 미친다. 그들은 단일 책임 원칙(3장, 의존성 역전에서 논의된 "단일 변경 이유 원칙"으로 명명되어야 함)의 관점에서 변경 이유를 공유한다. 두 유스케이스가 동일한 출력 모델을 공유하는 경우에도 마찬가지이다.
유스케이스가 기능적으로 결합되어 있는 경우, 즉 특정 요구 사항을 공유하는 경우 유스케이스 간에 입력 및 출력 모델을 공유하는 것이 유효하다. 이 경우 특정 세부 정보를 변경하면 두 유스케이스 모두에 영향을 미치기를 실제로 원한다.
그러나 두 유스케이스가 서로 독립적으로 발전할 수 있어야 하는 경우 이것은 지름길이다. 이 경우, 시작 시 동일하게 보이더라도 입력 및 출력 클래스를 복제하는 것을 의미하더라도 처음부터 유스케이스를 분리해야 한다.
따라서 유사한 개념을 중심으로 여러 유스케이스를 구축할 때 유스케이스가 서로 독립적으로 발전해야 하는지 정기적으로 질문하는 것이 좋다. 대답이 "예"가 되는 즉시 입력 및 출력 모델을 분리할 때이다.

### 도메인 엔티티를 입력 또는 출력 모델로 사용
`Account` 도메인 엔티티와 인커밍 포트 `SendMoneyUseCase`가 있는 경우, 그림 11.2와 같이 엔티티를 인커밍 포트의 입력 및/또는 출력 모델로 사용하고 싶을 수 있다.

![[tom_hombergs_69.png]]
*그림 11.2 – 도메인 엔티티를 유스케이스의 입력 또는 출력 모델로 사용하면 도메인 엔티티가 유스케이스에 결합된다*

인커밍 포트는 도메인 엔티티에 대한 종속성을 갖는다. 이 결과 `Account` 엔티티가 변경될 또 다른 이유를 추가했다는 것이다.
잠깐, `Account` 엔티티는 `SendMoneyUseCase` 인커밍 포트에 대한 종속성이 없다(그 반대이다). 그렇다면 어떻게 인커밍 포트가 엔티티에 대한 변경 이유가 될 수 있는가?
유스케이스에서 현재 `Account` 엔티티에서 사용할 수 없는 계정에 대한 일부 정보가 필요하다고 가정하자. 그러나 이 정보는 궁극적으로 `Account` 엔티티에 저장되지 않고 다른 도메인 또는 바운디드 컨텍스트에 저장된다. 그럼에도 불구하고 이미 유스케이스 인터페이스에서 사용할 수 있기 때문에 `Account` 엔티티에 새 필드를 추가하고 싶을 수 있다.
간단한 생성 또는 업데이트 유스케이스의 경우, 엔티티가 데이터베이스에 상태를 유지하는 데 필요한 정보를 정확하게 포함하므로 유스케이스 인터페이스의 도메인 엔티티가 괜찮을 수 있다.
유스케이스가 데이터베이스의 몇 가지 필드를 업데이트하는 것뿐만 아니라 풍부한 도메인 엔티티에 도메인 로직의 일부를 위임할 수 있는 더 복잡한 도메인 로직을 구현하는 즉시, 유스케이스 인터페이스에 대한 전용 입력 및 출력 모델을 사용해야 한다. 유스케이스의 변경 사항이 도메인 엔티티에 전파되는 것을 원하지 않기 때문이다.
이 지름길을 위험하게 만드는 것은 많은 유스케이스가 간단한 생성 또는 업데이트 유스케이스로 시작하여 시간이 지남에 따라 복잡한 도메인 로직의 괴물이 된다는 사실이다. 이것은 최소 실행 가능 제품으로 시작하여 앞으로 나아가면서 복잡성을 추가하는 애자일 환경에서 특히 그렇다. 따라서 처음에 도메인 엔티티를 입력 모델로 사용했다면, 도메인 엔티티와 독립적인 전용 입력 모델로 교체할 시점을 찾아야 한다.

### 인커밍 포트 건너뛰기
아웃고잉 포트는 애플리케이션 계층과 아웃고잉 어댑터 간의 종속성을 역전시키는 데 필요하지만(종속성을 안쪽으로 향하게 하기 위해), 종속성 역전을 위해 인커밍 포트는 필요하지 않다. 그림 11.3과 같이 인커밍 어댑터가 인커밍 포트 없이 애플리케이션 또는 도메인 서비스에 직접 액세스하도록 결정할 수 있다.

![[tom_hombergs_70.png]]
*그림 11.3 – 인커밍 포트가 없으면 도메인 로직에 대한 명확하게 표시된 진입점을 잃게 된다*

인커밍 포트를 제거함으로써 인커밍 어댑터와 애플리케이션 계층 간의 추상화 계층을 줄였다. 추상화 계층을 제거하는 것은 보통 기분이 좋다.
그러나 인커밍 포트는 애플리케이션 코어에 대한 진입점을 정의한다. 일단 제거하면 특정 사용 사례를 구현하기 위해 어떤 서비스 메서드를 호출할 수 있는지 알아내기 위해 애플리케이션 내부에 대해 더 많이 알아야 한다. 전용 인커밍 포트를 유지함으로써 애플리케이션에 대한 진입점을 한눈에 식별할 수 있다. 이것은 특히 새로운 개발자가 코드베이스에서 자신의 위치를 파악하는 것을 쉽게 만든다.
인커밍 포트를 유지하는 또 다른 이유는 아키텍처를 쉽게 강제할 수 있다는 것이다. 12장, 아키텍처 경계 강제하기에서 배울 강제 옵션을 사용하면 인커밍 어댑터가 애플리케이션 서비스가 아닌 인커밍 포트만 호출하도록 할 수 있다. 이것은 애플리케이션 계층으로의 모든 진입점을 매우 의식적인 결정으로 만든다. 더 이상 인커밍 어댑터에서 호출되도록 의도되지 않은 서비스 메서드를 우연히 호출할 수 없다.
애플리케이션이 충분히 작거나 단일 인커밍 어댑터만 있고 인커밍 포트의 도움 없이 전체 제어 흐름을 파악할 수 있다면 인커밍 포트 없이 할 수 있다. 그러나 애플리케이션이 작게 유지되거나 평생 동안 단일 인커밍 어댑터만 가질 것이라고 얼마나 자주 말할 수 있는가?

### 서비스 건너뛰기
인커밍 포트 외에도 특정 사용 사례의 경우 그림 11.4와 같이 서비스 계층 전체를 건너뛰고 싶을 수 있다.

![[tom_hombergs_71.png]]
*그림 11.4 – 서비스가 없으면 코드베이스에 더 이상 사용 사례 표현이 없다*

여기서 아웃고잉 어댑터 내의 `AccountPersistenceAdapter` 클래스는 인커밍 포트를 직접 구현하고 일반적으로 인커밍 포트를 구현하는 서비스를 대체한다.
이 경우 서비스는 일반적으로 생성, 업데이트 또는 삭제 요청을 도메인 로직을 추가하지 않고 영속성 어댑터로 전달하기만 하므로 간단한 CRUD 사용 사례에 대해 이 작업을 수행하는 것은 매우 유혹적이다. 전달하는 대신 영속성 어댑터가 사용 사례를 직접 구현하도록 할 수 있다.
그러나 이것은 인커밍 어댑터와 아웃고잉 어댑터 간에 공유 모델이 필요하며, 이 경우 `Account` 도메인 엔티티이므로 일반적으로 이전에 설명한 대로 도메인 모델을 입력 모델로 사용한다는 것을 의미한다.
또한 애플리케이션 코어 내에 더 이상 사용 사례 표현이 없다. CRUD 사용 사례가 시간이 지남에 따라 더 복잡해지면 사용 사례가 이미 거기에 구현되었기 때문에 도메인 로직을 아웃고잉 어댑터에 직접 추가하고 싶을 수 있다. 이것은 도메인 로직을 분산시켜 찾고 유지 관리하기 어렵게 만든다.
결국 상용구 통과 서비스를 방지하기 위해 간단한 CRUD 사용 사례에 대해 서비스를 건너뛰도록 선택할 수 있다. 그러나 팀은 사용 사례가 엔티티를 생성, 업데이트 또는 삭제하는 것 이상을 수행할 것으로 예상되는 즉시 서비스를 도입하기 위한 명확한 지침을 개발해야 한다.

### 이것이 유지보수 가능한 소프트웨어를 구축하는 데 어떻게 도움이 되는가?
경제적인 관점에서 지름길이 의미가 있는 경우가 있다. 이 장에서는 지름길을 택할지 여부를 결정하는 데 도움이 되도록 일부 지름길이 가질 수 있는 결과에 대한 몇 가지 통찰력을 제공했다.
논의에 따르면 간단한 CRUD 사용 사례에 대해 지름길을 도입하는 것이 유혹적이라는 것을 보여준다. 왜냐하면 전체 아키텍처를 구현하는 것이 과잉처럼 느껴지기 때문이다(그리고 지름길은 지름길처럼 느껴지지 않는다).
그러나 모든 애플리케이션은 작게 시작하므로 팀이 사용 사례가 CRUD 상태에서 벗어날 때 동의하는 것이 매우 중요하다. 그래야만 팀이 장기적으로 더 유지보수하기 쉬운 아키텍처로 지름길을 대체할 수 있다.
일부 사용 사례는 CRUD 상태에서 결코 벗어나지 않을 것이다. 그들에게는 유지 관리 오버헤드가 실제로 수반되지 않으므로 지름길을 영원히 유지하는 것이 더 실용적일 수 있다.
어떤 경우든, 우리(또는 우리의 후임자)가 미래에 결정을 재평가할 수 있도록 아키텍처와 특정 지름길을 선택한 이유에 대한 결정을 문서화해야 한다.
때로는 지름길이 허용될 수 있지만, 우리는 의식적으로 지름길을 택하기로 결정하고 싶다. 즉, 일을 하는 "올바른" 방법을 하나 정의하고 이 방법을 강제하여 좋은 이유가 있는 경우 그 방법에서 벗어날 수 있도록 해야 한다. 다음 장에서는 아키텍처를 강제하는 몇 가지 방법을 살펴볼 것이다.

---

# 12. 아키텍처 경계 강제하기
이전 장에서 아키텍처에 대해 많이 이야기했으며, 코드를 만들고 배치하는 방법에 대한 결정을 내리는 데 도움이 되는 목표 아키텍처를 갖는 것이 좋다.
그러나 모든 플레이 규모 이상의 소프트웨어 프로젝트에서는 아키텍처가 시간이 지남에 따라 침식되는 경향이 있다. 계층 간의 경계가 약해지고 코드를 테스트하기가 더 어려워지며 일반적으로 새로운 기능을 구현하는 데 점점 더 많은 시간이 필요하다.
이 장에서는 아키텍처 내의 경계를 강제하고 따라서 아키텍처 침식을 방지하기 위해 취할 수 있는 몇 가지 조치에 대해 논의할 것이다.

## 경계와 종속성
아키텍처 경계를 강제하는 다양한 방법에 대해 이야기하기 전에, 아키텍처 내에서 경계가 어디에 있는지, 그리고 경계를 강제하는 것이 실제로 무엇을 의미하는지 논의해 보자.

![[tom_hombergs_72.png]]
*그림 12.1 – 아키텍처 경계를 강제한다는 것은 종속성이 올바른 방향을 가리키도록 강제하는 것을 의미한다 (점선 화살표는 우리 아키텍처에 따라 허용되지 않는 종속성을 표시한다)*

그림 12.1은 헥사고날 아키텍처의 요소가 3장, 종속성 역전에서 소개된 일반적인 클린 아키텍처 접근 방식과 유사하게 네 개의 계층에 어떻게 분산될 수 있는지를 보여준다.
가장 안쪽 계층에는 도메인 엔티티와 도메인 서비스가 포함된다. 그 주위의 애플리케이션 계층은 일반적으로 애플리케이션 서비스를 통해 사용 사례를 구현하기 위해 해당 엔티티와 서비스에 액세스할 수 있다.
어댑터는 인커밍 포트를 통해 해당 서비스에 액세스하거나 아웃고잉 포트를 통해 해당 서비스에 의해 액세스된다. 마지막으로, 구성 계층에는 어댑터 및 서비스 객체를 생성하고 종속성 주입 메커니즘에 제공하는 팩토리가 포함된다.
앞의 그림에서 아키텍처 경계는 매우 명확해진다. 각 계층과 그 다음 안쪽 및 바깥쪽 이웃 사이에 경계가 있다. 종속성 규칙에 따르면 이러한 계층 경계를 넘는 종속성은 항상 안쪽을 가리켜야 한다.
이 장은 종속성 규칙을 강제하는 방법에 관한 것이다. 우리는 그림에서 점선 화살표와 같이 잘못된 방향을 가리키는 불법적인 종속성이 없는지 확인하고 싶다.

### 가시성 수정자
객체 지향 언어 일반, 특히 Java가 경계를 강제하기 위해 제공하는 가장 기본적인 도구부터 시작하자: 가시성 수정자.
가시성 수정자는 지난 몇 년 동안 내가 수행한 거의 모든 신입 사원 면접에서 주제였다. 나는 면접관에게 Java가 제공하는 가시성 수정자와 그 차이점이 무엇인지 물어보곤 했다.
대부분의 면접관은 public, protected 및 private 수정자만 나열한다. 그들 중 소수만이 패키지-비공개(또는 기본) 수정자를 알고 있다. 이것은 면접관이 이전 지식에서 추상화할 수 있는지 알아보기 위해 그러한 가시성 수정자가 왜 의미가 있는지에 대한 몇 가지 질문을 할 수 있는 좋은 기회이다.
그렇다면 패키지-비공개 수정자가 왜 그렇게 중요한 수정자인가? Java 패키지를 사용하여 클래스를 응집력 있는 "모듈"로 그룹화할 수 있기 때문이다. 이러한 모듈 내의 클래스는 서로 액세스할 수 있지만 패키지 외부에서는 액세스할 수 없다. 그런 다음 특정 클래스를 공개하여 모듈에 대한 진입점 역할을 하도록 선택할 수 있다. 이렇게 하면 잘못된 방향을 가리키는 종속성을 도입하여 종속성 규칙을 우연히 위반할 위험이 줄어든다.
4장, 코드 구성에서 논의된 패키지 구조를 가시성 수정자를 염두에 두고 다시 살펴보자.

```bash
buckpal
├── adapter
│   ├── in
│   │   └── web
│   │       └── o SendMoneyController
│   └── out
│       └── persistence
│           ├── o AccountPersistenceAdapter
│           └── o SpringDataAccountRepository
├── application
│   ├── domain
│   │   ├── model
│   │   │   ├── + Account
│   │   │   └── + Activity
│   │   └── service
│   │       └── o SendMoneyService
│   └── port
│       ├── in
│       │   └── + SendMoneyUseCase
│       └── out
│           └── + UpdateAccountStatePort
└── common
```

영속성 패키지의 클래스는 외부 세계에서 액세스할 필요가 없기 때문에 패키지-비공개(위 트리에서 o로 표시)로 만들 수 있다. 영속성 어댑터는 구현하는 출력 포트를 통해 액세스된다. 같은 이유로 `SendMoneyService` 클래스를 패키지-비공개로 만들 수 있다. 종속성 주입 메커니즘은 일반적으로 리플렉션을 사용하여 클래스를 인스턴스화하므로 패키지-비공개이더라도 여전히 해당 클래스를 인스턴스화할 수 있다.
그러나 Spring을 사용하면 이 접근 방식은 10장, 애플리케이션 조립하기에서 논의된 클래스패스 스캐닝 접근 방식을 사용하는 경우에만 작동한다. 다른 접근 방식에서는 이러한 객체의 인스턴스를 직접 생성해야 하므로 공개 액세스가 필요하기 때문이다.
예제의 나머지 클래스는 아키텍처에 의해 정의된 대로 공개되어야 한다( + 로 표시됨): 도메인 패키지는 다른 계층에서 액세스할 수 있어야 하고 애플리케이션 계층은 웹 및 영속성 어댑터에서 액세스할 수 있어야 한다.
패키지-비공개 수정자는 클래스가 몇 개 안 되는 작은 모듈에 적합하다.
그러나 패키지가 특정 수의 클래스에 도달하면 동일한 패키지에 너무 많은 클래스가 있어 혼란스러워진다. 이 경우 코드를 더 쉽게 찾을 수 있도록 하위 패키지를 만드는 것을 좋아한다(그리고 미적 감각을 만족시키기 위해 인정한다). 여기서 패키지-비공개 수정자는 Java가 하위 패키지를 다른 패키지로 취급하고 하위 패키지의 패키지-비공개 멤버에 액세스할 수 없기 때문에 실패한다. 따라서 하위 패키지의 멤버는 공개되어야 하며 외부 세계에 노출되어 아키텍처가 불법적인 종속성에 취약해진다.

### 컴파일 후 적합성 함수
클래스에서 공개 수정자를 사용하는 즉시 컴파일러는 종속성의 방향이 아키텍처에 따라 잘못된 방향을 가리키더라도 다른 클래스가 사용하도록 허용한다.
이러한 경우 컴파일러가 도움이 되지 않으므로 종속성 규칙이 위반되지 않았는지 확인하는 다른 방법을 찾아야 한다.
한 가지 방법은 아키텍처를 입력으로 받아 특정 측면에 대한 적합성을 결정하는 함수인 적합성 함수를 도입하는 것이다. 우리 경우, 적합성은 종속성 규칙이 위반되지 않음으로 정의된다.
이상적으로는 컴파일러가 컴파일 중에 적합성 함수를 실행하지만, 그렇지 않은 경우 코드가 이미 컴파일된 후 런타임에 이러한 함수를 실행할 수 있다. 이러한 런타임 검사는 지속적인 통합 빌드 내에서 자동화된 테스트 중에 가장 잘 실행된다.
Java에 대한 이러한 종류의 아키텍처 적합성 함수를 지원하는 도구는 ArchUnit이다.¹ 무엇보다도 ArchUnit은 종속성이 예상 방향을 가리키는지 확인하는 API를 제공한다. 위반을 발견하면 예외를 발생시킨다. JUnit과 같은 단위 테스트 프레임워크 기반의 테스트 내에서 실행하는 것이 가장 좋으며, 종속성 위반 시 테스트가 실패하도록 만든다.
ArchUnit을 사용하면 이제 각 계층에 이전 섹션에서 논의된 패키지 구조에 정의된 자체 패키지가 있다고 가정하고 계층 간의 종속성을 확인할 수 있다. 예를 들어, 도메인 모델에서 도메인 모델 외부의 어떤 것에도 종속성이 없는지 확인할 수 있다.

> 1 ArchUnit: https://github.com/TNG/ArchUnit.

```java
class DependencyRuleTests {

    @Test
    void domainModelDoesNotDependOnOutside() {
        noClasses()
                .that()
                .resideInAPackage("buckpal.application.domain.model..")
                .should()
                .dependOnClassesThat()
                .resideOutsideOfPackages(
                        "buckpal.application.domain.model..",
                        "lombok..",
                        "java..")
                .check(new ClassFileImporter()
                        .importPackages("buckpal.."));
    }
}
```

이 규칙은 그림 12.2에 시각화된 종속성 규칙을 검증한다.

![[tom_hombergs_75.png]]
*그림 12.2 – 우리 도메인 모델은 자체 및 일부 라이브러리 패키지에 액세스할 수 있지만, 예를 들어 어댑터를 포함하는 패키지와 같이 다른 패키지의 코드에는 액세스할 수 없다 (https://www.archunit.org/use-cases의 다이어그램에서 영감을 받음)*

앞의 규칙의 문제점은 도메인 모델에서 일부 라이브러리 코드를 사용하는 경우, 도입하는 모든 종속성에 대해 이 규칙에 예외를 추가해야 한다는 것이다(예제에서 lombok 및 java에 대해 수행한 것처럼). 14장, 소프트웨어 아키텍처에 대한 구성 요소 기반 접근 방식에서 이 문제가 없는 규칙을 볼 것이다.
약간의 작업을 통해 ArchUnit API 위에 일종의 도메인 특정 언어(DSL)를 만들어 헥사고날 아키텍처 내의 모든 관련 패키지를 지정한 다음 해당 패키지 간의 모든 종속성이 올바른 방향을 가리키는지 자동으로 확인할 수도 있다.

```java
class DependencyRuleTests {

    @Test
    void validateHexagonalArchitecture() {
        HexagonalArchitecture.basePackage("buckpal")
                .withApplicationLayer("application")
                .domainModel("domain.model")
                .services("domain.service")
                .incomingPorts("port.in")
                .outgoingPorts("port.out")
                .and()
                .withAdaptersLayer("adapter")
                .incoming("in.web")
                .outgoing("out.persistence")
                .and()
                .withConfiguration("configuration")
                .check(new(new ClassFileImporter()
                        .importPackages("buckpal.."));
    }
}
```

앞의 코드 예제에서는 먼저 애플리케이션의 상위 패키지를 지정한다. 그런 다음 도메인, 어댑터, 애플리케이션 및 구성 계층에 대한 하위 패키지를 지정한다. `check()`에 대한 최종 호출은 패키지 종속성이 종속성 규칙에 따라 유효한지 확인하는 일련의 검사를 실행한다. 이 헥사고날 아키텍처 DSL에 대한 코드는 GitHub에서 사용할 수 있으므로 직접 사용해 볼 수 있다.²
앞의 것과 같은 컴파일 후 검사는 불법적인 종속성과 싸우는 데 큰 도움이 될 수 있지만, 안전하지는 않다. 예를 들어, 앞의 코드 예제에서 패키지 이름 `buckpal`을 잘못 입력하면 테스트에서 클래스를 찾지 못하므로 종속성 위반이 발생하지 않는다. 단일 오타 또는 더 중요한 것은 패키지 이름을 바꾸는 단일 리팩토링으로 인해 전체 테스트가 쓸모없게 될 수 있다.
이러한 테스트를 리팩토링에 안전하게 만들거나 적어도 리팩토링으로 인해 깨졌을 때 실패하도록 노력해야 한다. 앞의 예에서는 예를 들어 언급된 패키지 중 하나가 존재하지 않을 때(이름이 바뀌었기 때문에) 테스트를 실패하게 할 수 있다.

> 2 ArchUnit용 헥사고날 아키텍처 DSL: https://github.com/thombergs/buckpal/blob/master/src/test/java/io/reflectoring/buckpal/archunit/HexagonalArchitecture.java.

### 빌드 아티팩트
지금까지 코드베이스 내에서 아키텍처 경계를 구분하는 유일한 도구는 패키지였다.
모든 코드는 동일한 모놀리식 빌드 아티팩트의 일부였다.
빌드 아티팩트는 (바람직하게는 자동화된) 빌드 프로세스의 결과이다. Java 세계에서 가장 인기 있는 빌드 도구는 현재 Maven과 Gradle이다. 따라서 지금까지 단일 Maven 또는 Gradle 빌드 스크립트가 있었고 Maven 또는 Gradle을 호출하여 애플리케이션 코드를 컴파일, 테스트 및 단일 JAR 파일로 패키징할 수 있었다고 상상해보라.
빌드 도구의 주요 기능은 종속성 해결이다. 특정 코드베이스를 빌드 아티팩트로 변환하기 위해 빌드 도구는 먼저 코드베이스가 종속된 모든 아티팩트를 사용할 수 있는지 확인한다. 그렇지 않은 경우 아티팩트 리포지토리에서 로드하려고 시도한다. 실패하면 코드를 컴파일하기 전에 빌드가 오류와 함께 실패한다.
이를 활용하여 아키텍처의 모듈과 계층 간의 종속성(따라서 경계)을 강제할 수 있다. 이러한 각 모듈 또는 계층에 대해 자체 코드베이스와 자체 빌드 아티팩트(JAR 파일)가 있는 별도의 빌드 모듈을 만든다. 각 모듈의 빌드 스크립트에서 아키텍처에 따라 허용되는 다른 모듈에 대한 종속성만 지정한다. 개발자는 클래스가 클래스패스에서 사용할 수조차 없고 컴파일 오류가 발생하기 때문에 더 이상 실수로 불법적인 종속성을 만들 수 없다.

![[tom_hombergs_77.png]]
*그림 12.3 – 불법적인 종속성을 금지하기 위해 아키텍처를 여러 빌드 아티팩트로 나누는 다양한 방법*

그림 12.3은 아키텍처를 별도의 빌드 아티팩트로 나누는 불완전한 옵션 집합을 보여준다.
왼쪽에서 시작하여 구성, 어댑터 및 애플리케이션 계층에 대한 별도의 빌드 아티팩트가 있는 기본 3모듈 빌드를 볼 수 있다. 구성 모듈은 어댑터 모듈에 액세스할 수 있으며, 어댑터 모듈은 다시 애플리케이션 모듈에 액세스할 수 있다. 구성 모듈은 암시적, 전이적 종속성으로 인해 애플리케이션 모듈에 액세스할 수도 있다. 어댑터 모듈에는 웹 어댑터와 영속성 어댑터가 포함된다. 즉, 빌드 도구는 해당 어댑터 간의 종속성을 금지하지 않는다. 해당 어댑터 간의 종속성은 종속성 규칙에 의해 엄격하게 금지되지는 않지만(두 어댑터 모두 동일한 외부 계층 내에 있으므로), 대부분의 경우 어댑터를 서로 격리하는 것이 합리적이다. 결국, 우리는 일반적으로 영속성 계층의 변경 사항이 웹 계층으로 유출되는 것을 원하지 않는다(단일 책임 원칙을 기억하라!). 다른 유형의 어댑터, 예를 들어 애플리케이션을 특정 타사 API에 연결하는 어댑터에 대해서도 마찬가지이다. 우리는 해당 API의 세부 정보가 어댑터 간에 우발적인 종속성을 추가하여 다른 어댑터로 유출되는 것을 원하지 않는다.
따라서 그림 12.3의 두 번째 열에 표시된 것처럼 단일 어댑터 모듈을 각 어댑터에 대해 하나씩 여러 빌드 모듈로 분할할 수 있다.
다음으로, 애플리케이션 모듈을 더 분할하기로 결정할 수 있다. 현재 애플리케이션에 대한 인커밍 및 아웃고잉 포트, 해당 포트를 구현하거나 사용하는 서비스, 그리고 도메인 로직의 많은 부분을 포함해야 하는 도메인 엔티티가 포함되어 있다.
도메인 엔티티가 포트 내에서 전송 객체로 사용되지 않도록 결정하면(즉, 9장, 경계 간 매핑의 매핑 없음 전략을 허용하지 않으려는 경우), 종속성 역전 원칙을 적용하고 포트 인터페이스만 포함하는 별도의 `api` 모듈을 꺼낼 수 있다(그림 12.3의 세 번째 열). 어댑터 모듈과 애플리케이션 모듈은 `api` 모듈에 액세스할 수 있지만 그 반대는 아니다. `api` 모듈은 도메인 엔티티에 액세스할 수 없으며 포트 인터페이스 내에서 사용할 수 없다. 또한 어댑터는 더 이상 엔티티 및 서비스에 직접 액세스할 수 없으므로 포트를 통과해야 한다.
한 걸음 더 나아가 `api` 모듈을 두 개로 분할하여 한 부분은 인커밍 포트만 포함하고 다른 부분은 아웃고잉 포트만 포함하도록 할 수도 있다(그림 12.3의 네 번째 열). 이렇게 하면 입력 또는 아웃고잉 포트에만 종속성을 선언하여 특정 어댑터가 인커밍 어댑터인지 아웃고잉 어댑터인지 매우 명확하게 할 수 있다.
또한 애플리케이션 모듈을 더 분할하여 서비스만 포함하는 모듈과 도메인 모델만 포함하는 모듈을 만들 수 있다. 이렇게 하면 도메인 모델이 서비스에 액세스하지 않도록 하고, 다른 애플리케이션(다른 사용 사례 및 따라서 다른 서비스 포함)이 도메인 빌드 아티팩트에 대한 종속성을 간단히 선언하여 동일한 도메인 모델을 사용할 수 있도록 한다.
그림 12.3은 애플리케이션을 빌드 모듈로 나누는 여러 가지 방법이 있으며, 그림에 표시된 네 가지 방법 외에도 물론 더 많은 방법이 있음을 보여준다. 요점은 모듈을 더 잘게 자를수록 모듈 간의 종속성을 더 강력하게 제어할 수 있다는 것이다. 그러나 더 잘게 자를수록 9장, 경계 간 매핑에서 소개된 매핑 전략 중 하나를 강제하여 해당 모듈 간에 더 많은 매핑을 수행해야 한다.

그 외에도 빌드 모듈로 아키텍처 경계를 구분하는 것은 간단한 패키지를 경계로 사용하는 것보다 여러 가지 장점이 있다.
1.  첫째, 빌드 도구는 순환 종속성을 절대적으로 싫어한다. 순환 종속성은 원 내의 한 모듈의 변경이 잠재적으로 원 내의 다른 모든 모듈의 변경을 의미하기 때문에 나쁘다. 이는 단일 책임 원칙을 위반하는 것이다. 빌드 도구는 순환 종속성을 해결하려고 시도하는 동안 무한 루프에 빠지기 때문에 순환 종속성을 허용하지 않는다. 따라서 빌드 모듈 간에 순환 종속성이 없는지 확인할 수 있다. 반면에 Java 컴파일러는 두 개 이상의 패키지 간에 순환 종속성이 있는지 전혀 신경 쓰지 않는다.
2.  둘째, 빌드 모듈을 사용하면 다른 모듈을 고려하지 않고 특정 모듈 내에서 격리된 코드 변경이 가능하다. 어댑터와 애플리케이션 계층이 동일한 빌드 모듈 내에 있는 경우 특정 어댑터에서 일시적인 컴파일 오류를 일으키는 애플리케이션 계층에서 주요 리팩토링을 수행해야 한다고 상상해보라. 일부 IDE는 테스트에 어댑터가 컴파일될 필요가 없음에도 불구하고 애플리케이션 계층에서 테스트를 실행하기 전에 어댑터의 모든 컴파일 오류를 수정해야 한다고 주장할 것이다. 그러나 애플리케이션 계층이 자체 빌드 모듈에 있는 경우 IDE는 현재 어댑터에 신경 쓰지 않으며 원하는 대로 애플리케이션 계층 테스트를 실행할 수 있다. Maven 또는 Gradle로 빌드 프로세스를 실행하는 경우에도 마찬가지이다. 두 계층이 모두 동일한 빌드 모듈에 있는 경우 어느 한 계층의 컴파일 오류로 인해 빌드가 실패한다. 따라서 여러 빌드 모듈을 사용하면 각 모듈에서 격리된 변경이 가능하다. 각 모듈을 자체 코드 리포지토리에 넣어 다른 팀이 다른 모듈을 유지 관리하도록 선택할 수도 있다.
3.  마지막으로, 빌드 스크립트에 명시적으로 선언된 각 모듈 간 종속성을 사용하면 새 종속성을 추가하는 것이 우발적인 것이 아니라 의식적인 행위가 된다. 현재 액세스할 수 없는 특정 클래스에 액세스해야 하는 개발자는 빌드 스크립트에 추가하기 전에 종속성이 정말 합리적인지 여부에 대해 약간의 생각을 할 것이다.

이러한 장점은 빌드 스크립트를 유지 관리하는 데 추가 비용이 들기 때문에 아키텍처가 다른 빌드 모듈로 분할되기 전에 다소 안정적이어야 한다.
또한 빌드 모듈은 시간이 지남에 따라 변경하기가 덜 유연한 경향이 있다. 일단 선택되면 처음에 정의한 모듈을 고수하는 경향이 있다. 모듈 분할이 처음부터 올바르지 않은 경우 리팩토링의 추가 노력으로 인해 나중에 수정할 가능성이 적다. 모든 코드가 단일 빌드 모듈 내에 있을 때 리팩토링이 더 쉽다.

### 이것이 유지보수 가능한 소프트웨어를 구축하는 데 어떻게 도움이 되는가?
소프트웨어 아키텍처는 기본적으로 아키텍처 요소 간의 종속성을 관리하는 것이다. 종속성이 큰 진흙 덩어리가 되면 아키텍처도 큰 진흙 덩어리가 된다.
따라서 시간이 지남에 따라 아키텍처를 보존하려면 종속성이 올바른 방향을 가리키도록 지속적으로 확인해야 한다.
새 코드를 생성하거나 기존 코드를 리팩토링할 때 패키지 구조를 염두에 두고 가능한 경우 패키지-비공개 가시성을 사용하여 패키지 외부에서 액세스해서는 안 되는 클래스에 대한 종속성을 피해야 한다.
단일 빌드 모듈 내에서 아키텍처 경계를 강제해야 하고 패키지 구조가 허용하지 않기 때문에 패키지-비공개 수정자가 작동하지 않는 경우 ArchUnit과 같은 컴파일 후 도구를 사용할 수 있다.
아키텍처가 충분히 안정적이라고 느낄 때마다 아키텍처 요소를 자체 빌드 모듈로 추출해야 한다. 이렇게 하면 종속성을 명시적으로 제어할 수 있기 때문이다.
세 가지 접근 방식을 모두 결합하여 아키텍처 경계를 강제하고 따라서 코드베이스를 시간이 지남에 따라 유지보수할 수 있도록 유지할 수 있다.
다음 장에서는 아키텍처 경계를 계속 탐색하지만 다른 관점에서 볼 것이다. 동일한 애플리케이션에서 여러 도메인(또는 바운디드 컨텍스트)을 관리하면서 그들 사이의 경계를 명확하게 유지하는 방법에 대해 생각해 볼 것이다.

---

# 13. 여러 바운디드 컨텍스트 관리하기
많은 애플리케이션은 하나 이상의 도메인 또는 도메인 주도 설계 언어를 고수하기 위해 하나 이상의 바운디드 컨텍스트로 구성된다. "바운디드 컨텍스트"라는 용어는 다른 도메인 간에 경계가 있어야 함을 알려준다. 다른 도메인 간에 경계가 없으면 이러한 도메인의 클래스 간에 종속성에 대한 제한이 없다. 결국 도메인 간에 종속성이 증가하여 함께 결합된다. 이 결합은 도메인이 더 이상 격리되어 발전할 수 없고 함께만 발전할 수 있음을 의미한다. 우리는 애초에 코드를 다른 도메인으로 분리하지 않았을 수도 있다!
코드를 다른 도메인으로 분리하는 전체 이유는 이러한 도메인이 격리되어 발전할 수 있도록 하기 위함이다. 이것은 3장, 종속성 역전에서 논의된 단일 책임 원칙의 적용이다. 이번에는 단일 클래스의 책임에 대해 이야기하는 것이 아니라 바운디드 컨텍스트를 구성하는 전체 클래스 그룹의 책임에 대해 이야기하고 있다. 한 바운디드 컨텍스트의 책임이 변경되면 다른 바운디드 컨텍스트에 대한 코드를 변경하고 싶지 않다!
바운디드 컨텍스트를 관리하는 것, 즉 그들 사이의 경계를 명확하게 유지하는 것은 소프트웨어 엔지니어링의 주요 과제 중 하나이다. 개발자가 소위 "레거시 소프트웨어"와 연관시키는 많은 고통은 불분명한 경계에서 비롯된다. 그리고 소프트웨어가 "레거시"가 되는 데 오래 걸리지 않는다는 것이 밝혀졌다.
따라서 (적어도 돌이켜보면) 놀랍지 않게도 이 책의 초판 독자 중 다수는 헥사고날 아키텍처로 여러 바운디드 컨텍스트를 관리하는 방법에 대해 질문했다. 불행히도 대답은 간단하지 않다. 종종 그렇듯이, 그것에 대해 여러 가지 방법이 있으며 그 중 어느 것도 본질적으로 옳거나 그르지 않다. 바운디드 컨텍스트를 분리하는 몇 가지 방법을 논의해 보자.

### 바운디드 컨텍스트당 하나의 헥사곤?
헥사고날 아키텍처와 여러 바운디드 컨텍스트로 작업할 때 우리의 반사 신경은 각 바운디드 컨텍스트에 대해 별도의 "헥사곤"을 만드는 것이다. 결과는 그림 13.1과 같을 것이다.

![[tom_hombergs_78.png]]
*그림 13.1 – 각 바운디드 컨텍스트가 자체 헥사곤으로 구현되는 경우, 바운디드 컨텍스트 간의 각 통신 라인에 대해 아웃고잉 포트, 어댑터 및 인커밍 포트가 필요하다*

각 바운디드 컨텍스트는 자체 헥사곤에 있으며, 상호 작용할 입력 포트를 제공하고 외부 세계와 상호 작용하기 위해 출력 포트를 사용한다.
이상적으로는 바운디드 컨텍스트가 서로 전혀 통신할 필요가 없으므로 둘 사이에 종속성이 없다. 그러나 실제 세계에서는 드물다. 왼쪽의 바운디드 컨텍스트가 오른쪽의 바운디드 컨텍스트의 일부 기능을 호출해야 한다고 가정하자.
헥사고날 아키텍처가 제공하는 아키텍처 요소를 사용하면 첫 번째 바운디드 컨텍스트에 출력 포트를 추가하고 두 번째 바운디드 컨텍스트에 입력 포트를 추가한다. 그런 다음 출력 포트를 구현하고 필요한 매핑을 수행하고 두 번째 바운디드 컨텍스트의 입력 포트를 호출하는 어댑터를 만든다.

문제 해결, 맞죠?
실제로 종이 위에서는 이것이 매우 깨끗한 해결책처럼 보인다. 바운디드 컨텍스트는 서로 최적으로 분리되어 있다. 그들 사이의 종속성은 포트와 어댑터의 형태로 명확하게 구조화되어 있다. 바운디드 컨텍스트 간의 새로운 종속성은 기존 포트에 명시적으로 추가하거나 새 포트를 추가해야 한다. 이러한 종속성을 만드는 데 많은 의식이 관련되어 있기 때문에 "우연히" 종속성이 스며들 가능성은 거의 없다.
그러나 두 개의 바운디드 컨텍스트 이상을 생각하면 이 아키텍처가 잘 확장되지 않는다는 것이 명백해진다. 두 개의 바운디드 컨텍스트와 하나의 종속성에 대해 하나의 어댑터(앞의 그림에서 도메인 어댑터라는 상자)를 구현해야 한다. 순환 종속성을 제외하면 세 개의 바운디드 컨텍스트에 대해 세 개의 어댑터, 네 개의 바운디드 컨텍스트에 대해 여섯 개의 어댑터 등을 구현해야 할 수 있다(그림 13.2 참조).¹

![[tom_hombergs_79.png]]
*그림 13.2 – 바운디드 컨텍스트 간의 잠재적 종속성 수는 순환 종속성을 제외하더라도 바운디드 컨텍스트 수에 비례하지 않게 증가한다*

각 종속성에 대해 적어도 하나의 관련 입력 및 출력 포트가 있는 하나의 어댑터를 구현해야 한다. 각 어댑터는 하나의 도메인 모델에서 다른 도메인 모델로 매핑해야 한다. 이것은 개발하고 유지 관리하는 데 금방 귀찮은 일이 된다. 귀찮고 가치보다 더 많은 노력이 필요한 경우 팀은 이를 피하기 위해 지름길을 택할 것이며, 결과적으로 언뜻 보기에는 헥사고날 아키텍처처럼 보이지만 약속하는 이점이 없는 아키텍처가 된다.

> 1 n개의 바운디드 컨텍스트 간의 잠재적 종속성을 계산하는 데 사용한 공식은 n-1 + n-2 + ... + 1이다. 첫 번째 바운디드 컨텍스트는 n-1개의 잠재적, 비순환 종속성을 갖고, 두 번째는 n-2개 등을 갖는다. 마지막 바운디드 컨텍스트는 다른 바운디드 컨텍스트에 대한 종속성을 가질 수 없다. 가질 수 있는 모든 종속성은 순환 종속성이 될 것이고, 우리는 순환 종속성을 허용하고 싶지 않기 때문이다.

헥사고날 아키텍처를 소개하는 원본 기사를 보면, 헥사고날 아키텍처의 의도는 단일 바운디드 컨텍스트를 포트와 어댑터에 캡슐화하는 것이 아니었다.² 대신, 의도는 애플리케이션을 캡슐화하는 것이다. 이 애플리케이션은 많은 바운디드 컨텍스트로 구성될 수도 있고 전혀 없을 수도 있다.
각 바운디드 컨텍스트를 자체 애플리케이션, 즉 자체 (마이크로)서비스로 추출할 준비를 할 때 각 바운디드 컨텍스트를 자체 헥사곤으로 감싸는 것이 합리적이다. 즉, 우리가 그들 사이에 두는 경계가 올바른 경계이며 변경될 것으로 예상하지 않는다는 것을 매우 확신해야 한다.
여기서 얻을 수 있는 교훈은 헥사고날 아키텍처가 동일한 애플리케이션에서 여러 바운디드 컨텍스트를 관리하기 위한 확장 가능한 솔루션을 제공하지 않는다는 것이다. 그리고 그럴 필요도 없다. 대신 도메인 주도 설계에서 영감을 받아 바운디드 컨텍스트를 분리할 수 있다. 왜냐하면 헥사곤 내에서는 원하는 모든 것을 할 수 있기 때문이다.

### 분리된 바운디드 컨텍스트
이전 섹션에서 우리는 포트와 어댑터가 각 바운디드 컨텍스트를 개별적으로 캡슐화하는 것이 아니라 전체 애플리케이션을 캡슐화해야 한다는 것을 배웠다. 그렇다면 바운디드 컨텍스트를 서로 어떻게 분리할까?
간단한 경우, 서로 통신하지 않는 바운디드 컨텍스트가 있을 수 있다. 코드를 통해 완전히 별개의 경로를 제공한다. 이 경우 그림 13.3과 같이 각 바운디드 컨텍스트에 대해 전용 입력 및 출력 포트를 구축할 수 있다.

![[tom_hombergs_80.png]]
*그림 13.3 – 바운디드 컨텍스트(점선)가 서로 통신할 필요가 없는 경우, 각각 자체 입력 포트를 구현하고 자체 출력 포트를 호출할 수 있다*

> 2 헥사고날 아키텍처에 대한 원본 기사: https://alistair.cockburn.us/hexagonal-architecture/.

이 예는 두 개의 바운디드 컨텍스트가 있는 헥사고날 아키텍처를 보여준다. 웹 어댑터는 애플리케이션을 구동하고 데이터베이스 어댑터는 애플리케이션에 의해 구동된다. 이러한 어댑터는 다른 모든 입력 및 출력 어댑터를 대표한다. 모든 애플리케이션이 데이터베이스가 있는 웹 애플리케이션인 것은 아니다.
각 바운디드 컨텍스트는 하나 이상의 전용 입력 포트를 통해 자체 사용 사례를 노출한다. 웹 어댑터는 모든 입력 포트를 알고 있으므로 모든 바운디드 컨텍스트의 기능을 호출할 수 있다.
바운디드 컨텍스트 각각에 대해 전용 입력 포트를 갖는 대신, 웹 어댑터가 여러 바운디드 컨텍스트에 요청을 라우팅하는 하나의 "광범위한" 입력 포트를 구현할 수도 있다.
이 경우 컨텍스트 간의 경계는 헥사곤 외부에서 숨겨진다.
상황에 따라 바람직할 수도 있고 그렇지 않을 수도 있다.
또한 각 바운디드 컨텍스트는 다른 바운디드 컨텍스트와 독립적으로 데이터를 저장하고 검색할 수 있도록 데이터베이스에 대한 자체 출력 포트를 정의한다.
바운디드 컨텍스트당 입력 포트를 분할하는 것은 선택 사항이지만, 바운디드 컨텍스트에 대한 도메인 데이터를 저장하고 검색하는 출력 포트를 다른 바운디드 컨텍스트와 분리하여 유지하는 것을 강력히 권장한다. 한 바운디드 컨텍스트가 금융 거래와 관련이 있고 다른 하나가 사용자 등록과 관련이 있는 경우, 거래 데이터를 저장하고 검색하는 데 전념하는 하나 이상의 출력 포트와 등록 데이터를 저장하고 검색하는 데 전념하는 다른 출력 포트가 있어야 한다.
각 바운디드 컨텍스트는 자체 영속성을 가져야 한다. 바운디드 컨텍스트가 데이터를 저장하고 검색하기 위해 출력 포트를 공유하면 동일한 데이터 모델에 모두 의존하기 때문에 빠르게 강력하게 결합된다. 헥사고날 애플리케이션에서 한 바운디드 컨텍스트를 꺼내 자체 마이크로서비스로 만들어야 한다고 상상해보라. 왜냐하면 나머지 애플리케이션과 다른 확장성 요구 사항이 있다는 것을 알았기 때문이다. 해당 바운디드 컨텍스트가 다른 바운디드 컨텍스트와 데이터베이스 모델을 공유하면 추출하기가 매우 어려워진다. 새로운 마이크로서비스가 다른 애플리케이션의 데이터베이스에 도달하는 것을 원하지 않을 것이다, 그렇지 않은가? 같은 이유로 각 바운디드 컨텍스트의 데이터베이스 모델을 분리하여 유지하고 싶다.
여러 바운디드 컨텍스트가 동일한 런타임에서 실행되는 한, 물리적 데이터베이스를 공유하고 동일한 데이터베이스 트랜잭션에 참여할 수 있다. 그러나 해당 데이터베이스 내에는 예를 들어 별도의 데이터베이스 스키마 또는 적어도 다른 데이터베이스 테이블의 형태로 다른 바운디드 컨텍스트의 데이터 간에 명확한 경계가 있어야 한다.
이와 같이 입력 및 출력 포트를 분할하면 바운디드 컨텍스트가 완전히 분리되는 좋은 효과가 있다. 각 바운디드 컨텍스트는 다른 컨텍스트에 영향을 주지 않고 자체적으로 발전할 수 있다. 그러나 그들은 서로 이야기하지 않기 때문에 분리되어 있을 뿐이다. 여러 바운디드 컨텍스트에 걸친 사용 사례가 있거나 한 바운디드 컨텍스트가 다른 컨텍스트와 대화해야 하는 경우는 어떻게 될까?

### 적절하게 결합된 바운디드 컨텍스트
모든 결합을 피할 수 있다면 소프트웨어 아키텍처는 훨씬 쉬울 것이다. 실제 애플리케이션에서는 바운디드 컨텍스트가 작업을 수행하기 위해 다른 바운디드 컨텍스트의 도움이 필요할 가능성이 매우 높다.
예를 들어, 다시 돈 거래와 관련된 바운디드 컨텍스트가 있다. 보안상의 이유로 어떤 사용자가 거래를 발행했는지 기록하고 싶을 것이다. 즉, 우리 바운디드 컨텍스트는 다른 바운디드 컨텍스트에 있는 사용자에 대한 일부 정보가 필요하다. 그러나 우리 바운디드 컨텍스트는 사용자 관리 컨텍스트에 긴밀하게 결합될 필요는 없다.
"거래 관리" 바운디드 컨텍스트에서 전체 사용자 객체를 알아야 하는 대신 사용자의 ID만 알면 충분할 수 있다. "등록" 컨텍스트의 사용자 객체는 많은 속성을 가진 복잡한 객체이지만, 거래 컨텍스트에서 사용자를 나타내는 것은 사용자 ID를 둘러싼 래퍼일 수 있다. 송금 사용 사례에서 이제 거래를 실행하는 사용자의 ID를 입력으로 받아 기록할 수 있다. 거래 컨텍스트를 사용자의 다른 모든 세부 정보에 결합할 필요는 없다.
그러나 사용자가 거래에서 차단되지 않았는지 확인하고 싶을 수 있다. 이 경우 도메인 이벤트를 사용할 수 있다.³ 사용자 관리 컨텍스트에서 사용자 상태가 변경될 때마다 다른 바운디드 컨텍스트에서 수신할 수 있는 도메인 이벤트를 트리거한다. 예를 들어, 우리 거래 컨텍스트는 사용자가 새로 등록되거나 차단되었을 때 이벤트를 수신할 수 있다. 그런 다음 나중에 송금 사용 사례에서 사용자 상태를 확인하기 위해 자체 데이터베이스에 해당 정보를 저장할 수 있다.
또 다른 가능한 해결책은 사용자 관리와 거래 컨텍스트 간의 오케스트레이터로 애플리케이션 서비스를 도입하는 것이다.⁴ 애플리케이션 서비스는 송금 입력 포트를 구현한다. 호출되면 먼저 사용자 관리 바운디드 컨텍스트에 사용자 상태를 요청한 다음 거래 컨텍스트에서 제공하는 송금 사용 사례에 상태를 전달한다. 다른 구현이지만 도메인 이벤트를 사용할 때와 동일한 효과이다.
이것들은 바운디드 컨텍스트를 "적절하게" 결합하는 방법에 대한 두 가지 예일 뿐이다. 아직 읽지 않았다면 영감을 얻기 위해 도메인 주도 설계 문헌을 읽어보는 것이 좋다.
헥사고날 아키텍처로 돌아와서, 여러 바운디드 컨텍스트를 적절하게 결합하는 것은 그림 13.4와 같을 수 있다.

> 3 도메인 주도 설계의 이벤트: 본 버논의 『도메인 주도 설계 구현』, 피어슨, 2013, 8장.
> 4 도메인 주도 설계의 애플리케이션 서비스: 본 버논의 『도메인 주도 설계 구현』, 피어슨, 2013, 14장.

![[tom_hombergs_81.png]]
*그림 13.4 – 여러 바운디드 컨텍스트에 걸친 사용 사례가 있는 경우, 컨텍스트 간에 정보를 조정하고 공유하기 위해 애플리케이션 서비스와 도메인 이벤트를 도입할 수 있다*

우리는 바운디드 컨텍스트 위에 오케스트레이터로 애플리케이션 서비스를 도입했다.
입력 포트는 이제 바운디드 컨텍스트 자체가 아니라 이 서비스에 의해 구현된다.
애플리케이션 서비스는 다른 시스템에서 필요한 정보를 얻기 위해 출력 포트를 호출한 다음 바운디드 컨텍스트에서 제공하는 하나 이상의 도메인 서비스를 호출할 수 있다. 바운디드 컨텍스트에 대한 호출을 조정하는 것 외에도 애플리케이션 서비스는 트랜잭션 경계 역할을 하여 예를 들어 동일한 데이터베이스 트랜잭션에서 여러 도메인 서비스를 호출할 수 있도록 한다.
바운디드 컨텍스트 내의 도메인 서비스는 바운디드 컨텍스트 간의 데이터 모델을 분리하여 유지하기 위해 여전히 자체 데이터베이스 출력 포트를 사용한다. 이 분리가 필요하지 않다고 결정하고 대신 단일 데이터베이스 출력 포트를 사용할 수 있다(그러나 데이터 모델을 공유하면 매우 긴밀한 결합이 발생한다는 점을 인지해야 한다).
바운디드 컨텍스트는 정보를 느슨하게 결합된 방식으로 교환하기 위해 각각 내보내고 수신할 수 있는 공유 도메인 이벤트 집합에 액세스할 수 있다.

### 이것이 유지보수 가능한 소프트웨어를 구축하는 데 어떻게 도움이 되는가?
도메인 간의 경계를 관리하는 것은 소프트웨어 개발에서 가장 어려운 부분 중 하나이다. 작은 코드베이스에서는 전체 코드베이스의 정신 모델이 여전히 우리 뇌의 작업 기억에 맞기 때문에 경계가 필요하지 않을 수 있다. 그러나 코드베이스가 특정 크기에 도달하는 즉시, 각 도메인을 격리하여 추론할 수 있도록 도메인 간에 경계를 도입해야 한다. 이렇게 하지 않으면 종속성이 스며들어 코드베이스가 두려운 "큰 진흙 덩어리" 중 하나가 된다.
헥사고날 아키텍처는 애플리케이션과 외부 세계 간의 경계를 관리하는 것이다. 경계는 애플리케이션에서 제공하는 특정 입력 포트와 애플리케이션에서 예상하는 특정 출력 포트로 구성된다.
헥사고날 아키텍처는 애플리케이션 내에서 더 세분화된 경계를 관리하는 데 도움이 되지 않는다.
"헥사곤" 내부에서는 원하는 모든 것을 할 수 있다. 코드베이스가 작업 기억에 비해 너무 커지면 도메인 주도 설계 또는 기타 개념으로 돌아가 코드베이스 내에 경계를 만들어야 한다.
다음 장에서는 헥사고날 아키텍처 유무에 관계없이 사용할 수 있는 경계를 만드는 경량 방법을 탐색할 것이다.

---

# 14. 소프트웨어 아키텍처에 대한 구성 요소 기반 접근 방식
소프트웨어 프로젝트를 시작할 때, 우리는 사용자가 실제로 소프트웨어를 사용할 때 우리에게 던질 모든 요구 사항을 결코 알지 못한다. 소프트웨어 프로젝트는 항상 기회를 잡고 교육받은 추측을 하는 것과 관련이 있다(우리는 이것을 더 전문적으로 들리게 하기 위해 "가정"이라고 부르는 것을 좋아한다). 소프트웨어 프로젝트의 환경은 모든 것이 어떻게 전개될지 미리 알기에는 너무 변덕스럽다. 이러한 변동성 때문에 애자일 운동이 탄생했다. 애자일 관행은 조직이 변화에 적응할 수 있을 만큼 유연하게 만든다.
하지만 어떻게 이러한 애자일 환경에 대처할 수 있는 소프트웨어 아키텍처를 만들 수 있을까? 모든 것이 언제든지 바뀔 수 있다면, 아키텍처에 신경을 써야 할까?
그렇다, 그래야 한다. 1장, 유지보수성에서 논의했듯이, 우리는 소프트웨어 아키텍처가 유지보수성을 가능하게 하도록 해야 한다. 유지보수 가능한 코드베이스는 시간이 지남에 따라 발전하여 외부 요인에 적응할 수 있다.
헥사고날 아키텍처는 유지보수성을 향한 큰 발걸음을 내딛는다. 그것은 우리 애플리케이션과 외부 세계 사이에 경계를 만든다. 애플리케이션 내부(헥사곤 내)에는 외부 세계에 전용 포트를 제공하는 도메인 코드가 있다. 이러한 포트는 애플리케이션을 어댑터에 연결하며, 어댑터는 외부 세계와 통신하여 우리 애플리케이션의 언어와 외부 시스템의 언어 사이를 번역한다. 이 아키텍처는 애플리케이션이 외부 세계와 대부분 독립적으로 발전할 수 있기 때문에 유지보수성을 향상시킨다. 포트가 변경되지 않는 한, 우리는 애자일 환경의 변화에 대응하기 위해 애플리케이션 내의 모든 것을 발전시킬 수 있다.
하지만 13장, 여러 바운디드 컨텍스트 관리하기에서 배웠듯이, 헥사고날 아키텍처는 애플리케이션 코어 내에 경계를 만드는 데 도움이 되지 않는다. 이와 관련하여 도움이 되는 다른 아키텍처를 애플리케이션 코어 내에 적용하고 싶을 수 있다.
또한, 헥사고날 아키텍처는 특히 막 시작하는 소프트웨어 프로젝트의 경우 어렵게 느껴진다는 말을 꽤 여러 번 들었다. 모든 사람이 종속성 역전과 도메인 모델과 외부 세계 간의 매핑의 가치를 이해하지 못하기 때문에 팀을 참여시키기가 어렵다.
헥사고날 아키텍처는 신생 애플리케이션에는 과잉일 수 있다.
이러한 경우, 우리는 미래에 다른 것으로 발전하는 데 필요한 모듈성을 여전히 제공하지만 모든 사람이 참여할 수 있을 만큼 간단한 더 간단한 아키텍처 스타일로 시작하고 싶을 수 있다. 나는 구성 요소 기반 아키텍처가 좋은 출발점이라고 제안하며, 이 장을 사용하여 이 아키텍처 스타일에 대해 논의할 것이다.

### 구성 요소를 통한 모듈성
유지보수성의 동인 중 하나는 모듈성이다. 모듈성을 통해 우리는 소프트웨어 시스템을 더 간단한 모듈로 나누어 복잡성을 극복할 수 있다. 특정 모듈에서 작업하기 위해 전체 시스템을 이해할 필요는 없다. 대신, 해당 모듈과 인터페이스하는 모듈에 집중할 수 있다. 모듈 간의 인터페이스가 명확하게 정의되어 있는 한, 모듈은 대부분 서로 독립적으로 발전할 수 있다. 우리는 아마도 하나의 모듈의 정신 모델을 작업 기억에 맞출 수 있지만, 코드베이스에 모듈이 없다면 정신 모델을 만드는 데 행운을 빈다. 우리는 코드에서 다소 무기력하게 뛰어다닐 것이다.
모듈성만이 인간이 복잡한 시스템을 만들 수 있게 한다. 그의 저서 『현대 소프트웨어 공학』에서 데이브 팔리는 아폴로 우주 프로그램의 모듈성에 대해 다음과 같이 이야기한다.¹
“이 모듈성에는 많은 장점이 있었다. 각 구성 요소가 문제의 한 부분에 집중하여 구축될 수 있고 설계에서 타협할 필요가 적다는 것을 의미했다. 다른 그룹(이 경우 완전히 다른 회사)이 각 모듈에서 다른 그룹과 거의 독립적으로 작업할 수 있게 했다. 다른 그룹이 모듈이 서로 어떻게 인터페이스할지에 동의하는 한, 제약 없이 모듈의 문제를 해결하기 위해 작업할 수 있었다.”
모듈성 덕분에 우리는 달에 갈 수 있었다! 모듈성 덕분에 우리는 자동차, 항공기, 건물을 지을 수 있다. 그것이 복잡한 소프트웨어를 구축하는 데에도 도움이 된다는 것은 놀라운 일이 아니다.
하지만 모듈이란 무엇인가? 나는 이 용어가 (객체 지향) 소프트웨어 개발에서 과부하되었다고 느낀다.
유용한 일을 하기 위해 되는대로 함께 던져진 클래스 묶음일지라도 모든 것과 그 고양이는 "모듈"이라고 불린다. 나는 복잡한 시스템을 구축하기 위해 다른 클래스 그룹과 함께 구성될 수 있는 특정 기능을 구현하기 위해 신중하게 설계된 클래스 그룹을 설명하기 위해 "구성 요소"라는 용어를 선호한다. 구성 측면은 구성 요소가 더 큰 전체를 형성하기 위해 구성될 수 있고 잠재적으로 환경의 변화에 대응하기 위해 재구성될 수도 있음을 의미한다. 구성 가능성은 구성 요소가 외부 세계에 제공하고 필요로 하는 것(입력 및 출력 포트, 누구?)을 알려주는 명확한 인터페이스를 정의해야 함을 요구한다. 레고 블록을 생각해보라. 레고 블록은 다른 블록이 부착될 특정 스터드 레이아웃을 제공하고 다른 블록에 부착하기 위해 특정 스터드 레이아웃이 필요하다. 즉, "모듈"이라는 용어를 사용하더라도 판단하지 않겠지만, 이 장의 나머지 부분에서는 "구성 요소"를 참조할 것이다.

> 1 아폴로 우주 프로그램의 모듈성: 데이브 팔리의 『현대 소프트웨어 공학』, 피어슨, 2022, 6장.

이 장의 목적을 위해, 구성 요소는 전용 네임스페이스와 명확하게 정의된 API를 가진 클래스 집합이다. 다른 구성 요소가 이 구성 요소의 기능이 필요한 경우 API를 통해 호출할 수 있지만 내부로 들어갈 수는 없다. 구성 요소는 더 작은 구성 요소로 구성될 수 있다.
기본적으로 이러한 하위 구성 요소는 부모 구성 요소의 내부에 있으므로 외부에서 액세스할 수 없다. 그러나 외부에서 액세스할 수 있어야 하는 기능을 구현하는 경우 부모 구성 요소의 API에 기여할 수 있다.
다른 아키텍처 스타일과 마찬가지로 구성 요소 기반 아키텍처는 어떤 종속성이 허용되고 어떤 것이 권장되지 않는지에 관한 것이다. 이것은 그림 14.1에 설명되어 있다.

![[tom_hombergs_82.png]]
*그림 14.1 – 내부 패키지에 대한 종속성은 유효하지 않지만 API 패키지가 내부 패키지에 중첩되지 않은 경우 API 패키지에 대한 종속성은 유효하다*

여기에는 두 개의 최상위 구성 요소 A와 B가 있다. 구성 요소 A는 두 개의 하위 구성 요소 A1과 A2로 구성되어 있고, 구성 요소 B는 단일 하위 구성 요소 B1만 있다.
A1이 B의 기능에 액세스해야 하는 경우 B의 API를 호출하여 얻을 수 있다. 그러나 하위 구성 요소로서 부모의 내부에 속하므로 외부에서 숨겨져 있기 때문에 B1의 API에 액세스할 수 없다.
B1은 부모 API의 인터페이스를 구현하여 부모의 API에 기능을 계속 기여할 수 있다. 나중에 사례 연구에서 이것이 실제로 작동하는 것을 볼 것이다.
동일한 규칙이 형제 구성 요소인 A1과 A2 사이에도 적용된다. A1이 A2의 기능에 액세스해야 하는 경우 API를 호출할 수 있지만 A2의 내부로 호출할 수는 없다.

그리고 그것이 구성 요소 기반 아키텍처의 전부이다. 네 가지 간단한 규칙으로 요약할 수 있다.
1.  구성 요소에는 주소 지정이 가능한 전용 네임스페이스가 있다.
2.  구성 요소에는 전용 API와 내부가 있다.
3.  구성 요소의 API는 외부에서 호출할 수 있지만 내부는 호출할 수 없다.
4.  구성 요소는 내부의 일부로 하위 구성 요소를 포함할 수 있다.

추상적인 것을 구체적으로 만들기 위해 실제 코드에서 구성 요소 기반 아키텍처를 살펴보자.

### 사례 연구 – "엔진 점검" 구성 요소 구축
이 장에서 제시된 구성 요소 기반 아키텍처에 대한 사례 연구로, 내가 작업했던 실제 소프트웨어 프로젝트에서 구성 요소를 추출하여 독립 실행형 GitHub 리포지토리로 만들었다.² 내가 비교적 적은 노력으로 구성 요소를 추출했고, 우리가 그것이 나온 소프트웨어 프로젝트에 대해 아무것도 모르고도 이 구성 요소에 대해 추론할 수 있다는 사실만으로도 모듈성을 적용하여 복잡성을 성공적으로 정복했음을 보여준다!
구성 요소는 객체 지향 Kotlin으로 작성되었지만 개념은 다른 모든 객체 지향 언어에 적용된다.
구성 요소의 이름은 "엔진 점검"이다. 웹 페이지를 탐색하고 일련의 검사를 실행하는 일종의 웹 스크레이퍼가 되도록 의도되었다. 이러한 검사는 "해당 웹 페이지의 HTML이 유효한지 확인"에서 "해당 웹 페이지의 모든 철자 오류 반환"에 이르기까지 무엇이든 될 수 있다.
웹 페이지를 스크래핑할 때 많은 문제가 발생할 수 있으므로 검사를 비동기적으로 실행하기로 결정했다.
즉, 구성 요소는 검사를 예약하는 API와 실행된 후 검사 결과를 검색하는 API를 제공해야 한다. 이는 들어오는 검사 요청을 저장할 큐와 이러한 검사 결과를 저장할 데이터베이스를 의미한다.
외부에서 보면, 우리가 엔진 점검을 "한 조각으로" 구축하든 하위 구성 요소로 나누든 상관없다. 구성 요소에 전용 API가 있는 한 이러한 세부 정보는 외부에서 숨겨진다. 그러나 위의 요구 사항은 엔진 점검 내의 하위 구성 요소에 대한 특정 자연스러운 경계를 설명한다. 이러한 경계를 따라 엔진 점검을 나누면 각 하위 구성 요소가 전체 문제보다 관리하기가 더 간단하기 때문에 엔진 점검 구성 요소 내에서 복잡성을 관리할 수 있다.

> 2 구성 요소 기반 아키텍처로 구현된 "엔진 점검"이 있는 GitHub 프로젝트: https://github.com/thombergs/components-example.

우리는 엔진 점검을 위해 세 가지 하위 구성 요소를 생각해 냈다.
- 큐 구성 요소: 검사 요청을 큐에 넣고 디큐하는 큐에 대한 액세스를 래핑한다.
- 데이터베이스 구성 요소: 검사 결과를 저장하고 검색하는 데이터베이스에 대한 액세스를 래핑한다.
- 검사 실행기 구성 요소: 실행할 검사를 알고 큐에서 검사 요청이 들어올 때마다 실행한다.

이러한 하위 구성 요소는 대부분 기술적인 경계를 도입한다는 점에 유의하라. 헥사고날 아키텍처의 출력 어댑터와 매우 유사하게, 우리는 외부 시스템(큐 및 데이터베이스)에 액세스하는 특수성을 하위 구성 요소에 숨기고 있다. 그러나 엔진 점검 구성 요소는 도메인 코드가 거의 또는 전혀 없는 매우 기술적인 구성 요소이다. "도메인 코드"로 간주할 수 있는 유일한 구성 요소는 일종의 컨트롤러 역할을 하는 검사 실행기이다. 기술 구성 요소는 경계가 다른 기능 도메인 간의 경계보다 명확하기 때문에 구성 요소 기반 아키텍처에 매우 적합하다.
세부 사항을 파고들기 위해 엔진 점검 구성 요소의 아키텍처 다이어그램을 살펴보자(그림 14.2).

![[tom_hombergs_83.png]]
*그림 14.2 – 엔진 점검 구성 요소는 부모 구성 요소의 API에 기여하는 세 개의 하위 구성 요소로 구성된다*

다이어그램은 코드 구조를 반영한다. 각 상자를 Java 패키지(또는 다른 프로그래밍 언어의 간단한 소스 코드 폴더)로 생각할 수 있다. 상자가 더 큰 상자 안에 있으면 더 큰 상자의 하위 패키지이다. 마지막으로 가장 낮은 수준의 상자는 클래스이다.
엔진 점검 구성 요소의 공개 API는 웹 페이지 검사를 예약하고 검사 결과를 검색할 수 있는 `CheckScheduler` 및 `CheckQueries` 인터페이스로 구성된다.
`CheckScheduler`는 큐 구성 요소 내부에 있는 `SqsCheckScheduler` 클래스에 의해 구현된다. 이런 식으로 큐 구성 요소는 부모 구성 요소의 API에 기여한다. 이 클래스의 이름을 볼 때만 Amazon의 Simple Queue Service(SQS)를 사용하고 있음을 알 수 있다. 이 구현 세부 정보는 엔진 점검 구성 요소 외부로 유출되지 않는다. 형제 구성 요소조차도 어떤 큐 기술이 사용되는지 모른다. 큐 구성 요소에는 API 패키지가 없으므로 모든 클래스가 내부적이라는 것을 알 수 있다!
그런 다음 `CheckRequestListener` 클래스는 큐에서 들어오는 요청을 수신한다. 들어오는 각 요청에 대해 검사 실행기 하위 구성 요소의 API에서 `CheckRunner` 인터페이스를 호출한다.
`DefaultCheckRunner`는 해당 인터페이스를 구현한다. 들어오는 요청에서 웹 페이지 URL을 읽고, 실행할 검사를 결정한 다음 해당 검사를 실행한다.
검사가 완료되면 `DefaultCheckRunner` 클래스는 데이터베이스 하위 구성 요소의 API의 `CheckMutations` 인터페이스를 호출하여 결과를 데이터베이스에 저장한다. 이 인터페이스는 데이터베이스에 연결하고 통신하는 세부 정보를 처리하는 `CheckRepository` 클래스에 의해 구현된다. 다시 말하지만, 데이터베이스 기술은 데이터베이스 하위 구성 요소 외부로 유출되지 않는다.
`CheckRepository` 클래스는 또한 엔진 점검의 공개 API의 일부인 `CheckQueries` 인터페이스를 구현한다. 이 인터페이스는 검사 결과를 쿼리하는 메서드를 제공한다.
엔진 점검 구성 요소를 세 개의 하위 구성 요소로 분할함으로써 복잡성을 나누었다.
각 하위 구성 요소는 전체 문제의 더 간단한 부분을 해결한다. 대부분 자체적으로 발전할 수 있다. 비용, 확장성 또는 기타 이유로 큐 또는 데이터베이스 기술을 변경해도 다른 하위 구성 요소로 유출되지 않는다. 원한다면 테스트를 위해 하위 구성 요소를 간단한 인메모리 구현으로 교체할 수도 있다.
이 모든 것은 코드를 구성 요소로 구조화하고 전용 API 및 내부 패키지를 갖는 규칙을 따름으로써 얻을 수 있다.

### 구성 요소 경계 강제하기
규칙은 있는 것이 좋지만, 그것이 전부라면 누군가 규칙을 어기고 아키텍처가 침식될 것이다. 우리는 구성 요소 아키텍처의 규칙을 강제해야 한다.
구성 요소 아키텍처의 좋은 점은 비교적 간단한 적합성 함수를 적용하여 구성 요소 아키텍처에 우발적인 종속성이 스며들지 않았는지 확인할 수 있다는 것이다.
"내부" 패키지 외부에 있는 클래스는 해당 "내부" 패키지 내부의 클래스에 액세스해서는 안 된다.

구성 요소의 모든 내부를 "internal"이라는 패키지(또는 다른 방식으로 "internal"로 표시된 패키지)에 넣으면 해당 패키지의 어떤 클래스도 해당 패키지 외부에서 호출되지 않는지 확인하기만 하면 된다. JVM 기반 프로젝트의 경우 ArchUnit을 사용하여 이 적합성 함수를 코딩할 수 있다.³

```kotlin
fun assertPackageIsNotAccessedFromOutside(internalPackage: String) {
    noClasses()
        .that()
        .resideOutsideOfPackage(packageMatcher(internalPackage))
        .should()
        .dependOnClassesThat()
        .resideInAPackage(packageMatcher(internalPackage))
        .check(analyzedClasses)
}
```

각 빌드 중에 내부 패키지를 식별하고 위의 함수에 모두 공급하는 방법만 있으면 되며, 실수로 내부 클래스에 대한 종속성을 도입한 경우 빌드가 실패한다.
적합성 함수는 아키텍처의 구성 요소에 대해 아무것도 알 필요조차 없다.
내부 패키지를 식별하기 위한 규칙을 따르고 해당 패키지를 함수에 공급하기만 하면 된다. 즉, 코드베이스에 구성 요소를 추가하거나 제거할 때마다 적합성 함수를 실행하는 테스트를 업데이트할 필요가 없다. 매우 편리하다!

> **참고**
> 이 적합성 함수는 12장, 아키텍처 경계 강제하기에서 소개한 적합성 함수의 반대 형태이다. 12장에서는 특정 패키지의 클래스가 해당 패키지 외부의 클래스에 액세스하지 않는지 확인했다. 여기서는 패키지 외부의 클래스가 패키지 내부의 클래스에 액세스하지 않는지 확인한다. 이 적합성 함수는 우리가 사용하는 모든 라이브러리에 대해 예외를 추가할 필요가 없기 때문에 훨씬 더 안정적이다.

물론 내부 패키지에 대한 규칙을 따르지 않음으로써 원치 않는 종속성을 여전히 도입할 수 있다. 그리고 규칙은 여전히 허점을 허용한다. 최상위 구성 요소의 "internal" 패키지에 클래스를 직접 넣으면 모든 하위 구성 요소의 클래스가 액세스할 수 있다. 따라서 최상위 구성 요소의 "internal" 패키지에 직접 클래스를 허용하지 않는 또 다른 규칙을 도입하고 싶을 수 있다.

> 3 특정 패키지 내의 코드에 액세스하는 코드가 없는지 확인하는 ArchUnit 규칙: https://github.com/thombergs/components-example/blob/main/server/src/test/kotlin/io/reflectoring/components/InternalPackageTest.kt.

### 이것이 유지보수 가능한 소프트웨어를 구축하는 데 어떻게 도움이 되는가?
구성 요소 기반 아키텍처는 매우 간단하다. 각 구성 요소에 전용 네임스페이스, 전용 API 및 내부 패키지가 있고 내부 패키지 내의 클래스가 외부에서 호출되지 않는 한, 우리는 구성 가능하고 재구성 가능한 많은 구성 요소로 구성된 매우 유지보수하기 쉬운 코드베이스를 얻는다. 구성 요소가 다른 구성 요소로 구성될 수 있다는 규칙을 추가하면 각 부분이 더 간단한 문제를 해결하는 더 작고 작은 부분으로 전체 애플리케이션을 구축할 수 있다.
구성 요소 아키텍처의 규칙을 피할 수 있는 허점이 있더라도 아키텍처 자체는 매우 간단하여 이해하고 전달하기가 매우 쉽다. 이해하기 쉬우면 유지 관리하기 쉽다. 유지 관리하기 쉬우면 허점이 악용될 가능성이 적다.
헥사고날 아키텍처는 애플리케이션 수준의 경계에 신경 쓴다. 구성 요소 기반 아키텍처는 구성 요소 수준의 경계에 신경 쓴다. 이를 사용하여 헥사고날 아키텍처 내에 구성 요소를 포함하거나, 간단한 구성 요소 기반 아키텍처로 시작하여 필요한 경우 다른 아키텍처로 발전시킬 수 있다. 구성 요소 기반 아키텍처는 설계상 모듈식이며 모듈은 이동 및 리팩토링이 쉽다.
다음 마지막 장에서는 아키텍처에 대한 논의를 마무리하고 어떤 아키텍처 스타일을 언제 선택해야 하는지에 대한 질문에 답하려고 노력할 것이다.

---

# 15. 아키텍처 스타일 결정하기
지금까지 이 책은 헥사고날 아키텍처 스타일로 웹 애플리케이션을 구축하는 독단적인 접근 방식을 제공했다. 코드 구성에서 지름길 택하기에 이르기까지, 우리는 이 아키텍처 스타일이 우리에게 직면하게 하는 많은 질문에 답했다.
이 책의 일부 답변은 기존의 계층적 아키텍처 스타일에 적용될 수 있다. 일부 답변은 이 책에서 제안한 것과 같은 도메인 중심 접근 방식에서만 구현할 수 있다.
그리고 일부 답변은 당신의 경험에 맞지 않았기 때문에 동의하지 않을 수도 있다.
그러나 우리가 답을 원하는 마지막 질문은 다음과 같다: 실제로 헥사고날 아키텍처 스타일을 언제 사용해야 하는가? 그리고 언제 기존의 계층적 스타일(또는 다른 스타일)을 고수해야 하는가?

### 간단하게 시작하기
내가 깨닫는 데 너무 오래 걸린 중요한 점은 소프트웨어 아키텍처는 소프트웨어 프로젝트 초기에 정의하고 그 후에는 저절로 처리되는 것이 아니라는 것이다. 프로젝트 초기에 훌륭한 아키텍처를 설계하는 데 필요한 모든 것을 알 수는 없다! 소프트웨어 프로젝트의 아키텍처는 변화하는 요구 사항에 적응하기 위해 시간이 지남에 따라 발전할 수 있고 발전해야 한다.
이것은 장기적으로 어떤 아키텍처 스타일이 소프트웨어 프로젝트에 가장 적합할지 알 수 없으며, 미래에 아키텍처 스타일을 변경해야 할 수도 있다는 것을 의미한다! 이를 가능하게 하려면 소프트웨어가 변경에 유연하도록 해야 한다. 유지보수성의 씨앗을 심어야 한다.
유지보수성이란 각 모듈을 격리하여 작업하고 필요한 경우 코드베이스에서 이동할 수 있도록 코드를 모듈식으로 만들어야 함을 의미한다. 우리 아키텍처는 원치 않는 종속성이 우연히 스며들어 유지보수성을 저해하지 않도록 해당 모듈 간의 경계를 가능한 한 명확하게 만들어야 한다.
프로젝트 시작 시에는 CRUD 유스케이스 모음만 포함될 수 있으며, 헥사고날 아키텍처와 같은 도메인 중심 아키텍처는 과잉일 수 있으므로 구성 요소 기반 접근 방식과 같이 더 간단한 것을 선택한다. 또는 이미 프로젝트에 대해 충분히 알고 있어서 풍부한 도메인 모델을 구축하기 시작할 수 있으며, 이 경우 헥사고날 아키텍처 스타일이 시작하기에 적합할 수 있다.

### 도메인 발전시키기
시간이 지남에 따라 우리는 소프트웨어의 요구 사항에 대해 점점 더 많이 배우고 최상의 아키텍처 스타일에 대해 점점 더 나은 결정을 내릴 수 있다. 애플리케이션은 간단한 CRUD 유스케이스 모음에서 많은 비즈니스 규칙이 있는 풍부한 도메인 중심 애플리케이션으로 발전할 수 있다. 이 시점에서 헥사고날 아키텍처 스타일이 좋은 옵션이 된다.
이전 장에서 헥사고날 아키텍처 스타일의 주요 특징은 영속성 문제 및 외부 시스템에 대한 종속성과 같은 전환에서 자유롭게 도메인 코드를 개발할 수 있다는 것이 분명해졌을 것이다. 내 생각에 외부 영향에서 자유롭게 도메인 코드를 발전시키는 것이 헥사고날 아키텍처 스타일에 대한 가장 중요한 단일 주장이다.
이것이 이 아키텍처 스타일이 DDD 관행과 잘 어울리는 이유이다. 명백한 것을 말하자면, DDD에서는 도메인이 개발을 주도하며, 영속성 문제 및 기타 기술적 측면을 동시에 생각할 필요가 없을 때 도메인에 대해 가장 잘 추론할 수 있다.
나는 심지어 헥사고날 스타일과 같은 도메인 중심 아키텍처 스타일이 DDD의 조력자라고 말하고 싶다. 도메인을 사물의 중심에 두는 아키텍처가 없고, 도메인 코드를 향한 종속성을 역전시키지 않으면 DDD를 실제로 할 기회가 없다. 디자인은 항상 다른 요인에 의해 주도될 것이다.
따라서 이 책에서 제시된 아키텍처 스타일을 사용할지 여부에 대한 첫 번째 지표는 다음과 같다. 애플리케이션에서 도메인 코드가 가장 중요한 것이 아니라면 아마도 이 아키텍처 스타일이 필요하지 않을 것이다.

### 경험을 믿으세요
우리는 습관의 동물이다. 습관은 우리를 위해 결정을 자동화하므로 시간을 할애할 필요가 없다.
사자가 우리를 향해 달려오면 우리는 달린다. 새로운 웹 애플리케이션을 구축하면 계층적 아키텍처 스타일을 사용한다. 과거에 너무 많이 해서 습관이 되었다.
습관적인 결정이 반드시 나쁜 결정이라고 말하는 것은 아니다. 습관은 나쁜 결정을 내리는 데 도움이 되는 것만큼 좋은 결정을 내리는 데에도 도움이 된다. 나는 우리가 경험한 것을 하고 있다고 말하는 것이다. 우리는 과거에 했던 것에 편안함을 느끼므로 왜 무엇이든 바꿔야 하는가?
따라서 아키텍처 스타일에 대한 교육받은 결정을 내리는 유일한 방법은 다른 아키텍처 스타일에 대한 경험을 갖는 것이다. 헥사고날 아키텍처 스타일에 대해 확신이 서지 않는다면 현재 구축 중인 애플리케이션의 작은 모듈에서 시도해보라. 개념에 익숙해져라.
편안해져라. 이 책의 아이디어를 적용하고, 수정하고, 자신만의 아이디어를 추가하여 편안한 스타일을 개발하라.

이 경험은 다음 아키텍처 결정을 내리는 데 도움이 될 수 있다.

### 상황에 따라 다르다
소셜 미디어에서 정기적으로 떠도는 "당신은 어떤 성격 유형인가?" 및 "당신이 개라면 어떤 종류의 개일까?"와 같은 모든 테스트처럼 아키텍처 스타일을 결정하기 위한 객관식 질문 목록을 제공하고 싶다.¹
그러나 그렇게 간단하지 않다. 어떤 아키텍처 스타일을 선택해야 하는지에 대한 내 대답은 전문 컨설턴트의 대답인 "상황에 따라 다르다"로 남아 있다. 구축할 소프트웨어 유형에 따라 다르다. 도메인 코드의 역할에 따라 다르다. 팀의 경험에 따라 다르다. 그리고 마지막으로 결정에 편안함을 느끼는 것에 따라 다르다.
그러나 이 책이 아키텍처 문제에 도움이 되는 영감의 불꽃을 제공했기를 바란다. 헥사고날 아키텍처 유무에 관계없이 아키텍처 결정에 대한 이야기가 있다면 듣고 싶다.²

> 1 알고 싶으시다면, 저는 "수호자" 성격 유형이고, 만약 제가 개라면 분명 핏불일 것이다.
> 2 연락처: tom@reflectoring.io로 이메일을 보내주세요.
